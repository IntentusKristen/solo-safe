"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _MapSourceModule = _interopRequireDefault(require("../MapSourceModule"));

var _Feature = _interopRequireDefault(require("../../maps/geo/Feature"));

var _Http = _interopRequireDefault(require("../../network/Http"));

var _FeatureCollection = _interopRequireDefault(require("../../maps/geo/FeatureCollection"));

var _MapboxRouteService = _interopRequireDefault(require("./services/mapbox/MapboxRouteService"));

var _GoogleRouteService = _interopRequireDefault(require("./services/google/GoogleRouteService"));

var _utils = require("../../utils");

var _layout = require("../../utils/layout");

var _utils2 = require("./utils");

var _views = require("./views");

var _colors = require("./colors");

require("./styles/routing.css");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var __awaiter = void 0 && (void 0).__awaiter || function (thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function (resolve) {
      resolve(value);
    });
  }

  return new (P || (P = Promise))(function (resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }

    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }

    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }

    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};

const WEATHER_SEGMENTS = {
  temps: {
    value: 'temps',
    title: 'Temperatures'
  },
  winds: {
    value: 'winds',
    title: 'Wind Speeds'
  },
  windgusts: {
    value: 'windgusts',
    title: 'Wind Gusts'
  },
  weather: {
    value: 'weather',
    title: 'Weather'
  },
  alerts: {
    value: 'alerts',
    title: 'Alerts'
  }
};

class Routing extends _MapSourceModule.default {
  constructor(opts = null) {
    const vp = (0, _layout.viewportSizeClass)();
    super((0, _utils.extend)({
      weatherTypes: ['temps', 'winds', 'windgusts', 'weather', 'alerts'],
      insets: vp.width === 'compact' ? [0, 0] : [100, 100],
      refresh: 0,
      showInfoOnSelect: vp.width !== 'compact'
    }, opts));
    this.state = {
      dataType: (0, _utils.isset)(this.opts.weatherTypes) ? this.opts.weatherTypes[0] : 'temps',
      routeId: undefined
    };
    this.routeStore = new Map();
  }

  get id() {
    return this.opts.id;
  }

  source() {
    return {
      type: 'geojson',
      restrictToTimeline: false,
      data: {
        service: () => this.request,
        formatter: data => {
          const routeId = this.state.routeId;
          const routeData = this.routeStore.get(routeId);
          const features = (0, _utils2.generateRouteFeatures)(routeId, data, routeData);

          if (this.opts.onWeatherData) {
            this.opts.onWeatherData(features);
          }

          return features;
        }
      },
      style: {
        marker: data => (0, _utils2.getMarkerStyle)(data, this.routeStore.get(this.state.routeId)),
        polyline: data => {
          if ((0, _utils.get)(data, '0')) {
            data = (0, _utils.get)(data, '0');
          }

          const dataType = this.state.dataType;
          const color = (0, _colors.getColor)(dataType, data);
          return {
            stroke: {
              color,
              width: 6 // lineCap: 'square'

            }
          };
        }
      }
    };
  }

  controls() {
    const routes = this.opts.routes;
    const weatherTypes = this.opts.weatherTypes;
    const dataTypeSegments = (weatherTypes || []).map(type => Object.assign(Object.assign({}, WEATHER_SEGMENTS[type]), {
      id: type
    }));

    if (routes.length === 1) {
      const route = routes[0];
      return {
        value: route.id,
        title: route.title
      };
    }

    return {
      id: this.id,
      title: this.opts.title,
      filter: true,
      multiselect: false,
      reloadOnChange: false,
      segments: dataTypeSegments.length > 0 ? {
        groups: [{
          id: 'route',
          title: 'Route',
          segments: routes.map(route => ({
            value: route.id,
            title: route.title
          }))
        }, {
          id: 'datatype',
          title: 'Route Weather',
          segments: dataTypeSegments
        }]
      } : {
        groups: [{
          id: 'route',
          segments: routes.map(route => ({
            value: route.id,
            title: route.title
          }))
        }]
      }
    };
  }

  legend() {
    return {
      get: () => {
        let code;

        switch (this.state.dataType) {
          case 'temps':
            code = 'temps';
            break;

          case 'winds':
          case 'windgusts':
            code = 'winds';
            break;

          case 'weather':
            code = 'weather';
            break;

          case 'alerts':
            code = 'alerts';
            break;

          default:
        }

        return {
          code
        };
      }
    };
  }

  infopanel() {
    return {
      views: [(0, _views.assetInfoView)(info => {
        this.showRouteInfo(this.state.routeId, info);
      }), (0, _views.routeInfoView)(info => {
        this.showRouteInfo(this.state.routeId, info);
      }), {
        id: 'impacts',
        title: 'Short-Term Impacts',
        renderer: 'hazards'
      }, (0, _views.zoomRouteView)(() => {
        this.showRouteInfo(this.state.routeId);
      })]
    };
  }

  onInit() {
    this.request = this.account.api().endpoint((0, _utils2.getEndpointForDataType)(this.state.dataType)).action("route"
    /* ROUTE */
    );
    this.app.on('layer:change', e => {
      const {
        id,
        source,
        value
      } = e.data || {};

      if (id === this.id) {
        const {
          route,
          datatype
        } = value;

        if (source) {
          this.setRoute(route, datatype, source);
        }
      }
    });
  }

  onRemove() {
    if (this.refreshTimer) {
      window.clearTimeout(this.refreshTimer);
    }

    this.refreshTimer = undefined;
  }

  onData(results) {}

  onMarkerClick(marker, data) {
    const id = data.routeId;

    if (id) {
      this.showRouteInfo(id, data);
    }
  }

  dataForRoute(id = this.state.routeId) {
    return this.routeStore.get(id);
  }

  zoomToRoute(id = this.state.routeId, insets = this.opts.insets) {
    const routeData = this.routeStore.get(id);

    if (!routeData) {
      return;
    }

    const feature = routeData.feature;
    const bounds = feature.geometry.bounds();
    const vp = (0, _layout.viewportSizeClass)();
    this.map.fitBounds(bounds, insets);
  }

  setRoute(id, dataType, source) {
    const request = this.request;
    const endpoint = (0, _utils2.getEndpointForDataType)(dataType);
    const routeDidChange = id !== this.state.routeId;
    let needsReload = false; // select corresponding control in the app's layers panel

    if (this.app) {
      const panel = this.app.panels.layers;

      if (panel) {
        panel.select([`${this.id}::route::${id}`, `${this.id}::datatype::${dataType}`]);
      }
    } // route and/or weather data needs reloading if endpoint or route id changed


    if (routeDidChange || endpoint !== request.getEndpoint()) {
      needsReload = true; // remove cached route data to force reload

      this.routeStore.delete(id);
    }

    if (routeDidChange) {
      this.trigger('change:route', {
        id,
        type: dataType,
        module: this
      });
    }

    if (dataType !== this.state.dataType) {
      this.trigger('change:datatype', {
        id,
        type: dataType,
        module: this
      });
    }

    this.state = {
      dataType,
      routeId: id
    }; // start refresh timer if refresh duration is > 0

    this.startReloadTimeoutIfNeeded();

    if (!needsReload) {
      source.render();
      return;
    }

    this.getRouteData(id).then(result => {
      if (this.opts.onRouteData) {
        result = this.opts.onRouteData(result);
      }

      const {
        feature
      } = result;

      if (!feature || !feature.coordinates) {
        throw new Error('Invalid route GeoJSON feature or missing coordinates.');
      }

      const coords = feature.coordinates;
      const {
        points,
        distance: totalDistance
      } = (0, _utils2.convertCoordsToGeoJSON)(coords);
      result.distanceMeters = Math.max(result.distanceMeters, totalDistance);
      this.routeStore.set(id, result);
      this.trigger('route:load', {
        id,
        data: result,
        module: this
      }); // set points data initially so route is rendered while weather data loads

      source.setData(points);

      if (routeDidChange && this.opts.showInfoOnSelect) {
        this.showRouteInfo(id);
      }

      (0, _utils2.configureRouteRequest)(request, dataType, endpoint, points);
      source.reload();
    }).catch(e => {
      console.error('[Aeris] Routing - Failed to load route data', e);
    });
  }

  startReloadTimeoutIfNeeded() {
    if (this.opts.refresh > 0) {
      if (this.refreshTimer) {
        window.clearTimeout(this.refreshTimer);
      }

      this.refreshTimer = window.setTimeout(() => {
        this.reloadCurrentRoute();
      }, Math.max(this.opts.refresh * 1000, 60 * 1000));
    }
  }

  reloadCurrentRoute() {
    const id = this.state.routeId;
    const source = this.dataSource;
    this.getRouteData(id).then(result => {
      if (this.opts.onRouteData) {
        result = this.opts.onRouteData(result);
      }

      this.routeStore.set(id, result);
      this.startReloadTimeoutIfNeeded();

      if (source) {
        source.reload();
      }
    });
  }

  showRouteInfo(id, markerData) {
    const routeConfig = this.getRouteConfig(id);

    if (!routeConfig) {
      return;
    }

    const routeData = this.routeStore.get(id);

    if (!routeData) {
      return;
    }

    const feature = routeData.feature;
    const coords = feature.coordinates;
    const departureTime = (0, _utils.get)(routeData, 'departure.timestamp') || Date.now();
    const data = (0, _utils2.generateRouteData)((0, _utils.extend)({}, routeConfig, {
      data: Object.assign({}, (0, _utils.cloneDeep)(routeData))
    }, {
      data: {
        departure: {
          timestamp: departureTime
        },
        destination: {
          timestamp: departureTime + (routeData.durationSeconds || 0) * 1000
        }
      }
    }), coords.map(c => [c.lon, c.lat]));
    data.p = '';
    let zoomTo;

    if ((0, _utils.isset)(markerData)) {
      const {
        coordinate,
        index = 0,
        type
      } = markerData;

      if ((0, _utils.isset)(coordinate)) {
        data.p = `${coordinate.lat},${coordinate.lon}`;
        zoomTo = coordinate; // pass which marker was selected so it can be highlighted in the info panel

        if (type === 'waypoint') {
          data.selectedIndex = index;
        } else {
          data.selectedIndex = type;
        }
      }
    }

    if (!(0, _utils.isset)(zoomTo)) {
      this.zoomToRoute(id);
    } else {
      this.map.setView(zoomTo, 11);
    } // console.log('routeData', data, routeData, routeData.waypoints);


    this.showInfoPanel(`Route - ${routeConfig.title || routeConfig.id}`).load(data, {
      route: data
    });
  }

  getRouteConfig(id) {
    const {
      routes
    } = this.opts; // get route info associated with the id

    let match;
    (routes || []).forEach(route => {
      if (route.id === id) {
        match = route;
      }
    });
    return match;
  }

  getRouteData(id) {
    return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
      var _a, _b;

      const {
        url,
        service: serviceOpts
      } = this.opts;
      const routeConfig = this.getRouteConfig(id);

      if (!routeConfig) {
        reject(new Error(`[Aeris] Routing - No route configuration found for id {${id}}`));
      }

      const cached = this.routeStore.get(id);

      if (cached) {
        resolve(cached);
        return;
      } // if route config already has a feature for data.feature, then it's a static route
      // and we don't need to perform a fetch request


      if ((0, _utils.get)(routeConfig, 'data.feature')) {
        const feature = routeConfig.data.feature;

        if ((0, _utils.isPlainObject)(feature)) {
          routeConfig.data.feature = new _Feature.default(feature);
        }

        resolve(routeConfig.data);
        return;
      }

      let data;

      if (url) {
        const requestUrl = (0, _utils.isFunction)(url) ? url(id) : url;
        data = yield this.getRouteDataFromUrl(id, requestUrl);
      } else if (serviceOpts) {
        data = yield this.getRouteDataFromService(id, serviceOpts);
      }

      const result = Object.assign(Object.assign(Object.assign({}, routeConfig.data), (0, _utils.pick)(data, ['asset', 'departure', 'destination', 'current', 'waypoints'])), {
        feature: (0, _utils.isPlainObject)(data.feature) ? new _Feature.default(data.feature) : data.feature,
        distanceMeters: data.distanceMeters || 0,
        durationSeconds: data.durationSeconds || 0
      });

      if (result.current && result.asset) {
        result.asset.loc = result.current.loc;
      } // add custom waypoints if defined with the route config
      // which should be provided as an array of valid GeoJSON Feature elements


      if ((_a = routeConfig.data) === null || _a === void 0 ? void 0 : _a.waypoints) {
        result.waypoints = result.waypoints.concat((_b = routeConfig.data) === null || _b === void 0 ? void 0 : _b.waypoints.map(item => new _Feature.default(item)));
      } // console.log('route service result', result, data);


      resolve(result);
    }));
  }

  getRouteDataFromUrl(id, url) {
    return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
      try {
        const result = yield _Http.default.request(url);
        let data;

        if (result && result.data) {
          data = result.data;

          if ((0, _utils.isString)(data)) {
            throw new Error('[Aeris] Routing - Invalid route data received');
          }

          if (!data.feature && data.type) {
            let feature;

            if (data.type === 'FeatureCollection' || data.type === 'Feature') {
              const collection = new _FeatureCollection.default(data);
              feature = collection.features[0];
            }

            data.feature = feature;
          }

          if ((0, _utils.isset)(data.waypoints)) {
            data.waypoints = (0, _utils2.convertPointsToFeatures)(data.waypoints);
          }
        }

        resolve(data);
      } catch (e) {
        console.error('[Aeris] Routing - Custom route URL request failed', e);
        reject(e);
      }
    }));
  }

  getRouteDataFromService(id, serviceOpts) {
    const routeConfig = this.getRouteConfig(id);
    return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
      let service;

      if (serviceOpts.type === 'mapbox') {
        service = new _MapboxRouteService.default({
          accessToken: serviceOpts.accessKey
        });
      } else if (serviceOpts.type === 'google') {
        service = new _GoogleRouteService.default({
          accessToken: serviceOpts.accessKey
        });
      }

      if (service) {
        try {
          // overview can be "full" or "simplified" for Mapbox
          const result = yield service.getDirections(routeConfig.points, {
            overview: this.state.dataType === 'alerts' ? 'full' : 'simplified'
          });
          resolve(result);
        } catch (e) {
          console.error('[Aeris] Routing - Directions service request failed', e);
          reject(e);
        }
      } else {
        reject(new Error(`[Aeris] Routing - Invalid directions service type of \'${serviceOpts.type}\' specified`));
      }
    }));
  }

}

var _default = Routing;
exports.default = _default;
module.exports = exports.default;