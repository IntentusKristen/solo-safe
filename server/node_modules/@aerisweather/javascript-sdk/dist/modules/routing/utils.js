"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.renderLocation = exports.getWindsFormatted = exports.getMarkerStyle = exports.generateRouteFeatures = exports.generateRouteData = exports.getLocationData = exports.filterWaypoints = exports.convertCoordsToGeoJSON = exports.convertPointsToFeatures = exports.createPoint = exports.configureForecastRequest = exports.configureRouteRequest = exports.getMarkerOpts = exports.getPropForDataType = exports.getEndpointForDataType = void 0;

var _Feature = _interopRequireDefault(require("../../maps/geo/Feature"));

var _utils = require("../../utils");

var _math = require("../../utils/math");

var _number = require("../../utils/number");

var _strings = require("../../utils/strings");

var _units = require("../../utils/units");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const PROP_MAPPING = {
  temps: ['tempF', 'tempC'],
  dewpt: ['dewpointF', 'dewpointC'],
  feelslike: ['feelslikeF', 'feelslikeC'],
  winds: ['windSpeedMPH', 'windSpeedKPH'],
  windgusts: ['windGustMPH', 'windGustKPH'],
  humidity: ['humidity', 'humidity'],
  precip: ['precipIN', 'precipMM'],
  sky: ['sky', 'sky'],
  weather: ['weatherPrimary', 'weatherPrimary']
};

const getEndpointForDataType = type => {
  if (type === 'alerts') {
    return 'alerts';
  }

  return 'forecasts';
};

exports.getEndpointForDataType = getEndpointForDataType;

const getPropForDataType = type => {
  const endpoint = getEndpointForDataType(type);
  const result = PROP_MAPPING[type];

  if (result) {
    let prefix = '';

    if (endpoint === 'observations') {
      prefix = 'ob.';
    } else if (endpoint === 'forecasts' || endpoint === 'conditions') {
      prefix = 'periods.';
    }

    return `${prefix}${result[0]}`;
  }

  if (endpoint === 'alerts') {
    return 'details.name,details.type,details.color,details.cat';
  }

  return '';
};

exports.getPropForDataType = getPropForDataType;

const getMarkerOpts = type => {
  switch (type) {
    case 'end':
    case 'start':
      return {
        fill: {
          color: '#222222'
        },
        stroke: {
          width: 4
        },
        size: [30, 30]
      };

    case 'current':
      return {
        fill: {
          color: '#ee6b00'
        },
        stroke: {
          width: 3
        },
        size: [22, 22]
      };

    default:
      return {
        fill: {
          color: '#222222'
        },
        stroke: {
          width: 2
        },
        size: [14, 14]
      };
  }
};

exports.getMarkerOpts = getMarkerOpts;

const configureRouteRequest = (request, dataType, endpoint, points) => {
  const dataProp = getPropForDataType(dataType);
  request.endpoint(endpoint);
  request.route(points.map(p => {
    const [lon, lat] = (0, _utils.get)(p, 'geometry.coordinates');
    const opts = dataType !== 'alerts' ? {
      from: (0, _utils.get)(p, 'properties.from')
    } : undefined;
    return Object.assign({
      p: `${lat},${lon}`
    }, opts);
  }));

  if (endpoint === 'forecasts') {
    const fields = ['temps', 'winds', 'windgusts', 'weather'].map(type => getPropForDataType(type));
    request.fields(`${fields.join(',')},request.skipped,periods.dateTimeISO`);
    request.filter('1min');
    request.plimit(1);
    request.mindist('10mi');
  } else if (endpoint === 'alerts') {
    request.fields(`${dataProp},request.skipped`);
    request.limit(1);
    request.mindist('5mi');
  }
};

exports.configureRouteRequest = configureRouteRequest;

const configureForecastRequest = (request, loc, timestamp) => {
  const forecastFields = `
		timestamp,dateTimeISO,tempF,tempC,icon,weatherPrimary,windSpeedMPH,windSpeedKPH,windSpeedMinMPH,windSpeedMinKPH,
		windSpeedMaxMPH,windSpeedMaxKPH,windGustMPH,windGustKPH
	`.split(',').map(key => `periods.${key}`);
  let dateParam = timestamp;

  if ((0, _utils.isNumber)(dateParam)) {
    dateParam = new Date(dateParam);
  }

  request.endpoint('forecasts').place(loc).fields(forecastFields.join(',')).filter('1hr').from(dateParam).limit(1);
  return {
    request,
    date: dateParam
  };
};

exports.configureForecastRequest = configureForecastRequest;

const createPoint = (coord, properties = {}) => ({
  type: 'Feature',
  geometry: {
    type: 'Point',
    coordinates: coord
  },
  properties
});

exports.createPoint = createPoint;

const convertPointsToFeatures = points => {
  const features = points.map(point => {
    const featureType = (0, _utils.get)(point, 'type');

    if (point instanceof _Feature.default) {
      return point;
    }

    if ((0, _utils.isset)(featureType)) {
      if (featureType === 'Point' || featureType === 'Feature') {
        return new _Feature.default(point);
      }
    }

    if ((0, _utils.isArray)(point)) {
      const [lon, lat] = point;
      return new _Feature.default({
        type: 'Point',
        coordinates: [lon, lat]
      });
    }

    if ((0, _utils.isPlainObject)(point)) {
      if ((0, _utils.isValidCoord)(point)) {
        const {
          lat,
          lon
        } = point;
        return new _Feature.default({
          type: 'Point',
          coordinates: [lon, lat]
        });
      }
    }

    return null;
  });
  return features.filter(v => (0, _utils.isset)(v));
};

exports.convertPointsToFeatures = convertPointsToFeatures;

const convertCoordsToGeoJSON = (coords, distance = 0, duration = 0) => {
  let totalDistance = 0;
  const points = coords.map((coord, i) => {
    let progress = 0;

    if (distance > 0) {
      if (i === coords.length - 1) {
        progress = 1;
      } else if (i > 0) {
        const lastCoord = coords[i - 1];
        totalDistance += (0, _math.geoDistance)(coord, lastCoord);
        progress = totalDistance / distance;
      }
    }

    return {
      type: 'Feature',
      geometry: {
        type: 'Point',
        coordinates: [coord.lon, coord.lat]
      },
      properties: {
        from: `+${Math.round(duration * progress / 60)}minutes`
      }
    };
  });
  return {
    points,
    distance: totalDistance
  };
};

exports.convertCoordsToGeoJSON = convertCoordsToGeoJSON;

const filterWaypoints = (waypoints, startCoord, endCoord) => waypoints.filter(waypoint => {
  let lat;
  let lon;
  let unique = true;

  if ((0, _utils.isArray)(waypoint)) {
    lat = waypoint[1];
    lon = waypoint[0];
  } else if (waypoint instanceof _Feature.default) {
    const coord = waypoint.geometry.toArray(true);
    lat = coord[1];
    lon = coord[0];
  } else if ((0, _utils.isPlainObject)(waypoint)) {
    lat = waypoint.lat;
    lon = waypoint.lon;
  }

  if (startCoord) {
    if (lon === startCoord[0] && lat === startCoord[1]) {
      unique = false;
    }
  }

  if (endCoord) {
    if (lon === endCoord[0] && lat === endCoord[1]) {
      unique = false;
    }
  }

  return unique;
});

exports.filterWaypoints = filterWaypoints;

const getLocationData = (point, place) => {
  if (!(0, _utils.isArray)(point) || point.length < 2) {
    return undefined;
  }

  const coord = {
    lat: point[1],
    lon: point[0]
  };
  const id = `${coord.lat}_${coord.lon}`;

  if (!place) {
    place = {
      lat: point[1],
      lon: point[0]
    };
  }

  return {
    id,
    place: (0, _utils.isPlainObject)(place) ? `${(0, _number.formatNumber)(place.lat, 4)}, ${(0, _number.formatNumber)(place.lon, 4)}` : (0, _strings.toName)(place),
    loc: coord
  };
};

exports.getLocationData = getLocationData;

const generateRouteData = (config, points) => {
  const configPoints = config.points || [];
  const startCoord = points[0];
  const endCoord = points[points.length - 1];
  const waypoints = (0, _utils.get)(config, 'data.waypoints') || configPoints.filter((v, i) => i !== 0 && i < configPoints.length - 1);
  let departure = (0, _utils.isset)(configPoints[0]) ? configPoints[0] : undefined;
  let destination = configPoints.length > 0 ? configPoints[configPoints.length - 1] : undefined;
  departure = (0, _utils.get)(config, 'data.departure.place') || departure;
  destination = (0, _utils.get)(config, 'data.destination.place') || destination;
  return (0, _utils.extend)({
    departure: {
      title: (0, _utils.get)(config, 'data.departure.title') || 'Departure',
      place: departure
    },
    destination: {
      title: (0, _utils.get)(config, 'data.destination.title') || 'Destination',
      place: destination
    }
  }, config.data, {
    departure: getLocationData(startCoord, departure),
    destination: getLocationData(endCoord, destination),
    waypoints: filterWaypoints(waypoints, startCoord, endCoord).map(waypoint => {
      if (waypoint instanceof _Feature.default) {
        const coord = waypoint.geometry.toArray(true);
        const name = (0, _utils.get)(waypoint.properties, 'name');
        return getLocationData(coord, name);
      }

      return getLocationData(undefined, waypoint);
    })
  });
};

exports.generateRouteData = generateRouteData;

const generateRouteFeatures = (routeId, points, routeData) => {
  const features = [];
  let startCoord;
  let endCoord;

  if ((0, _utils.isArray)(points)) {
    let currentFeature;

    const addFeature = () => {
      features.push({
        type: 'Feature',
        geometry: {
          type: 'LineString',
          coordinates: currentFeature.coords
        },
        properties: Object.assign(Object.assign({}, currentFeature.data), {
          routeId
        })
      });
    };

    const resetFeature = (coord, apiData) => {
      currentFeature = {
        data: apiData,
        coords: [coord]
      };
    };

    if (points.length > 1) {
      startCoord = (0, _utils.get)(points[0], 'geometry.coordinates');
      endCoord = (0, _utils.get)(points[points.length - 1], 'geometry.coordinates'); // add points for route markers

      const startFeature = createPoint(startCoord, {
        type: 'start',
        label: 'A',
        routeId,
        coordinate: {
          lat: startCoord[1],
          lon: startCoord[0]
        }
      });
      const endFeature = createPoint(endCoord, {
        type: 'end',
        label: 'B',
        routeId,
        coordinate: {
          lat: endCoord[1],
          lon: endCoord[0]
        }
      });
      features.push(startFeature, endFeature); // add line segments

      points.forEach((point, index) => {
        const coord = (0, _utils.get)(point, 'geometry.coordinates');
        const skipped = (0, _utils.get)(point, 'properties.request.skipped');
        const apiResponse = (0, _utils.get)(point, 'properties.response');

        if (index === 0) {
          resetFeature(coord, apiResponse);
        } else {
          currentFeature.coords.push(coord);

          if (index > 0 && !skipped || index === points.length - 1) {
            addFeature();
            resetFeature(coord, apiResponse);
          }
        }
      });
    }
  } // add points for route markers and waypoints


  if (routeData) {
    const {
      waypoints,
      current
    } = routeData;

    if (waypoints) {
      const filteredWaypoints = filterWaypoints(waypoints, startCoord, endCoord);
      filteredWaypoints.forEach((waypoint, index) => {
        if (waypoint instanceof _Feature.default) {
          const [lon, lat] = waypoint.geometry.toArray(true);
          features.push(createPoint([lon, lat], {
            type: 'waypoint',
            routeId,
            coordinate: {
              lat,
              lon
            },
            index
          }));
        }
      });
    }

    if (current && current.loc) {
      const {
        lat,
        lon
      } = current.loc || {};

      if ((0, _utils.isset)(lat) && (0, _utils.isset)(lon)) {
        features.push(createPoint([lon, lat], {
          type: 'current',
          routeId,
          coordinate: {
            lat,
            lon
          }
        }));
      }
    }
  }

  return features;
};

exports.generateRouteFeatures = generateRouteFeatures;

const getMarkerStyle = (modelData, routeData) => {
  const {
    type,
    label
  } = modelData;
  const markerOpts = getMarkerOpts(type); // use a custom marker style for this waypoint if defined

  const markerStyle = (0, _utils.get)(routeData, `${type}.markerStyle`);

  if (markerStyle) {
    return Object.assign({}, markerStyle);
  }

  return {
    className: 'marker-route-waypoint',
    svg: {
      shape: (0, _utils.extend)({
        type: 'circle',
        fill: {
          color: '#222222'
        },
        stroke: {
          color: '#ffffff',
          width: 2
        },
        size: [14, 14]
      }, markerOpts),
      text: label ? {
        value: label,
        anchor: 'start',
        color: '#ffffff',
        translate: {
          y: -2
        },
        autosize: false
      } : undefined
    },
    size: markerOpts.size || [14, 14]
  };
};

exports.getMarkerStyle = getMarkerStyle;

const getWindsFormatted = (data, metric = false) => {
  let result = 'Calm';

  if (data.windSpeedMaxMPH > 5) {
    if (metric) {
      result = `${(0, _utils.toRangeStr)(data.windSpeedMinKPH, data.windSpeedMaxKPH, 5)} ${(0, _units.unitsForDataType)('speed', true)}`;
    } else {
      result = `${(0, _utils.toRangeStr)(data.windSpeedMinMPH, data.windSpeedMaxMPH, 5)} ${(0, _units.unitsForDataType)('speed', false)}`;
    }
  } else if (data.windSpeedMaxMPH < 5 && data.windSpeedMinMPH > 0) {
    result = metric ? '< 8 kmh' : '< 5 mph';
  }

  return result;
};

exports.getWindsFormatted = getWindsFormatted;

const renderLocation = (type, data, includesDuration = true) => {
  const {
    weather,
    metric = false,
    selected = false,
    loc
  } = data;
  const dataAttr = [`data-waypoint-type="${data.type}"`];

  if ((0, _utils.isset)(loc)) {
    dataAttr.push(`data-coord="${loc.lat},${loc.lon}"`);
  }

  if (type === 'waypoint') {
    return `
			<div class="awxjs__routing-waypoint${selected ? ' awxjs__routing-location-selected' : ''}">
				<div class="awxjs__ui-row">
					<div class="awxjs__routing-marker">
						<div class="awxjs__routing-marker-connector"></div>
					</div>
					<div class="awxjs__routing-location-info">
						<div class="awxjs__text-md awxjs__text-bold">
							${data.place}
						</div>
					</div>
				</div>
			</div>
		`;
  }

  return `
		<div class="awxjs__routing-location${selected ? ' awxjs__routing-location-selected' : ''}">
			<div class="awxjs__ui-row">
				<div class="awxjs__routing-marker">
					<div class="awxjs__routing-marker-outer"></div>
					<div class="awxjs__routing-marker-inner"></div>
					<div class="awxjs__routing-marker-label">${data.indicator || ''}</div>
				</div>
				<div class="awxjs__routing-location-info awxjs__expand">
					<div class="awxjs__ui-cols">
						<div class="awxjs__expand">
							<div class="awxjs__text-lg awxjs__text-bold">
								${data.title}
							</div>
							<div class="awxjs__text-md">
								${data.place}
							</div>
							${includesDuration ? `
								<div class="awxjs__text-md awxjs__push-top">
									${data.timeLabel}:&nbsp;
									<strong>${(0, _utils.formatDate)(new Date(data.timestamp), 'h:mm a, MMM d, yyyy')}</strong>
								</div>
							` : ''}
						</div>
						${(0, _utils.isset)(loc) ? `
							<div class="awxjs__right">
								<div class="awxjs__ui-btn-icon awxjs__ui-btn-icon-filled awxjs__ui-btn-goto" ${dataAttr.join(' ')} title="Zoom to location">
									<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 100 100">
										<path d="M50,0C30.9,0,15.6,15.3,15.6,34.4C15.6,53.4,50,100,50,100s34.4-46.6,34.4-65.6C84.4,15.3,69.1,0,50,0z M50,50
											c-8.7,0-15.6-6.9-15.6-15.6c0-8.7,6.9-15.6,15.6-15.6c8.7,0,15.6,6.9,15.6,15.6C65.6,43.1,58.7,50,50,50z"/>
									</svg>
								</div>
							</div>
						` : ''}
					</div>
					${weather ? `
						<div class="awxjs__routing-location-wx">
							<div class="awxjs__ui-cols align-center">
								<div>
									<img class="awxjs__app__ui-panel-info__forecast-icon" src="https://cdn.aerisapi.com/wxblox/icons/${weather.icon || 'na.png'}">
								</div>
								<div class="awxjs__app__ui-panel-info__forecast-temp">
									${(0, _units.formatDataValue)(weather, 'tempF', 'tempC', metric)}
								</div>
								<div class="awxjs__app__ui-panel-info__forecast-conditions">
									<div class="awxjs__app__ui-panel-info__forecast-wx">
										${weather.weatherPrimary}
									</div>
									<div class="awxjs__app__ui-panel-info__forecast-detail">
										<span>Winds</span> ${getWindsFormatted(weather, metric)}
									</div>
								</div>
							</div>
						</div>
					` : ''}
				</div>
			</div>
		</div>
	`;
};

exports.renderLocation = renderLocation;