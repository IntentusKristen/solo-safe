"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _MapSourceModule = require("../../MapSourceModule");

var _index = require("../../../utils/index");

const color = code => {
  code = (code || '').toUpperCase();

  switch (code) {
    case 'TR.A':
      return '#ffe401';

    case 'TR.W':
      return '#ff9000';

    case 'HU.A':
      return '#ff00d2';

    case 'HU.W':
      return '#ff0017';

    default:
      return '#000000';
  }
};

class Breakpoints extends _MapSourceModule.BaseMapSourceModule {
  get id() {
    return this.opts.id || 'tropical-breakpoints';
  }

  source() {
    return {
      type: 'vector',
      data: {
        request: {
          endpoint: 'tropicalcyclones',
          action: ":id"
          /* ID */
          ,
          parameters: {
            filter: 'geo',
            fields: 'id,profile,breakPointAlerts',
            limit: 50
          }
        },
        properties: {
          id: 'id',
          category: '[path].alertType',
          path: 'breakPointAlerts'
        },
        formatter: data => {
          const records = !(0, _index.isArray)(data) ? [data] : data; // convert array of breakpoint geometries into MultiLineString features based on group

          records.forEach(record => {
            const groups = {};
            (record.breakPointAlerts || []).forEach(line => {
              const type = line.alertType;

              if (!groups[type]) {
                groups[type] = [];
              }

              groups[type].push(line.coords.coordinates);
            });
            const features = [];
            Object.keys(groups).forEach(group => {
              features.push({
                type: 'Feature',
                properties: {
                  id: `${record.id}-${group}`,
                  alertType: group
                },
                geometry: {
                  type: 'MultiLineString',
                  coordinates: groups[group]
                }
              });
            });
            record.breakPointAlerts = features;
          });
          return data;
        }
      },
      style: {
        polyline: data => {
          const type = (0, _index.get)(data, 'alertType');
          return {
            stroke: {
              color: color(type),
              width: 6
            }
          };
        }
      }
    };
  }

  controls() {
    return {
      value: this.id,
      title: 'Breakpoints'
    };
  }

  legend() {
    return {
      title: 'Tropical Breakpoints',
      code: 'tropical-breakpoints'
    };
  }

}

var _default = Breakpoints;
exports.default = _default;
module.exports = exports.default;