import Animation from '../anim/Animation';
export interface Animatable {
    toggle(): void;
    play(): void;
    pause(): void;
    stop(): void;
    restart(): void;
    reset(): void;
    goToTime(time: any): Animatable;
    setStartDate(date: Date | number): Animatable;
    setStartOffset(offset: number): Animatable;
    setEndDate(date: Date | number): Animatable;
    setEndOffset(offset: number): Animatable;
}
export interface AnimatableSource<T extends Animation> {
    animation: T;
}
/**
 * An interface implemented by an object that contains a renderable object associated with a
 * specific time.
 */
export interface TimeRepresentable {
    /**
     * GMT timestamp in milliseconds
     */
    timestamp: number;
    /**
     * Renderable object that is added to a map view
     */
    renderable: any;
}
/**
 * A data type that represents annotation information associated with a specific time.
 */
export interface TimeValueRepresentable {
    /**
     * A series of values for the representable keyed by timestamp.
     *
     * @type {{ [timestamp: number]: string }}
     * @memberof TimeValueRepresentable
     */
    data: {
        [timestamp: number]: string;
    };
    /**
     * Renderable object that is added to a map view.
     *
     * @type {*}
     * @memberof TimeValueRepresentable
     */
    renderable: any;
}
/**
 * A data type that represents the configuration options for an animation.
 */
export interface AnimationOptions {
    /**
     * Animation identifier.
     */
    key?: string;
    /**
     * Whether the animation is enabled.
     */
    enabled?: boolean;
    /**
     * Start time offset in seconds relative to the current time, e.g. `-5 * 3600` for five hours ago.
     */
    from?: number | string;
    /**
     * End time offset in seconds relative to the current time, e.g. `2 * 3600` for two hours from now.
     */
    to?: number | string;
    /**
     * Duration of the animation in seconds.
     */
    duration?: number;
    /**
     * End delay in seconds, which is the duration of the hold time on the last frame before
     * restarting playback at the beginning.
     */
    endDelay?: number;
    /**
     * Total number of intervals to request data for, specifically for image-related animations.
     */
    intervals?: number;
    /**
     * Whether to begin playing the animation as soon as it's initialized. Default value is `false`.
     */
    autoplay?: boolean;
    /**
     * Refresh duration in seconds. This is typically only used for data-related animations that
     * may need to reload stale data after a determined length of time.
     */
    refresh?: number;
    /**
     * Whether this animation is considered a future animation.
     */
    future?: boolean;
    /**
     * Whether to always show this animation, meaning it will also be visible if the animation is
     * not a future animation and the current playhead is in the future, or the animation is a
     * future animation and the playhead is in the past.
     */
    alwaysShow?: boolean;
}
/**
 * A data type that represents the configuration options for an animation that requires remote data.
 */
export interface DataLoadingAnimationOptions extends AnimationOptions {
    /**
     * Whether the animation should remain visible while loading animation intervals.
     *
     * Default value is `true`.
     *
     * @type {boolean}
     */
    showWhenLoading?: boolean;
    /**
     * A Boolean indicating whether intervals should appear during an animation while still
     * loading. If `false`, then only fully loaded intervals will appearing during animation
     * playback when `bufferIntervals` is less than the total intervals in the animation.
     *
     * Default is `false`.
     *
     * @type {boolean}
     */
    showLoadingIntervals?: boolean;
    /**
     * Total number of intervals to load before animation playback begins. Setting this value to a
     * number lower than the value for `intervals` will allow playback to begin before all intervals
     * have loaded for the animation. A value of `0` will start playing the animation immediately
     * even if no intervals have fully loaded and may result in blank frames initially.
     *
     * Set this value to `-1` to disable this feature and require the animation to load all intervals
     * before playback can begin.
     *
     * Default value is `-1`.
     *
     * @type {number}
     */
    bufferIntervals?: number;
    /**
     * A Boolean that indicates whether animation intervals should be loaded in reversed order, which
     * only applies if `bufferIntervals` is less than the value defined for `intervals`. Setting
     * this to `true` will load the intervals at the end of the animation range first.
     *
     * Default value is `false`.
     */
    reverseLoadOrder?: boolean;
    /**
     * An array of Date instances to use for the animation intervals. If not provided, then the animation
     * interval times will be evenly calculated across the time range based on the total number of intervals
     * to use for the animation.
     *
     * @type {Date[]}
     */
    times?: Date[];
}
/**
 * A data type that represents the configuration options for an image-based animation.
 */
export interface ImageAnimationOptions extends DataLoadingAnimationOptions {
    /**
     * Whether animation images should be sized based on the size given by the provider.
     *
     * @type {boolean}
     */
    autosize?: boolean;
    /**
     * Whether the animation should remain visible when playback has stopped.
     *
     * @type {boolean}
     */
    showWhenStopped?: boolean;
}
/**
 * A data type that represents the configuration options for an tile-based animation.
 */
export interface TileAnimationOptions extends DataLoadingAnimationOptions {
    /**
     * Whether animation is enabled.
     *
     * @type {boolean}
     */
    enabled: boolean;
    /**
    * Type of animation, either `tile` or `image`. Default value is `tile`.
    *
    * @type {string}
    */
    type: string;
}
export interface TimelineOptions extends DataLoadingAnimationOptions {
}
