"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.isModule = void 0;

var _EventDispatcher = _interopRequireDefault(require("../../event/EventDispatcher"));

var _Timeline = _interopRequireDefault(require("../anim/Timeline"));

var _constants = require("../constants");

var _CoordinateBounds = require("../../geo/CoordinateBounds");

var _strategies = require("./strategies");

var _sources = require("./sources");

var _MapLayerConfig = _interopRequireDefault(require("./MapLayerConfig"));

var _ActivityIndicator = _interopRequireDefault(require("../../ui/ActivityIndicator"));

var _Layers = _interopRequireDefault(require("../Layers"));

var _MapRequest = _interopRequireDefault(require("../../network/maps/MapRequest"));

var _utils = require("../utils");

var _utils2 = require("../../utils");

var _utils3 = require("./utils");

var _DataSourceStore = _interopRequireDefault(require("./DataSourceStore"));

var _MaplibreMapStrategy = _interopRequireDefault(require("./strategies/maplibre/MaplibreMapStrategy"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const layerToModuleMapping = {
  'tropical-cyclones': 'tropical.Systems',
  'tropical-cyclones-break-points': 'tropical.Breakpoints'
};

const isModule = key => (0, _utils2.isset)(layerToModuleMapping[key]);
/**
 * An `InteractiveMap` object provides an abstract interface for displaying weather-related data on an interactive map view using
 * one of the supported third-party mapping libraries.
 *
 * @export
 * @class InteractiveMap
 * @extends {EventDispatcher}
 * @implements {MapStrategyDataSource}
 */


exports.isModule = isModule;

class InteractiveMap extends _EventDispatcher.default {
  /**
   * Initializes a map instance with the specified target and configuration object.
   *
   * @param {*} target Either the `HTMLElement` where you want your map view to be rendered, or
   * an existing map object instance that pertains to one of the supported third-party mapping
   * libraries. If a map object instance if provided, then that instance will be used for
   * rendering weather data instead of the library creating a new instance.
   * @param {InteractiveMapOptions} [opts] Map configuration
   * @param {(map: InteractiveMap) => void} [onInit] Optional callback to be called when the map
   * view has been fully initialized
   * @memberof InteractiveMap
   */
  constructor(target, opts, onInit) {
    super();
    this._ready = false;
    this._metric = false;
    this.store = new _DataSourceStore.default();
    this._stateForData = {};
    this._resumeAnimationTimer = null;
    this._resumeOnBoundsChange = false;
    /**
     * Updates the map timeline and all active map content sources on the map.
     *
     * @memberof InteractiveMap
     */

    this.update = (0, _utils2.debounce)(() => {
      this._loadForBounds(true);
    }, 250);
    this._dblClickTimer = null;

    if (!target) {
      throw new Error('[Aeris] Invalid target specified for InteractiveMap, which must be a DOM element or map instance');
    }

    opts = opts || {}; // if a map object was passed instead of an HTMLElement, set the appropriate strategy type

    if (target instanceof HTMLElement === false) {
      if ((0, _utils.isLeaflet)(target)) {
        opts.strategy = 'leaflet';
      } else if ((0, _utils.isMapbox)(target)) {
        opts.strategy = 'mapbox';
      } else if ((0, _utils.isMaplibre)(target)) {
        opts.strategy = 'maplibre';
      } else if ((0, _utils.isGoogle)(target)) {
        opts.strategy = 'google';
      } else if ((0, _utils.isOpenLayers)(target)) {
        opts.strategy = 'openlayers';
      }
    }

    opts = (0, _utils2.extend)({
      strategy: 'leaflet',
      center: undefined,
      zoom: 7,
      metric: false,
      timeline: {
        from: -2 * 3600,
        to: 0,
        intervals: 10,
        bufferIntervals: 2,
        showLoading: true,
        showLoadingIntervals: true,
        resetOnBoundsChange: false
      },
      refresh: 0,
      attribution: true,
      onInit: undefined,
      reloadOnBoundsChange: true
    }, opts);
    this._opts = opts;

    if (opts.account) {
      this.account = opts.account;
    }

    if (opts.strategy === 'mapbox') {
      this._strategy = new _strategies.MapboxMapStrategy(target, opts);
    } else if (opts.strategy === 'maplibre') {
      this._strategy = new _MaplibreMapStrategy.default(target, opts);
    } else if (opts.strategy === 'google') {
      this._strategy = new _strategies.GoogleMapStrategy(target, opts);
    } else if (opts.strategy === 'openlayers') {
      this._strategy = new _strategies.OpenLayersMapStrategy(target, opts);
    } else {
      this._strategy = new _strategies.LeafletMapStrategy(target, opts);
    }

    this._strategy.dataSource = this;
    this._timeline = new _Timeline.default((0, _utils2.extend)(opts.timeline, {
      key: 'map-timeline'
    }));
    this._sourceOrder = {
      tile: []
    };
    this._layers = new _Layers.default(this.account);
    this._config = new _MapLayerConfig.default(opts.styles);
    this._metric = this._opts.metric;

    const onReady = () => {
      this._indicator = new _ActivityIndicator.default();

      this._indicator.appendTo(this.strategy.$el);

      this.strategy.$el.addClass('awxjs__ia-map');

      this._setupEvents();

      this._ready = true; // add layers if defined in config options

      if (opts.layers) {
        let layers = opts.layers;

        if (!(0, _utils2.isArray)(layers)) {
          layers = layers.split(',');
        }

        layers.forEach(layer => {
          if ((0, _utils2.isString)(layer)) {
            this.addLayer(layer);
          } else if ((0, _utils2.isPlainObject)(layer)) {
            const {
              layer: code,
              options
            } = layer;
            this.addLayer(code, options);
          }
        });
      }

      if (opts.refresh > 0) {
        this.enableAutoUpdate(opts.refresh);
      }

      if (onInit) onInit(this);
      this.trigger("load"
      /* LOAD */
      );
      this.trigger("ready"
      /* READY */
      );
    };

    this._layers.fetch().then(() => {
      // strategy may not be ready if it requires loading additional assets at runtime
      if (!this.strategy.isReady()) {
        this.strategy.on('ready', e => {
          onReady();
        });
      } else {
        onReady();
      }
    });
  }
  /**
   * Returns the underlying third-party map object instance associated with the current map strategy.
   *
   * @readonly
   * @memberof InteractiveMap
   */


  get map() {
    return this.strategy.map;
  }
  /**
   * Returns the current map strategy being used.
   *
   * @readonly
   * @type {MapStrategy}
   * @memberof InteractiveMap
   */


  get strategy() {
    return this._strategy;
  }
  /**
   * Returns the configured options for the map.
   *
   * @readonly
   * @type {InteractiveMapOptions}
   * @memberof InteractiveMap
   */


  get opts() {
    return this._opts;
  }
  /**
   * Configuration and style manager for the map content sources and associated layers.
   *
   * @readonly
   * @type {MapLayerConfig}
   * @memberof InteractiveMap
   */


  get config() {
    return this._config;
  }
  /**
   * Returns the map's animation timeline.
   *
   * @readonly
   * @type {Timeline}
   * @memberof InteractiveMap
   */


  get timeline() {
    return this._timeline;
  }
  /**
   * Returns the layer metadata info instance.
   *
   * @readonly
   * @type {Layers}
   * @memberof InteractiveMap
   */


  get layerInfo() {
    return this._layers;
  }
  /**
   * The Aeris account to use when requesting data for the map.
   *
   * @type {Account}
   * @memberof InteractiveMap
   */


  get account() {
    return this._account;
  }

  set account(value) {
    this._account = value;
  }
  /**
   * Returns whether the current map units are set to metric.
   *
   * @readonly
   * @type {boolean}
   * @memberof InteractiveMap
   */


  get isMetric() {
    return this._metric;
  }
  /**
   * Returns whether the map is ready, meaning the underlying map view and events have been fully
   * setup and initialized.
   *
   * @returns {boolean}
   * @memberof InteractiveMap
   */


  isReady() {
    return this.strategy.isReady();
  }
  /**
   * Returns the map's center coordinate.
   *
   * @returns {Coordinate}
   * @memberof InteractiveMap
   */


  getCenter() {
    return this.strategy.getCenter();
  }
  /**
   * Sets the map's center coordinate.
   *
   * @param {Coordinate} coord
   * @memberof InteractiveMap
   */


  setCenter(coord) {
    this.strategy.setCenter(coord);
  }
  /**
   * Returns the current map zoom level.
   *
   * @returns {number}
   * @memberof InteractiveMap
   */


  getZoom() {
    return this.strategy.getZoom();
  }
  /**
   * Sets the map zoom level.
   *
   * @param {number} zoom
   * @memberof InteractiveMap
   */


  setZoom(zoom) {
    this.strategy.setZoom(zoom);
  }
  /**
   * Sets the map's center coordinate and zoom level.
   *
   * @param {Coordinate} center
   * @param {number} zoom
   * @memberof InteractiveMap
   */


  setView(center, zoom) {
    this.strategy.setView(center, zoom);
  }
  /**
   * Returns the geographical bounds for the visible map region.
   *
   * @returns {GeoBounds}
   * @memberof InteractiveMap
   */


  getBounds() {
    return this.strategy.getBounds();
  }
  /**
   * Sets the map bounds to contain the specified geographical bounds.
   *
   * @param {GeoBounds} bounds
   * @memberof InteractiveMap
   */


  setBounds(bounds) {
    this.strategy.setBounds(bounds);
  }
  /**
   * Sets the map bounds to contain the specified geographical bounds with optional padding insets.
   *
   * @param {GeoBounds} bounds
   * @param {number[]} [padding]
   * @memberof InteractiveMap
   */


  fitBounds(bounds, padding) {
    padding = padding || [10, 10];
    this.strategy.fitBounds(bounds, padding);
  }
  /**
   * Sets the units to display on the map.
   *
   * Map content sources that display measurement values should observe the change:unit event
   * and update their content on the map accordingly.
   *
   * @param {boolean} isMetric
   * @memberof InteractiveMap
   */


  setMetric(isMetric) {
    if (this._metric !== isMetric) {
      this._metric = isMetric;
      this.trigger("change:units"
      /* CHANGE_UNITS */
      , {
        metric: isMetric,
        unit: isMetric ? "metric"
        /* Metric */
        : "imperial"
        /* Imperial */

      });
    }
  }
  /**
   * AMP Layers
   */

  /**
   * Adds an AMP layer to the map for the specified layer code.
   *
   * @param {string} layer
   * @param {LayerOptions} [opts]
   * @returns {InteractiveMap}
   * @memberof InteractiveMap
   */


  addLayer(layer, opts) {
    this._checkReady();

    if (!(0, _utils2.isset)(layer) || (0, _utils2.isEmpty)(layer) || !(0, _utils2.isString)(layer)) {
      console.warn(`[Aeris] Cannot add invalid layer code {${layer}} to InteractiveMap.`, layer);
      debugger;
      return this;
    }

    const key = (0, _utils3.identifierForLayer)(layer);
    const identifier = (0, _utils2.get)(opts, 'id') || key;
    let source = this.getSourceForId(identifier); // if (!source && identifier === layerKey) {
    // 	source = this.getSourceForLayer(layerKey);
    // }

    if (source) {
      return this;
    } // handle backwards compatibility for layers that are now part of lazy-loaded modules
    // if the layer is associated with a lazy-loaded map module, we need to load the module first
    // and then add its source to the map


    const layerModule = layerToModuleMapping[layer];

    if (layerModule) {
      (0, _utils.loadMapModuleConfig)(layerModule, (id, config, module) => {
        const mid = (0, _utils2.get)(opts, 'id') || id;

        if (module) {
          module.initialize(this.account, null, this);
        }

        config = (0, _utils2.extend)({}, config, opts);
        const moduleSource = this.createSource(mid, config.type, config);
        moduleSource.code = layer;
        this.store.mapping.set(layer, mid);
        this.addSource(moduleSource, opts); // need to trigger layer:add event since this source is being added via addLayer()

        this.trigger("layer:add"
        /* LAYER_ADD */
        , {
          id: identifier,
          layer: key,
          source
        });
      });
      return this;
    }

    source = (0, _utils3.createAerisSource)(layer, (0, _utils2.extend)({}, (0, _utils2.cloneDeep)(opts), {
      account: this.account,
      servers: this._opts.servers,
      time: this.timeline.currentDate(),
      attribution: this._opts.attribution ? _constants.AERIS_ATTRIBUTION : null,
      timeline: {
        intervals: (0, _utils2.get)(this._opts, 'timeline.intervals'),
        alwaysShowPast: (0, _utils2.get)(this._opts, 'timeline.alwaysShowPast'),
        alwaysShowFuture: (0, _utils2.get)(this._opts, 'timeline.alwaysShowFuture'),
        bufferIntervals: (0, _utils2.get)(this._opts, 'timeline.bufferIntervals'),
        showLoadingIntervals: (0, _utils2.get)(this._opts, 'timeline.showLoadingIntervals')
      }
    }), this.strategy.factory, this._layers);

    if (source) {
      source.code = key;
      this.addSource(source, opts);
      this.store.mapping.set(key, identifier);
      this.trigger("layer:add"
      /* LAYER_ADD */
      , {
        id: identifier,
        layer: key,
        source
      }); // const zIndex = get(opts, 'style.zIndex');
      // if (source instanceof TileSource && isset(zIndex)) {
      // 	this.setLayerOrder(layer, zIndex);
      // }
    }

    return this;
  }
  /**
   * Adds a series of AMP layers for the specified array of layer codes.
   *
   * @param {string[]} layers
   * @returns {InteractiveMap}
   * @memberof InteractiveMap
   */


  addLayers(layers) {
    this._checkReady();

    layers.forEach(layer => this.addLayer(layer));
    return this;
  }
  /**
   * Removes an AMP layer from the map for the specified layer code.
   *
   * @param {string} layer
   * @returns {InteractiveMap}
   * @memberof InteractiveMap
   */


  removeLayer(layer) {
    layer = layer.replace(/\:.+$/, '');
    const source = this.getSourceForLayer(layer);

    if (!source) {
      return this;
    }

    this.removeSource(source); // this.trigger(MapEvent.LAYER_REMOVE, {
    // 	layer: layer.replace(/\:[^,]+/g, ''), source
    // });

    const key = this.store.mapping.get(source.key);
    const identifier = this.store.mapping.get(key);
    this.trigger("layer:remove"
    /* LAYER_REMOVE */
    , {
      id: identifier,
      layer: key,
      source
    });
    return this;
  }
  /**
   * Removes an AMP layer from the map for the specified identifier.
   *
   * @param {string} id
   * @returns
   * @memberof InteractiveMap
   */


  removeLayerForId(id) {
    const source = this.getSourceForId(id);

    if (!source) {
      return this;
    }

    ;
    const key = this.store.mapping.get(source.key);
    const identifier = this.store.mapping.get(key);
    this.removeSource(source);
    this.trigger("layer:remove"
    /* LAYER_REMOVE */
    , {
      id: identifier,
      layer: key,
      source
    });
    return this;
  }
  /**
   * Removes a series of AMP layers associated with the specified array of layer codes.
   *
   * @param {string[]} layers
   * @returns {InteractiveMap}
   * @memberof InteractiveMap
   */


  removeLayers(layers) {
    layers.forEach(layer => this.removeLayer(layer));
    return this;
  }
  /**
   * Updates the layer's zIndex order by bringing it to the top of the layer stack. This only
   * affects tile and image layers.
   *
   * @param {string} layer
   * @memberof InteractiveMap
   */


  bringLayerToFront(layer) {
    const source = this.getSourceForLayer(layer);
    const index = this.store.count;

    if (source && source instanceof _sources.TileSource) {
      const order = this._sourceOrder.tile;
      const previous = order.indexOf(layer);

      if (previous !== -1) {
        order.splice(previous, 1);
        order.push(layer);
      } // update all source z-index values so they aren't at the same index


      Object.keys(this.store.items).forEach(key => {
        const keySource = this.store.get(key);

        if (keySource instanceof _sources.TileSource) {
          // add 1 to the z-index since the map library base layer is at index 0
          keySource.setOrder(order.indexOf(key) + 1);
        }
      });
    }
  }
  /**
   * Updates the layer's zIndex order by sending it to the bottom of the layer stack. This only
   * affects tile and image layers.
   *
   * @param {string} layer
   * @memberof InteractiveMap
   */


  sendLayerToBack(layer) {
    const source = this.getSourceForLayer(layer);

    if (source && source instanceof _sources.TileSource) {
      const order = this._sourceOrder.tile;
      const previous = order.indexOf(layer);

      if (previous !== -1) {
        order.splice(previous, 1);
        order.splice(0, 0, layer);
      } // update all source z-index values so they aren't at the same index


      Object.keys(this.store.items).forEach(key => {
        const keySource = this.store.get(key);

        if (keySource instanceof _sources.TileSource) {
          // add 1 to the z-index since the map library base layer is at index 0
          keySource.setOrder(order.indexOf(key) + 1);
        }
      });
    }
  }
  /**
   * Updates the layer's zIndex order. This only affects tile and image layers.
   *
   * @param {string} layer
   * @param {number} zIndex
   * @memberof InteractiveMap
   */


  setLayerOrder(layer, zIndex) {
    const source = this.getSourceForLayer(layer);

    if (source && source instanceof _sources.TileSource && (0, _utils2.isset)(zIndex)) {
      source.setOrder(zIndex);
    }
  }
  /**
   * Returns the map content source associated with the specified layer code, if any.
   *
   * @param {string} layer
   * @returns {*}
   * @memberof InteractiveMap
   */


  getSourceForLayer(layer) {
    const mappedId = this.store.mapping.get(layer);

    if (mappedId) {
      return this.getSource(mappedId);
    }

    return this.getSource(layer);
  }
  /**
   * Returns the map content source associated with the specified identifier, if any.
   *
   * @param {string} id
   * @returns {*}
   * @memberof InteractiveMap
   */


  getSourceForId(id) {
    const mappedId = this.store.mapping.get(id);

    if (mappedId) {
      return this.getSource(mappedId);
    }

    return this.getSource(id);
  }
  /**
   * Instantiates and returns a new map content source instance based on the specified type and
   * configuration options.
   *
   * @param {string} key
   * @param {string} type
   * @param {any} config
   * @returns {any}
   * @memberof InteractiveMap
   */


  createSource(key, type, config) {
    return (0, _utils3.createSource)(key, type, Object.assign({
      account: this.account,
      servers: this._opts.servers
    }, config), this.strategy.factory);
  }
  /**
   * Content Sources
   */

  /**
   * Adds a new map content source for the specified layer code.
   *
   * @param {*} source
   * @param {string} key
   * @returns {InteractiveMap}
   * @memberof InteractiveMap
   */


  addSource(source, opts) {
    this._checkReady();

    if (!(0, _utils2.isset)(source.key)) {
      console.error('[Aeris] Cannot add a data source with an undefined key to the map. Make sure you have set the `key` property on your data source before adding to the map.');
      return this;
    }

    source.strategy = this.strategy;
    source.enabled = true;
    source.identifier = source.key;
    this.store.add(source.identifier, source);
    this.strategy.addSource(source);
    const style = (0, _utils2.get)(opts, 'style');

    if (style) {
      this._updateSourceStyle(source, style);
    }

    if ((0, _utils2.has)(source, 'animation') && (0, _utils2.isset)(source.animation)) {
      if (source.animation.isEnabled() === true) {
        this.timeline.add(source.key, source.animation);
      }
    }

    const bounds = this.getBounds();

    if (source instanceof _sources.VectorSource) {
      source.on('data:load:start', e => this.trigger("source:load:start"
      /* SOURCE_LOAD_START */
      , e.data));
      source.on('data:load:done', e => this.trigger("source:load:done"
      /* SOURCE_LOAD_DONE */
      , e.data));
      source.load({
        bounds,
        from: this.timeline.startDate(),
        to: this.timeline.endDate()
      }).catch(error => {
        console.error(`[Aeris] Failed to load data for VectorSource with key ${source.key}`, error);
      });
    }

    this.trigger("source:add"
    /* SOURCE_ADD */
    , {
      source,
      id: source.key
    });
    return this;
  }
  /**
   * Adds the map content source associated with a map module.
   *
   * @param {*} module
   * @param {*} [overrides=null]
   * @memberof InteractiveMap
   */


  addModule(module, overrides = null, constructorOpts = null) {
    const initialize = _module => {
      _module.initialize(this.account, null, this);

      const config = _module.source();

      const source = this.createSource(_module.id, config.type, (0, _utils2.extend)({}, config, overrides));

      if (source) {
        this.addSource(source);
      }
    };

    const setup = _module => {
      if (this.isReady) {
        initialize(_module);
      } else {
        this.on('ready', () => {
          initialize(_module);
        });
      }
    }; // determine if we're loading in a pre-built module from the library, which we then need
    // to load and then create an instance of before adding


    if ((0, _utils2.isFunction)(module)) {
      module().then(Module => {
        Module = Module.default || Module;
        const result = new Module(constructorOpts);
        setup(result);
      });
    } else if ((0, _utils2.has)(module, 'source')) {
      setup(module);
    }
  }
  /**
   * Removes the map content source associated with the specified layer code.
   *
   * @param {*} source
   * @returns {InteractiveMap}
   * @memberof InteractiveMap
   */


  removeSource(source) {
    source.enabled = false;
    this.strategy.removeSource(source);

    if ((0, _utils2.has)(source, 'animation') && (0, _utils2.isset)(source.animation)) {
      if (source.animation.isEnabled() === true) {
        source.animation.reset();
        this.timeline.remove(source.animation);
      }
    }

    if ((0, _utils2.has)(source, 'reset')) {
      source.reset();
    }

    this.store.remove(source.identifier);
    this.store.each((key, item) => {
      if (item === source) {
        this.store.remove(key);
      }
    }); // const layer = this.store.mapping(source.key);
    // const key = this.store.mapping(source.key);
    // const identifier = this.store.mapping(key);

    const identifier = source.key;
    const layer = source.code;
    this.trigger("source:remove"
    /* SOURCE_REMOVE */
    , {
      source,
      id: identifier,
      layer
    });
    return this;
  }
  /**
   * Removes all active data sources from the map.
   *
   * @returns {InteractiveMap}
   * @memberof InteractiveMap
   */


  removeAllSources() {
    this.store.each((_, source) => {
      this.removeSource(source);
    });
    return this;
  }
  /**
   * Returns the map content source associated with the specified key, if any.
   *
   * @param {string} key
   * @returns {*}
   * @memberof InteractiveMap
   */


  getSource(key) {
    let source = this.store.get(key);

    if (!source) {
      key = (0, _utils3.getSourceId)(key);
      source = this.store.get(key);
    }

    return source;
  }
  /**
   * Returns whether a data source exists on the map for the specified key.
   *
   * @param {string} key
   * @returns {boolean}
   * @memberof InteractiveMap
   */


  hasSource(key) {
    key = (0, _utils3.getSourceId)(key);
    return this.store.has(key);
  }
  /**
   * Presents a callout bubble on the map from the specified target. The target can either be an
   * `Coordinate` object or a native marker object for the current mapping strategy.
   *
   * You can provide native options to configure the callout via the `opts` parameter, which is
   * a configuration object as supported by the strategy's mapping library.
   *
   * @param {*} target
   * @param {*} content
   * @param {*} opts
   * @memberof InteractiveMap
   */


  showCallout(target, content, opts) {
    this.strategy.showCallout(target, content, opts);
  }
  /**
   * Enables auto-updating of map data on regular intervals based on the specified number of
   * seconds.
   *
   * @param {number} interval
   * @memberof InteractiveMap
   */


  enableAutoUpdate(seconds) {
    if (!this._refreshInterval && seconds > 0) {
      seconds = Math.max(seconds, 10);

      if (this._refreshInterval) {
        window.clearInterval(this._refreshInterval);
      }

      this._refreshInterval = setInterval(() => {
        this._updateTimeline();
      }, seconds * 1000);
    }
  }
  /**
   * Disables auto-updating of map data.
   *
   * @memberof InteractiveMap
   */


  disableAutoUpdate() {
    if (this._refreshInterval) {
      clearInterval(this._refreshInterval);
    }

    this._refreshInterval = null;
  }
  /**
   * @ignore
   *
   * @memberof InteractiveMap
   */


  _updateTimeline() {
    const tl = this.timeline;
    let restartAnimation = false;

    if (tl.isAnimating() || tl.isLoading()) {
      tl.stop();
      tl.reset();
      restartAnimation = true;
    }

    tl.refresh();
    tl.goToInit(); // if animation was previously active/playing before updating, we need to restart it

    if (restartAnimation) {
      clearTimeout(this._restartAnimationTimeout);
      this._restartAnimationTimeout = setTimeout(() => {
        tl.play();
      }, 300);
    }
  }

  _updateSourceStyle(source, style = {}) {
    if (!source) return;

    if (source instanceof _sources.TileSource) {
      const {
        zIndex,
        opacity
      } = style;

      if ((0, _utils2.isset)(opacity)) {
        source.setOpacity(opacity);
      }

      if ((0, _utils2.isset)(zIndex)) {
        source.setOrder(zIndex);
      }
    }
  }
  /**
   * @ignore
   * Updates point and shape map content sources by loading new data for the current map bounds.
   *
   * @memberof InteractiveMap
   */


  _loadForBounds(force = false, isAnimating = false) {
    const bounds = this.getBounds();
    this.store.each((key, source) => {
      if (source instanceof _sources.VectorSource) {
        const vectorSource = source;

        if (vectorSource.requiresBounds || vectorSource.hasData() === false || force) {
          vectorSource.load({
            bounds,
            from: this.timeline.startDate(),
            to: this.timeline.endDate()
          }, isAnimating).catch(error => {
            console.error(`[Aeris] Failed to load data for VectorSource with key ${source.key}`, error);
          });
        }
      }
    });
  }
  /**
   * @ignore
   * Updates existing map content sources for the specified date and time.
   *
   * @param {(number | Date)} date
   * @memberof InteractiveMap
   */


  _updateSourcesForDate(date) {
    if (!(0, _utils2.isDate)(date)) {
      date = new Date(date);
    }

    this.store.each((key, source) => {
      if (source instanceof _sources.TileSource) {
        source.timestamp = date;
      }
    });
  }
  /**
   * @ignore
   * Called before the map's visible region changes, either from a center or zoom change.
   *
   * @memberof InteractiveMap
   */


  _beforeBoundsChange() {
    if (this.timeline.isAnimating() && this.timeline.isPaused() === false) {
      this._resumeOnBoundsChange = true;
      this.timeline.pause();
    } else {
      this._resumeOnBoundsChange = false;
    }
  }
  /**
   * @ignore
   * Called after the map's visible region changes, either from a center or zoom change. This method will also request an update
   * for all point and shape layers that are active on the map and require new data for the visible region change.
   *
   * @memberof InteractiveMap
   */


  _afterBoundsChange() {
    const shouldReset = (0, _utils2.get)(this._opts, 'timeline.resetOnBoundsChange');
    let reload = this._opts.reloadOnBoundsChange;

    if (this._resumeAnimationTimer) {
      clearTimeout(this._resumeAnimationTimer);
      this._resumeAnimationTimer = null;
    }

    if (reload && !(0, _utils2.isEmpty)(this._stateForData)) {
      const prev = this._stateForData;
      const prevCenter = this.strategy.coordToPoint(prev.center);
      const newCenter = this.strategy.coordToPoint(this.getCenter());

      if ((0, _utils2.isset)(prevCenter) && (0, _utils2.isset)(newCenter)) {
        const delta = Math.max(Math.abs(prevCenter.x - newCenter.x), Math.abs(prevCenter.y - newCenter.y));
        reload = delta >= 50;
      }

      if (this.getZoom() !== prev.zoom) {
        reload = true;
      }
    } // check if we need to reset animations based on whether there are vector sources currently being animated


    let hasVectorSource = false;
    this.store.each((key, source) => {
      if (source instanceof _sources.VectorSource) {
        hasVectorSource = true;
      }
    }); // only reload data for new bounds if change was large enough to prevent reloading
    // with minor adjustments to map panning

    if (reload) {
      if (shouldReset === true) {
        this.timeline.reset();
      }

      if (hasVectorSource) {
        const isAnimating = this.timeline.isPaused() || this.timeline.isAnimating();

        this._loadForBounds(false, isAnimating);

        this._stateForData = {
          center: this.getCenter(),
          bounds: this.getBounds(),
          zoom: this.getZoom()
        };
      }
    }

    if (this._resumeOnBoundsChange && this.timeline.isPaused()) {
      this._resumeAnimationTimer = setTimeout(() => {
        this.timeline.resume();
      }, 500);
    }
  }
  /**
   * @ignore
   * Sets up the event mappings between the internal strategy and Map instance.
   *
   * @memberof InteractiveMap
   */


  _setupEvents() {
    // need to use a timeout to better handle click vs double-click for mapping strategies
    // that trigger click events for dblclick as well
    this.strategy.on('click', e => {
      if (this._dblClickTimer !== null) {
        return;
      }

      this._dblClickTimer = setTimeout(() => {
        e.data.coord = (0, _CoordinateBounds.normalize)(e.data.coord);
        this.trigger("click"
        /* CLICK */
        , e.data);
        this._dblClickTimer = null;
      }, 200);
    });
    this.strategy.on('dblclick', e => {
      clearTimeout(this._dblClickTimer);
      this._dblClickTimer = null;
      this.trigger("dblclick"
      /* DBL_CLICK */
      , e.data);
    });
    this.strategy.on('resize', e => this.trigger("resize"
    /* RESIZE */
    , e.data));
    this.strategy.on('mousedown', e => this.trigger("mousedown"
    /* MOUSE_DOWN */
    , e.data));
    this.strategy.on('mouseup', e => this.trigger("mouseup"
    /* MOUSE_UP */
    , e.data));
    this.strategy.on('mouseover', e => this.trigger("mouseover"
    /* MOUSE_OVER */
    , e.data));
    this.strategy.on('mouseout', e => this.trigger("mouseout"
    /* MOUSE_OUT */
    , e.data));
    this.strategy.on('mousemove', e => this.trigger("mousemove"
    /* MOUSE_MOVE */
    , e.data)); // bounds/zoom events

    this.strategy.on('before:change:bounds', () => {
      this._beforeBoundsChange();
    });
    this.strategy.on('change:bounds', e => {
      this.trigger("change:bounds"
      /* CHANGE_BOUNDS */
      , {
        bounds: this.getBounds()
      });

      this._afterBoundsChange();
    });
    this.strategy.on('change:center', e => this.trigger("change:center"
    /* CHANGE_CENTER */
    , {
      center: this.getCenter()
    }));
    this.strategy.on('change:zoom', e => this.trigger("change:zoom"
    /* CHANGE_ZOOM */
    , {
      zoom: this.getZoom()
    }));
    this.strategy.on('move', e => this.trigger("move"
    /* MOVE */
    ));
    this.strategy.on('move:start', e => {
      this.trigger("move:start"
      /* MOVE_START */
      );
      this.trigger("before:change:bounds"
      /* BEFORE_CHANGE_BOUNDS */
      , {
        bounds: this.getBounds()
      });
    });
    this.strategy.on('move:end', e => {
      this.trigger("move:end"
      /* MOVE_END */
      );
      this.trigger("after:change:bounds"
      /* AFTER_CHANGE_BOUNDS */
      , {
        bounds: this.getBounds()
      });
    });
    this.strategy.on('zoom', e => this.trigger("zoom"
    /* ZOOM */
    ));
    this.strategy.on('zoom:start', e => {
      this.trigger("zoom:start"
      /* ZOOM_START */
      );
      this.trigger("before:change:bounds"
      /* BEFORE_CHANGE_BOUNDS */
      , {
        bounds: this.getBounds()
      });
    });
    this.strategy.on('zoom:end', e => {
      this.trigger("zoom:end"
      /* ZOOM_END */
      );
      this.trigger("after:change:bounds"
      /* AFTER_CHANGE_BOUNDS */
      , {
        bounds: this.getBounds()
      });
    });
    this.strategy.on('idle', e => this.trigger('idle')); // marker events

    this.strategy.on('marker:click', e => this.trigger("marker:click"
    /* MARKER_CLICK */
    , e.data));
    this.strategy.on('marker:mouseover', e => this.trigger("marker:mouseover"
    /* MARKER_MOUSEOVER */
    , e.data));
    this.strategy.on('marker:mouseout', e => this.trigger("marker:mouseout"
    /* MARKER_MOUSEOUT */
    , e.data));
    this.strategy.on('marker:drag', e => this.trigger("marker:drag"
    /* MARKER_DRAG */
    , e.data));
    this.strategy.on('marker:dragstart', e => this.trigger("marker:dragstart"
    /* MARKER_DRAG_START */
    , e.data));
    this.strategy.on('marker:dragend', e => this.trigger("marker:dragend"
    /* MARKER_DRAG_END */
    , e.data)); // shape events

    this.strategy.on('shape:click', e => this.trigger("shape:click"
    /* SHAPE_CLICK */
    , e.data));
    this.strategy.on('shape:mouseover', e => this.trigger("shape:mouseover"
    /* SHAPE_MOUSEOVER */
    , e.data));
    this.strategy.on('shape:mouseout', e => this.trigger("shape:mouseout"
    /* SHAPE_MOUSEOUT */
    , e.data)); // timeline events

    this.timeline.on('play load:start', () => {
      this.trigger("timeline:play"
      /* TIMELINE_PLAY */
      , {
        timeline: this.timeline
      });
    });
    this.timeline.on('stop', e => {
      clearTimeout(this._restartAnimationTimeout);
      this.trigger("timeline:stop"
      /* TIMELINE_STOP */
      , {
        timeline: this.timeline
      });
    });
    this.timeline.on('advance', e => {
      if (!this.timeline.isAnimating()) {
        this._updateSourcesForDate(e.data.time);
      }

      this.trigger("timeline:change"
      /* TIMELINE_CHANGE */
      , (0, _utils2.extend)({
        timeline: this.timeline
      }, e.data));
    });
    this.timeline.on('start:change end:change', () => {
      this.timeline.reset();
      this.update();
    });
    this.timeline.on('load:start', () => {
      this._indicator.startAnimating();
    });
    this.timeline.on('load:done', () => {
      this._indicator.stopAnimating();
    });
  }
  /**
   * @ignore
   * @private
   * @memberof InteractiveMap
   */


  _checkReady() {
    if (!this._ready) {
      const message = `[Aeris] Must wait for an instance of InteractiveMap to be fully
				initialized before calling methods on it. Observe the \`load\` or \`ready\` events
				that are triggered when an InteractiveMap instance is fully initialized.`;
      throw new Error(message.replace(/\n\s+/g, ' '));
    }
  }
  /**
   * Data Sources
   */

  /**
   * @ignore
   * @param {string} layer
   * @returns {MapRequest}
   * @memberof InteractiveMap
   */


  requestForMap(layer) {
    const request = new _MapRequest.default({
      server: (0, _utils2.get)(this._opts, 'servers.maps'),
      client: {
        id: this.account.id,
        secret: this.account.secret
      }
    }, {
      type: "tile"
      /* TILE */

    });
    request.layers(layer);
    return request;
  }

}

var _default = InteractiveMap;
exports.default = _default;