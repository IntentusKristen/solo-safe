"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createAerisSource = exports.identifierForLayer = exports.createSource = exports.createTextSource = exports.createGeoJsonSource = exports.createVectorSource = exports.createTileSource = exports.mapRequestForConfig = exports.apiRequestForConfig = exports.getSourceId = void 0;

var _ApiRequest = _interopRequireDefault(require("../../network/api/ApiRequest"));

var _MapRequest = _interopRequireDefault(require("../../network/maps/MapRequest"));

var _sources = require("./sources");

var _utils = require("../../utils");

var _Layers = require("../Layers");

var _style = require("./style");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const getSourceId = id => {
  if (!(0, _utils.isString)(id)) return undefined; // parse id from full identifier string

  const parts = id.split('::');
  return parts[parts.length - 1];
};

exports.getSourceId = getSourceId;

const apiRequestForConfig = (account, config) => {
  if (!(0, _utils.isset)(config)) return null;
  let request = config.service;

  if ((0, _utils.isset)(config.request)) {
    const opts = config.request;

    if (request) {
      const action = opts.action;
      const params = opts.parameters;

      if (action) {
        request.action(action);
      }

      if (params) {
        request.setParams(params);
      }
    } else if (opts.endpoint) {
      request = new _ApiRequest.default({
        server: opts.server,
        client: {
          id: account.id,
          secret: account.secret
        }
      });
      request.endpoint(opts.endpoint);

      if (opts.action) {
        request.action(opts.action);
      }

      if (opts.parameters) {
        request.setParams(opts.parameters);
      }
    }
  }

  return request;
};

exports.apiRequestForConfig = apiRequestForConfig;

const mapRequestForConfig = (account, config) => {
  const {
    layer,
    request: opts
  } = config;
  const request = new _MapRequest.default({
    server: opts.server,
    client: {
      id: account.id,
      secret: account.secret
    }
  }, {
    type: "tile"
    /* TILE */

  });
  request.layers(layer);
  return request;
};

exports.mapRequestForConfig = mapRequestForConfig;

const createTileSource = (identifier, config, factory) => {
  let service = (0, _utils.get)(config, 'data.service');

  if ((0, _utils.isFunction)(service)) {
    service = service();
  }

  if (service instanceof _MapRequest.default) {
    service.type("tile"
    /* TILE */
    );
  } // console.log('TILE', identifier, config, service);


  return factory.tileLayer(identifier, service, config);
};

exports.createTileSource = createTileSource;

const createVectorSource = (identifier, config) => new _sources.VectorSource(identifier, config);

exports.createVectorSource = createVectorSource;

const createGeoJsonSource = (identifier, config) => new _sources.GeoJsonSource(identifier, config);

exports.createGeoJsonSource = createGeoJsonSource;

const createTextSource = (identifier, config) => {
  const props = (0, _utils.get)(config, 'data.properties'); // make sure required data property mappings are provided for text layers

  if (!props) {
    throw new Error('Value for `data.properties` option is required for text layers');
  } else {
    const {
      timestamp,
      value
    } = props;

    if (!timestamp || !value) {
      throw new Error('Value for `data.properties.timestamp` and `data.properties.value` options are required for text layers');
    }
  }

  return new _sources.TextSource(identifier, config);
};

exports.createTextSource = createTextSource;

const createSource = (identifier, type, config, factory) => {
  const {
    account,
    servers
  } = config || {};
  delete config.account;
  delete config.servers;

  if (['tile', 'vector', 'geojson', 'text'].indexOf(type) === -1) {
    return null;
  }

  if (type === 'tile') {
    return createTileSource(identifier, config, factory);
  } // setup service for the module's data source


  if (config.data && !(0, _utils.isset)((0, _utils.get)(config, 'data.service'))) {
    const request = apiRequestForConfig(account, (0, _utils.extend)({}, {
      request: {
        server: servers.api
      }
    }, config.data));
    (0, _utils.set)(config, 'data.service', request);
  } // console.log('VECTOR', identifier, config);


  if (type === 'vector') {
    return new _sources.VectorSource(identifier, config);
  }

  if (type === 'geojson') {
    return new _sources.GeoJsonSource(identifier, config);
  }

  if (type === 'text') {
    return new _sources.TextSource(identifier, config);
  }

  return null;
};

exports.createSource = createSource;

const identifierForLayer = layer => layer.replace(/\:[^,]+/g, '');

exports.identifierForLayer = identifierForLayer;

const createAerisSource = (layer, config = {}, factory, layersMetadata) => {
  const {
    account,
    servers,
    timeline = {}
  } = config || {};
  const key = identifierForLayer(layer);
  const identifier = (0, _utils.get)(config, 'id') || key;

  if ((0, _Layers.isTile)(layer) || config.type === 'tile') {
    delete config.data;
    const validate = (0, _utils.isset)(config.validate) ? config.validate : true;

    if (validate === true && !layersMetadata.exists(layer)) {
      const invalid = layersMetadata.findInvalidIds(layer);
      console.warn(`[Aeris] Cannot add layer(s) {${invalid}}, not a valid AerisWeather Maps layer. See https://www.aerisweather.com/support/docs/aeris-maps/reference/map-layers/ for the list of supported AMP layers.`);
      return void 0;
    }

    const isFutureLayer = layersMetadata.isFuture(layer);
    const isBase = layersMetadata.isBase(layer);
    const isOverlay = layersMetadata.isOverlay(layer);
    let alwaysShow = (0, _utils.get)(config, 'alwaysShow');

    if (!(0, _utils.isset)(alwaysShow)) {
      alwaysShow = isFutureLayer ? timeline.alwaysShowFuture : timeline.alwaysShowPast;
    }

    const service = mapRequestForConfig(account, {
      layer,
      request: {
        server: servers.maps
      }
    });
    service.param('format', (0, _utils.get)(config, 'style.format') || 'png'); // override custom config values depending on layer type

    let sourceConfig = config;

    if (isOverlay || isBase) {
      sourceConfig = (0, _utils.extend)(sourceConfig, {
        pane: isOverlay ? 'admin' : null,
        offset: 0,
        alwaysShow: true,
        animation: {
          enabled: false
        }
      });
    } else {
      const totalIntervals = timeline.intervals;
      sourceConfig = (0, _utils.extend)({
        animation: {
          enabled: true,
          intervals: totalIntervals
        }
      }, sourceConfig, {
        offset: (0, _utils.get)(config, 'data.offset'),
        future: isFutureLayer,
        alwaysShow,
        animation: {
          bufferIntervals: timeline.bufferIntervals,
          showLoadingIntervals: timeline.showLoadingIntervals
        }
      });
    }

    sourceConfig.zIndex = (0, _utils.get)(config, 'style.zIndex');
    const source = createTileSource(identifier, (0, _utils.extend)(sourceConfig, {
      data: {
        service
      }
    }), factory);
    source.updateVisibility();
    return source;
  }

  let type = 'vector';

  if ((0, _Layers.isText)(layer)) {
    type = 'text';
  }

  const defaultConfig = (0, _style.configForLayer)(layer);
  const sourceConfig = (0, _utils.extend)({
    data: {
      request: {
        parameters: {
          plimit: 1
        }
      },
      coordinate: item => (0, _utils.get)(item, 'loc')
    },
    requiresBounds: (0, _utils.get)(defaultConfig, 'data.request.action') !== "search"
    /* SEARCH */

  }, defaultConfig, config);
  return createSource(identifier, type, sourceConfig, factory);
};

exports.createAerisSource = createAerisSource;