"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _Layer = _interopRequireDefault(require("./Layer"));

var strings = _interopRequireWildcard(require("../../../../../utils/strings"));

var _utils = require("../../../../../utils");

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* eslint-disable spaced-comment */
/// <reference path="../../../../../../node_modules/maplibre-gl/dist/maplibre-gl.d.ts" />

/* eslint-enable spaced-comment */
class MapboxPolygonLayer extends _Layer.default {
  constructor(layer, polygons, opts = {}, id = undefined) {
    super(layer, opts, id);
    this._needsEventSetup = true;
    this._polygons = polygons;
  }

  get strokeLayerId() {
    return `${this.layerId}-stroke`;
  }

  addTo(map) {
    super.addTo(map);

    if (this._strokeLayer) {
      const contains = map.getLayer(this.strokeLayerId) !== undefined;

      if (!contains) {
        map.addLayer(this._strokeLayer, this.layerId);
      }
    }

    if (this._needsEventSetup) {
      map.on('click', this.layerId, e => {
        this.trigger('click', {
          data: this.data,
          shape: this.renderable
        });
      });
      map.on('mouseenter', this.layerId, e => {
        this.trigger('mouseover', {
          data: this.data,
          shape: this.renderable
        });
      });
      map.on('mouseleave', this.layerId, e => {
        this.trigger('mouseout', {
          data: this.data,
          shape: this.renderable
        });
      });
      this._needsEventSetup = false;
    }
  }

  remove() {
    if (!this.map) return;

    if (this._strokeLayer) {
      const contains = this.map.getLayer(this.strokeLayerId) !== undefined;

      if (contains) {
        this.map.removeLayer(this.strokeLayerId);
      }
    }

    super.remove();
  }

  invalidate() {
    const isMulti = this._polygons.length > 1;
    const polygons = (this._polygons || []).map(polygon => {
      const outer = polygon.outer.map(c => [c.lon, c.lat]);
      const inner = polygon.inner ? polygon.inner.map(p => p.map(c => [c.lon, c.lat])) : [];
      return [outer, ...inner];
    });
    this.source = {
      type: 'geojson',
      data: {
        type: 'FeatureCollection',
        features: [{
          type: 'Feature',
          geometry: {
            type: isMulti ? 'MultiPolygon' : 'Polygon',
            coordinates: isMulti ? polygons : polygons[0] || []
          }
        }]
      }
    };
    this.createRenderable();

    if (this.map) {
      const map = this.map;
      this.remove();
      this.addTo(map);
    }
  }

  createRenderable() {
    const style = this.opts;
    const convertedStyle = {
      fill: {},
      stroke: {}
    }; // format the line/fill styles as required for the Mapbox paint style spec

    ['fill', 'line'].forEach(type => {
      const dest = type === 'line' ? 'stroke' : 'fill';
      Object.keys(style).filter(key => new RegExp(`^${type}-`).test(key)).forEach(prop => {
        const k = strings.hyphenate(prop);

        if ((0, _utils.isset)(style[prop])) {
          convertedStyle[dest][k] = style[prop];
        }
      });
    }); // need to create a separate layer for the stoke style since Mapbox
    // doesn't allow you to set the apply stroke styling to a fill layer

    if (Object.keys(convertedStyle.stroke).length > 0) {
      this._strokeLayer = {
        id: this.strokeLayerId,
        type: 'line',
        source: this.sourceId,
        layout: {},
        paint: convertedStyle.stroke
      };
    }

    return {
      id: this.layerId,
      type: 'fill',
      source: this.sourceId,
      layout: {},
      paint: convertedStyle.fill
    };
  }

}

var _default = MapboxPolygonLayer;
exports.default = _default;
module.exports = exports.default;