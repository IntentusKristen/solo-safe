"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _utils = require("../../../../../utils");

var _MapMarker = _interopRequireDefault(require("../../../layers/MapMarker"));

var _utils2 = require("../../mapbox/utils");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* eslint-disable spaced-comment */
/// <reference path="../../../../../../node_modules/maplibre-gl/dist/maplibre-gl.d.ts" />

/* eslint-enable spaced-comment */
class MapboxMarker extends _MapMarker.default {
  update(opts) {
    var _a;

    if (!(0, _utils.isset)(opts)) return;
    const {
      data
    } = opts;

    if ((0, _utils.isset)(data)) {
      this.data = Object.assign(Object.assign({}, this.data), data);
    }

    const value = (_a = this.data) === null || _a === void 0 ? void 0 : _a.value;
    let style = opts.style || {};

    if ((0, _utils.isFunction)(style)) {
      style = style({
        value
      });
    }

    this.setStyle(style);
  }

  setStyle(style) {
    this.opts.style = style; // Mapbox doesn't support updating an existing marker's element, so we need to create a new marker
    // for each different value associated with a coordinate's data and add/remove it accordingly

    this.invalidate();
  }

  createRenderable() {
    const {
      style
    } = this.opts;
    const coord = this.coordinate;
    const opts = {};

    if (style) {
      opts.icon = (0, _utils2.markerIconFromStyle)(style);

      if (style.zIndex) {
        opts.zIndex = style.zIndex;
      }
    }

    const renderable = new maplibregl.Marker({
      element: opts.icon
    });
    renderable.setLngLat([coord.lon, coord.lat]);

    if (style && style.callout) {
      let content = style.callout;

      if ((0, _utils.isFunction)(style.callout)) {
        const fn = style.callout;
        content = fn();
      }

      const popup = new maplibregl.Popup();
      popup.setHTML(content);
      renderable.setPopup(popup);
    }

    return renderable;
  }

  updateVisibility(visible) {}

  addToMap(map, index) {
    const renderable = this.renderable;

    if (renderable) {
      const el = renderable.getElement();

      this._events.forEach(name => {
        const handlerName = `__awxjs_${name}Handler`;

        if (renderable[handlerName]) {
          el.removeEventListener(name, renderable[handlerName]);
        } else {
          renderable[handlerName] = e => {
            e.stopPropagation();
            this.trigger(name, {
              data: this.data,
              marker: renderable
            });
          };
        }

        el.addEventListener(name, renderable[handlerName]);
      });

      renderable.addTo(map);
    }
  }

  removeFromMap(map) {
    const renderable = this.renderable;

    if (renderable) {
      const el = renderable.getElement();

      this._events.forEach(name => {
        const handlerName = `__awxjs_${name}Handler`;

        if (renderable[handlerName]) {
          el.removeEventListener(name, renderable.__awxjs_clickHandler);
        }
      });

      renderable.remove();
    }
  }

}

var _default = MapboxMarker;
exports.default = _default;
module.exports = exports.default;