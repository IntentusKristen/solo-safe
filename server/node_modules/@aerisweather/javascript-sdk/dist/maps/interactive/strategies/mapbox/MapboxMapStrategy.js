"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _MapStrategy = _interopRequireDefault(require("../MapStrategy"));

var Mapbox = _interopRequireWildcard(require("."));

var _MapboxOverlayFactory = _interopRequireDefault(require("./MapboxOverlayFactory"));

var _utils = require("../../../../utils");

var _utils2 = require("../../../utils");

var _DOM = _interopRequireDefault(require("../../../../display/DOM"));

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* eslint-disable spaced-comment */
/// <reference path="../../../../../node_modules/@types/mapbox-gl/index.d.ts" />

/* eslint-enable spaced-comment */
const MAPBOX_VERSION = '2.0.0';
/**
 * A map strategy for working with the third-party Mapbox GL mapping library.
 *
 * @export
 * @class MapboxMapStrategy
 * @extends {EventDispatcher}
 * @implements {MapStrategy}
 */

class MapboxMapStrategy extends _MapStrategy.default {
  constructor(target, opts) {
    super(target, (0, _utils.extend)({
      accessToken: null,
      style: 'mapbox://styles/mapbox/streets-v9'
    }, opts));
    this._pointAnimationUpdates = {};
    this._shapeDataById = {};
    this._clickedMapLayer = false;
  }

  get strategy() {
    return 'mapbox';
  }

  get $el() {
    return (0, _DOM.default)(this.map.getContainer());
  }

  loadDependencies() {
    const css = document.createElement("style");
    css.innerHTML = '.mapboxgl-marker { line-height: 0; }';
    window.document.body.appendChild(css);
    return new Promise((resolve, reject) => {
      if (typeof mapboxgl === 'undefined' || typeof mapboxgl.Map === 'undefined') {
        Promise.all([(0, _utils.loadStyles)(`https://api.tiles.mapbox.com/mapbox-gl-js/v${MAPBOX_VERSION}/mapbox-gl.css`), (0, _utils.loadScript)(`https://api.tiles.mapbox.com/mapbox-gl-js/v${MAPBOX_VERSION}/mapbox-gl.js`)]).then(() => {
          resolve();
        });
      } else {
        resolve();
      }
    });
  }

  setupMap(target) {
    this._factory = new _MapboxOverlayFactory.default();
    this._eventMapping = {
      load: 'load',
      remove: 'unload',
      resize: 'resize',
      click: 'click',
      dblclick: 'dblclick',
      mousedown: 'mousedown',
      mouseup: 'mouseup',
      mouseover: 'mouseover',
      mouseout: 'mouseout',
      mousemove: 'mousemove',
      zoom: 'zoom',
      zoomstart: 'zoom:start',
      zoomend: 'zoom:end',
      move: 'move',
      movestart: 'move:start',
      moveend: 'move:end'
    };
    const mbversion = mapboxgl.version;

    if (mbversion) {
      let [major, minor] = mbversion.split('.');
      major = parseInt(major, 10);
      minor = parseInt(minor, 10);

      if (major === 0 && minor < 50) {
        throw new Error(`AerisWeather SDK requires Mapbox GL JS version 0.50.0 or higher. You are using version ${mbversion}.`);
      }
    } // set view properties from native map options if defined


    const mapOpts = this.opts.map;

    if (mapOpts) {
      const {
        center,
        zoom
      } = mapOpts;

      if (center && (0, _utils.isArray)(center)) {
        const [lon, lat] = center;

        if ((0, _utils.isset)(lat) && (0, _utils.isset)(lon)) {
          (0, _utils.set)(this.opts, 'center', {
            lat,
            lon
          });
        }
      }

      if (zoom) {
        (0, _utils.set)(this.opts, 'zoom', zoom);
      }
    } // constructor allows passing either an HTMLElement or instance of mapboxgl.Map
    // if mapboxgl.Map instance is provided then don't create a new map instance


    if ((0, _utils2.isMapbox)(target)) {
      this._setInitialView = false;
      this._map = target;
      setTimeout(() => {
        this.trigger('map:ready');
      }, 250);
    } else {
      if ((0, _utils.isString)(target)) {
        target = (0, _DOM.default)(target);
      }

      if ((0, _utils.isArray)(target) && target.length > 0) {
        target = target[0]; // eslint-disable-line no-restricted-globals
      } else if ((0, _utils.isDOM)(target)) {
        const obj = target;
        target = obj[0];
      }

      mapboxgl.accessToken = this.opts.accessToken;
      this._map = new mapboxgl.Map((0, _utils.extend)({}, this.opts.map, {
        container: target,
        style: this.opts.style
      }));
      this._currentMapStyle = this.opts.style;
      const removeZoomControl = (0, _utils.get)(this.opts, 'map.zoomControl') === false;

      if (!removeZoomControl) {
        const controls = new mapboxgl.NavigationControl();

        this._map.addControl(controls, 'bottom-left');
      }

      if (!(0, _utils.isset)(this.opts.center)) {
        (0, _utils.set)(this.opts, 'center', {
          lat: 43.0,
          lon: -93.0
        });
      }

      if (!(0, _utils.isset)(this.opts.zoom)) {
        (0, _utils.set)(this.opts, 'zoom', 7);
      }

      this.map.on('load', () => {
        setTimeout(() => {
          this.trigger('map:ready');
        }, 250);
      });
    }
  }
  /**
   * Updates the base map style using a Mapbox style URL.
   *
   * @param {string} style
   * @returns
   * @memberof MapboxMapStrategy
   */


  setBaseStyle(style) {
    if (style === this._currentMapStyle) return;
    const map = this.map; // grab the existing style and cache all Aeris-related sources and layers
    // so they can be re-added after changing the map style

    const mapStyle = map.getStyle();
    const aerisLayers = mapStyle.layers.filter(layer => /^aeris-/.test(layer.id));
    const aerisSources = Object.keys(mapStyle.sources).filter(key => /^aeris-/.test(key)).reduce((prev, result) => {
      prev[result] = mapStyle.sources[result];
      return prev;
    }, {}); // need to wait for the new style to load before re-adding the previous map data

    map.on('style.load', () => {
      Object.keys(aerisSources).forEach(key => {
        const existing = map.getSource(key);

        if (!existing) {
          map.addSource(key, aerisSources[key]);
        }
      });
      aerisLayers.forEach(layer => {
        const existing = map.getLayer(layer.id);

        if (!existing) {
          map.addLayer(layer);
        }
      });
    }); // update the map style

    map.setStyle(style, {
      diff: true
    });
  }

  setView(center, zoom) {
    this.map.jumpTo({
      center: {
        lat: center.lat,
        lon: center.lon
      },
      zoom: Math.max(1, zoom - 1)
    });
  }

  getCenter() {
    const coord = this._map.getCenter();

    return {
      lat: coord.lat,
      lon: coord.lng
    };
  }

  setCenter(coord) {
    this._map.setCenter({
      lat: coord.lat,
      lon: coord.lon
    });
  }

  getZoom() {
    return this._map.getZoom() + 1;
  }

  setZoom(zoom) {
    this._map.setZoom(Math.max(0, zoom - 1));
  }

  getBounds() {
    const b = this.map.getBounds();
    return {
      north: b.getNorth(),
      west: b.getWest(),
      south: b.getSouth(),
      east: b.getEast()
    };
  }

  setBounds(bounds) {
    const sw = new mapboxgl.LngLat(bounds.west, bounds.south);
    const ne = new mapboxgl.LngLat(bounds.east, bounds.north);
    this.map.fitBounds(new mapboxgl.LngLatBounds(sw, ne));
  }

  fitBounds(bounds, padding = [10, 10]) {
    const sw = new mapboxgl.LngLat(bounds.west, bounds.south);
    const ne = new mapboxgl.LngLat(bounds.east, bounds.north);
    const b = new mapboxgl.LngLatBounds(sw, ne);
    const opts = {};

    if (padding.length === 1) {
      opts.padding = padding[0];
    } else if (padding.length === 2) {
      opts.padding = {
        top: padding[1],
        right: padding[0],
        bottom: padding[1],
        left: padding[0]
      };
    } else if (padding.length === 4) {
      opts.padding = {
        top: padding[0],
        right: padding[1],
        bottom: padding[2],
        left: padding[3]
      };
    }

    this.map.fitBounds(b, opts);
  }
  /** Sources */


  isTile(source) {
    return source instanceof Mapbox.TileSource;
  }

  isMarker(el) {
    if (el === null || el === void 0 ? void 0 : el.renderable) {
      return el.renderable instanceof mapboxgl.Marker;
    }

    return el instanceof mapboxgl.Marker;
  }

  isPolygon(el) {
    return el instanceof Mapbox.Polygon;
  }

  isPolyline(el) {
    return el instanceof Mapbox.Polyline;
  }

  addSource(source) {
    super.addSource(source);

    if (this.isTile(source)) {
      source.updateVisibility();
    }
  }
  /** Overlays */


  addOverlay(overlay) {
    if (overlay instanceof Mapbox.Tile) {
      overlay.addTo(this.map);
    }
  }

  removeOverlay(overlay) {
    if (overlay instanceof Mapbox.Tile) {
      overlay.remove();
    }
  }
  /** Markers */


  addMarker(marker, data) {
    if (marker instanceof Mapbox.Marker) {
      marker.on('click', () => this.trigger("marker:click"
      /* MARKER_CLICK */
      , {
        data,
        marker
      }));
      marker.on('mouseover', () => this.trigger("marker:mouseover"
      /* MARKER_MOUSEOVER */
      , {
        data,
        marker
      }));
      marker.on('mouseout', () => this.trigger("marker:mouseout"
      /* MARKER_MOUSEOUT */
      , {
        data,
        marker
      }));
      marker.addTo(this.map);
    } else if (marker instanceof mapboxgl.Marker) {
      marker.addTo(this.map);
    }

    super.addMarker(marker, data);
  }

  removeMarker(marker) {
    if (marker instanceof Mapbox.Marker) {
      marker.offAll();
      marker.remove();
    } else if (marker instanceof mapboxgl.Marker) {
      marker.remove();
    }

    super.removeMarker(marker);
  }

  updateMarker(marker, options, layer = null) {
    if (!(0, _utils.isset)(options)) return;

    if (marker instanceof Mapbox.Marker) {
      marker.update(options);
    }
  }
  /** Polygons & Polylines */


  addShape(shape, data) {
    if (shape instanceof Mapbox.Polygon || shape instanceof Mapbox.Polyline) {
      shape.on('click', () => this.trigger("shape:click"
      /* SHAPE_CLICK */
      , {
        data,
        shape
      }));
      shape.on('mouseover', () => this.trigger("shape:mouseover"
      /* SHAPE_MOUSEOVER */
      , {
        data,
        shape
      }));
      shape.on('mouseout', () => this.trigger("shape:mouseout"
      /* SHAPE_MOUSEOUT */
      , {
        data,
        shape
      }));
      shape.addTo(this.map);
      this._shapeDataById[shape.id] = data; // this._renderableEvents.forEach((name) => {
      // 	shape.on(name, () => {
      // 		if (name === 'click') {
      // 			this._clickedMapLayer = true;
      // 			setTimeout(() => {
      // 				this._clickedMapLayer = false;
      // 			}, 100);
      // 		}
      // 		this.trigger(`shape:${name}`, { data, shape })
      // 	});
      // });
    }

    super.addShape(shape, data);
  }

  removeShape(shape) {
    if (shape instanceof Mapbox.Polygon || shape instanceof Mapbox.Polyline) {
      shape.offAll();
      shape.remove();
    }

    super.removeShape(shape);
  }

  showShape(shape) {
    if (this.isPolygon(shape) || this.isPolyline(shape)) {
      shape.show();
      return;
    }

    super.showShape(shape);
  }

  hideShape(shape) {
    if (this.isPolygon(shape) || this.isPolyline(shape)) {
      shape.hide();
      return;
    }

    super.hideShape(shape);
  }
  /** Conversions */


  coordToPoint(coord) {
    const p = this.map.project({
      lat: coord.lat,
      lng: coord.lon
    });
    return {
      x: p.x,
      y: p.y
    };
  }

  pointToCoord(point) {
    const c = this.map.unproject([point.x, point.y]);
    return {
      lat: c.lat,
      lon: c.lng
    };
  }
  /** Callout */


  showCallout(target, content, opts) {
    const popup = new mapboxgl.Popup(opts).setHTML(content);

    if ((0, _utils2.isCoordObject)(target)) {
      popup.setLngLat({
        lat: target.lat,
        lng: target.lon
      }).addTo(this.map);
    } else if (this.isMarker(target)) {
      target.setPopup(popup);
      target.togglePopup();
    }
  }

  _setupEvents() {
    this.map.on('movestart', e => {
      ['before:change:bounds', 'before:change:center'].forEach(name => this.trigger(name));
    });
    this.map.on('moveend', e => {
      ['after:change:bounds', 'after:change:center', 'change:bounds', 'change:center'].forEach(name => this.trigger(name));
    });
    this.map.on('zoomstart', e => {
      ['before:change:zoom'].forEach(name => this.trigger(name));
    });
    this.map.on('zoomend', e => {
      ['after:change:zoom', 'change:zoom'].forEach(name => this.trigger(name));
    }); // call super at the bottom so our initial click event handler gets called first to
    // handle layer vs map click triggers

    super._setupEvents();
  }

  _shouldTriggerEvent(name) {
    if (name === 'click') {
      return this._clickedMapLayer === false;
    }

    return true;
  }

  _dataForMapEvent(name, event) {
    if (!event) return null;
    let data = null;

    switch (name) {
      case 'mouseover':
      case 'mousemove':
      case 'mousedown':
      case 'mouseup':
      case 'click':
      case 'dblclick':
        data = {
          coord: {
            lat: event.lngLat.lat,
            lon: event.lngLat.lng
          },
          point: {
            x: event.point.x,
            y: event.point.y
          }
        };
        break;

      default:
        break;
    }

    return data;
  }

}

var _default = MapboxMapStrategy;
exports.default = _default;
module.exports = exports.default;