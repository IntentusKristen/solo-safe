"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.markerIconFromStyle = exports.formatLayerOptions = void 0;

var _utils = require("../../../../utils");

var _strings = require("../../../../utils/strings");

var _color = require("../../../../utils/color");

var _SVG = require("../../../../display/SVG");

/* eslint-disable spaced-comment */
/// <reference path="../../../../../node_modules/@types/openlayers/index.d.ts" />

/* eslint-enable spaced-comment */
const formatLayerOptions = opts => {
  const formatted = {
    stroke: null,
    fill: null
  };

  if (opts.stroke) {
    const {
      r,
      g,
      b
    } = (0, _color.toRGB)(opts.stroke.color); // eslint-disable-line object-curly-newline

    formatted.stroke = {
      color: `rgba(${r}, ${g}, ${b}, ${opts.stroke.opacity || 1.0})`,
      width: opts.stroke.width,
      lineCap: opts.stroke.lineCap,
      lineJoin: opts.stroke.lineJoin,
      lineDash: opts.stroke.dashArray,
      lineDashOffset: opts.stroke.dashOffset
    };
  }

  if (opts.fill) {
    const {
      r,
      g,
      b
    } = (0, _color.toRGB)(opts.fill.color); // eslint-disable-line object-curly-newline

    formatted.fill = {
      color: `rgba(${r}, ${g}, ${b}, ${(0, _utils.isset)(opts.fill.opacity) ? opts.fill.opacity : 1.0})`
    };
  } // convert camelcase style keys to hypenated strings


  Object.keys(formatted).forEach(key => {
    const k = (0, _strings.hyphenate)(key);

    if (k !== key) {
      formatted[k] = formatted[key];
      delete formatted[key];
    }
  });
  return formatted;
};

exports.formatLayerOptions = formatLayerOptions;

const markerIconFromStyle = style => {
  if (style.html) {
    console.warn('awxjs - HTML markers are not currently supported with OpenLayers');
  }

  if (style.svg) {
    let [width, height] = style.size || [12, 12];

    if (style.svg.text) {
      const textStyle = style.svg.text;

      if ((0, _utils.isArray)(textStyle)) {
        textStyle.forEach(styleDef => {
          if (styleDef.autosize) {
            [width, height] = _SVG.SVG.calculateTextSize(styleDef.value, styleDef.size);
          }
        });
      } else {
        const styleDef = textStyle;

        if (styleDef.autosize) {
          [width, height] = _SVG.SVG.calculateTextSize(styleDef.value, styleDef.size);
        }
      }
    }

    height += 3;

    const image = _SVG.SVG.draw(width, height, style.svg);

    return new ol.style.Icon({
      src: `data:image/svg+xml;base64,${btoa(image)}`,
      size: [width, height],
      imgSize: [width, height],
      crossOrigin: 'anonymous'
    });
  }

  if (style.icon) {
    const icon = style.icon;
    return new ol.style.Icon({
      src: icon.url,
      size: style.size,
      imgSize: style.size,
      anchor: icon.anchor,
      crossOrigin: 'anonymous'
    });
  }

  return null;
};

exports.markerIconFromStyle = markerIconFromStyle;