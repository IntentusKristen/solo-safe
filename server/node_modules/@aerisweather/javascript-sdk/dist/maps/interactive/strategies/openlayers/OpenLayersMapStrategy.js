"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _MapStrategy = _interopRequireDefault(require("../MapStrategy"));

var OpenLayers = _interopRequireWildcard(require("."));

var _Event = _interopRequireDefault(require("../../../../event/Event"));

var _OpenLayersOverlayFactory = _interopRequireDefault(require("./OpenLayersOverlayFactory"));

var _OpenLayersTileSource = _interopRequireDefault(require("./sources/OpenLayersTileSource"));

var _Popup = _interopRequireDefault(require("./Popup"));

var _utils = require("../../../../utils");

var _DOM = _interopRequireDefault(require("../../../../display/DOM"));

var _utils2 = require("../../../utils");

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* eslint-disable spaced-comment */
/// <reference path="../../../../../node_modules/@types/openlayers/index.d.ts" />

/* eslint-enable spaced-comment */

/**
 * A map strategy for working with the third-party OpenLayers mapping library.
 *
 * @export
 * @class OpenLayersMapStrategy
 * @extends {MapStrategy}
 * @implements {MapStrategy}
 */
class OpenLayersMapStrategy extends _MapStrategy.default {
  constructor() {
    super(...arguments);
    this._hasLoaded = false;
    this._clickedMapLayer = false;
    this._shapeDataById = {};
  }

  get strategy() {
    return 'openlayers';
  }

  get $el() {
    return (0, _DOM.default)(this.map.getTarget());
  }

  loadDependencies() {
    return new Promise((resolve, reject) => {
      if (typeof ol === 'undefined' || typeof ol.Map === 'undefined') {
        const version = '6.5.0';
        Promise.all([(0, _utils.loadStyles)(`https://openlayers.org/en/v${version}/css/ol.css`), (0, _utils.loadScript)(`https://cdn.rawgit.com/openlayers/openlayers.github.io/master/en/v${version}/build/ol.js`)]).then(() => {
          resolve();
        });
      } else {
        resolve();
      }
    });
  }

  setupMap(target) {
    this._factory = new _OpenLayersOverlayFactory.default();
    this._eventMapping = {
      // rendercomplete: 'load',
      unload: 'unload',
      resize: 'resize',
      // click: 'click',
      dblclick: 'dblclick',
      pointermove: 'mousemove',
      zoom: 'zoom',
      zoomstart: 'zoom:start',
      zoomend: 'zoom:end',
      movestart: 'move:start',
      moveend: 'move:end',
      popupopen: 'popupopen',
      popupclose: 'popupclose'
    };

    _Popup.default.injectStyles(); // set view properties from native map options if defined


    const initView = (0, _utils.get)(this.opts, 'map.view');

    if (initView && initView instanceof ol.View) {
      const [lon, lat] = ol.proj.toLonLat(initView.getCenter());

      if ((0, _utils.isset)(lat) && (0, _utils.isset)(lon)) {
        (0, _utils.set)(this.opts, 'center', {
          lat,
          lon
        });
      }

      (0, _utils.set)(this.opts, 'zoom', initView.getZoom());
    } // constructor allows passing either an HTMLElement or instance of ol.Map
    // if ol.Map instance is provided then don't create a new map instance


    if ((0, _utils2.isOpenLayers)(target)) {
      this._setInitialView = false;
      this._map = target;
    } else {
      if ((0, _utils.isString)(target)) {
        target = (0, _DOM.default)(target);
      }

      if ((0, _utils.isArray)(target) && target.length > 0) {
        target = target[0]; // eslint-disable-line no-restricted-globals
      } else if ((0, _utils.isDOM)(target)) {
        const obj = target;
        target = obj[0];
      }

      const mapOpts = (0, _utils.extend)({
        layers: [new ol.layer.Tile({
          source: new ol.source.OSM()
        })]
      }, this.opts.map);
      mapOpts.target = target;
      this._map = new ol.Map(mapOpts); // position the zoom control at the bottom-left

      (0, _DOM.default)('head').append('<style>.ol-zoom { top: auto; bottom: .5em; }</style>');

      if (!(0, _utils.isset)(this.opts.center)) {
        (0, _utils.set)(this.opts, 'center', {
          lat: 43.0,
          lon: -93.0
        });
      }

      if (!(0, _utils.isset)(this.opts.zoom)) {
        (0, _utils.set)(this.opts, 'zoom', 7);
      }
    }

    setTimeout(() => {
      this.trigger('map:ready');
    }, 250);
  }
  /**
   * Updates the base layer using tiles from the provided URL.
   *
   * @param {string} url
   * @memberof OpenLayersMapStrategy
   */


  setBaseStyle(url) {
    const baseLayer = this.map.getLayers().item(0);
    this.map.removeLayer(baseLayer);
    this.map.getLayers().insertAt(0, new ol.layer.Tile({
      source: (0, _utils.isset)(url) ? new ol.source.XYZ({
        url: url.replace(/\{s\}/, '1')
      }) : new ol.source.OSM()
    }));
  }

  setBaseUrl(url) {
    this.setBaseStyle(url);
  }

  setView(center, zoom) {
    this.map.setView(new ol.View({
      center: ol.proj.fromLonLat([center.lon, center.lat]),
      zoom
    }));
  }

  getCenter() {
    const [lon, lat] = ol.proj.toLonLat(this.map.getView().getCenter());
    return {
      lat,
      lon
    };
  }

  setCenter(coord) {
    this.map.getView().setCenter(ol.proj.fromLonLat([coord.lon, coord.lat]));
  }

  getZoom() {
    return this.map.getView().getZoom();
  }

  setZoom(zoom) {
    this.map.getView().setZoom(zoom);
  }

  getBounds() {
    // const [ minx, miny, maxx, maxy ]: ol.Extent = this.map.getView().calculateExtent(this.map.getSize());
    // const [ west, south ] = ol.proj.toLonLat([ minx, miny ]);
    // const [ east, north ] = ol.proj.toLonLat([ maxx, maxy ]);
    const extent = this.map.getView().calculateExtent(this.map.getSize());
    const [west, south, east, north] = ol.proj.transformExtent(extent, 'EPSG:3857', 'EPSG:4326');
    return {
      north,
      west,
      south,
      east
    };
  }

  setBounds(bounds) {
    const [minx, miny] = ol.proj.fromLonLat([bounds.west, bounds.south]);
    const [maxx, maxy] = ol.proj.fromLonLat([bounds.east, bounds.north]);
    const extent = [minx, miny, maxx, maxy];
    this.map.getView().fit(extent);
  }

  fitBounds(bounds, padding = [10, 10]) {
    const [minx, miny] = ol.proj.fromLonLat([bounds.west, bounds.south]);
    const [maxx, maxy] = ol.proj.fromLonLat([bounds.east, bounds.north]);
    const extent = [minx, miny, maxx, maxy];
    let opts;

    if (padding.length === 1) {
      opts = [padding[0], padding[0], padding[0], padding[0]];
    } else if (padding.length === 2) {
      opts = [padding[1], padding[0], padding[1], padding[0]];
    } else if (padding.length === 4) {
      opts = [padding[0], padding[1], padding[2], padding[3]];
    }

    this.map.getView().fit(extent, {
      padding: opts
    });
  }
  /** Sources */


  isTile(source) {
    return source instanceof _OpenLayersTileSource.default;
  }

  isMarker(el) {
    return el instanceof OpenLayers.Marker;
  }

  isPolygon(el) {
    return el instanceof OpenLayers.Polygon;
  }

  isPolyline(el) {
    return el instanceof OpenLayers.Polyline;
  }
  /** Overlays */


  addOverlay(overlay, index) {
    if (overlay instanceof OpenLayers.Tile) {
      overlay.addTo(this.map, index);
    } else if (overlay instanceof ol.layer.Base || overlay instanceof ol.layer.Tile) {
      if (index) {
        this.map.getLayers().insertAt(index, overlay);
      } else {
        this.map.addLayer(overlay);
      }
    }
  }

  removeOverlay(overlay) {
    if (overlay instanceof OpenLayers.Tile) {
      overlay.remove();
    } else if (overlay instanceof ol.layer.Base || overlay instanceof ol.layer.Tile) {
      this.map.removeLayer(overlay);
    }
  }
  /** Markers */


  addMarker(marker, data) {
    if (marker instanceof OpenLayers.Marker) {
      if (!this.containsLayer(marker.renderable)) {
        marker.on('click', () => this.trigger("marker:click"
        /* MARKER_CLICK */
        , {
          data,
          marker
        }));
        marker.on('mouseover', () => this.trigger("marker:mouseover"
        /* MARKER_MOUSEOVER */
        , {
          data,
          marker
        }));
        marker.on('mouseout', () => this.trigger("marker:mouseout"
        /* MARKER_MOUSEOUT */
        , {
          data,
          marker
        }));
        marker.addTo(this.map);
      }
    } else if (marker instanceof ol.layer.Vector) {
      if (!this.containsLayer(marker)) {
        this.map.addLayer(marker);
      }

      return;
    }

    super.addMarker(marker, data);
  }

  removeMarker(marker) {
    if (marker instanceof OpenLayers.Marker) {
      marker.offAll();
      marker.remove();
    } else if (marker instanceof ol.layer.Vector) {
      this.map.removeLayer(marker);
    }

    super.removeMarker(marker);
  }

  updateMarker(marker, options, layer = null) {
    if (!options) return;

    if (marker instanceof OpenLayers.Marker) {
      marker.update(options);
    }

    super.updateMarker(marker, options, layer);
  }

  showMarkers(markers, show) {
    markers.forEach(marker => {
      if (this.isMarker(marker)) {
        marker = marker.layer;
      }

      if (marker instanceof ol.layer.Vector) {
        marker.setVisible(show);
      }
    });
  }
  /** Polygons & Polylines */


  addShape(shape, data) {
    if (shape instanceof OpenLayers.Polygon || shape instanceof OpenLayers.Polyline) {
      if (!this.containsLayer(shape.renderable)) {
        // need to insert shapes below markers which use Point geometries
        // so grab the index of the first Point layer on the map to use for inserting the shape
        const index = this.getIndexBoundForGeom('point', true);
        shape.on('click', () => this.trigger("shape:click"
        /* SHAPE_CLICK */
        , {
          data,
          shape
        }));
        shape.on('mouseover', () => this.trigger("shape:mouseover"
        /* SHAPE_MOUSEOVER */
        , {
          data,
          shape
        }));
        shape.on('mouseout', () => this.trigger("shape:mouseout"
        /* SHAPE_MOUSEOUT */
        , {
          data,
          shape
        }));
        shape.addTo(this.map, index);
        this._shapeDataById[shape.id] = data;
      }
    }

    super.addShape(shape, data);
  }

  removeShape(shape) {
    if (shape instanceof OpenLayers.Polygon || shape instanceof OpenLayers.Polyline) {
      shape.offAll();
      shape.remove();
    }

    super.removeShape(shape);
  }

  showShape(shape) {
    this.addShape(shape);
  }

  hideShape(shape) {
    this.removeShape(shape);
  }

  containsLayer(layer) {
    const existing = this.map.getLayers().getArray();
    return existing.indexOf(layer) !== -1;
  }
  /** Conversions */


  coordToPoint(coord) {
    if (!(0, _utils.isset)(coord)) {
      return null;
    }

    const point = this.map.getPixelFromCoordinate(ol.proj.fromLonLat([coord.lon, coord.lat]));

    if (point) {
      const [x, y] = point;
      return {
        x,
        y
      };
    }

    return null;
  }

  pointToCoord(point) {
    if (!(0, _utils.isset)(point)) {
      return null;
    }

    const coord = this.map.getCoordinateFromPixel(ol.proj.toLonLat([point.x, point.y]));

    if (coord) {
      const [lon, lat] = coord;
      return {
        lat,
        lon
      };
    }

    return null;
  }

  getInsertIndex(layer, positionOffset) {
    const existing = this.map.getLayers().getArray();
    const index = existing.indexOf(layer);

    if (index !== -1) {
      return Math.max(0, index + positionOffset);
    }

    return existing.length;
  }

  getIndexBoundForGeom(type, min = false) {
    let index = 0;
    const existing = this.map.getLayers().getArray();
    existing.forEach((layer, i) => {
      if (layer instanceof ol.layer.Vector) {
        const source = layer.getSource();
        const features = source.getFeatures();

        if (features && features.length > 0) {
          const geom = features[0].getGeometry();

          if (geom.getType().toLowerCase() === type.toLowerCase()) {
            index = min ? Math.min(index, i) : Math.max(index, i);
          }
        }
      }
    });
    return Math.max(1, index);
  }
  /** Callout */


  showCallout(target, content, opts) {
    const popup = new _Popup.default();
    popup.setHTML(content);

    if ((0, _utils2.isCoordObject)(target)) {
      popup.setCoordinate(target);
    } else if (this.isMarker(target)) {
      popup.setCoordinate(target.coordinate);
    } else if (target instanceof ol.Feature) {
      const geom = target.getGeometry();

      if (geom instanceof ol.geom.Point) {
        const [lon, lat] = geom.getCoordinates();
        popup.setCoordinate({
          lat,
          lon
        });
      }
    }

    if (this._activePopup) {
      this._activePopup.remove();
    }

    this._activePopup = popup;
    popup.addTo(this.map);
  }

  _setupEvents() {
    super._setupEvents();

    const getMouseEventInfo = e => {
      const pixel = this.map.getEventPixel(e);
      const mapCoord = this.map.getEventCoordinate(e);
      const coord = mapCoord ? ol.proj.toLonLat(mapCoord) : [null, null];
      return {
        pixel,
        coord
      };
    }; // OpenLayers doesn't support regular mouse events, so we need to register them on the map's DOM target


    ['mouseover', 'mouseout', 'mousedown', 'mouseup'].forEach(eventName => {
      this.map.getTargetElement().addEventListener(eventName, e => {
        const {
          pixel,
          coord
        } = getMouseEventInfo(e);
        this.trigger(eventName, {
          coord: {
            lat: coord[1],
            lon: coord[0]
          },
          point: {
            x: pixel[0],
            y: pixel[1]
          }
        });
      });
    });
    this.map.on('rendercomplete', () => {
      if (this._hasLoaded === false) {
        this._hasLoaded = true;
        this.trigger('load');
      }
    });
    this.map.on('click', e => {
      // let selectedLayer: ol.layer.Layer;
      // trigger custom events for markers and shape selections in order to properly handle popup
      let selectedMarker = false; // const selected = this.map.getFeaturesAtPixel(e.pixel, {
      // 	layerFilter: (layer) => {
      // 		return (layer instanceof ol.layer.Vector);
      // 	}
      // });
      // if (selected && selected.length > 0) {
      // 	const feature = selected[0];
      // 	const geom = feature.getGeometry();
      // 	if (geom instanceof ol.geom.Point) {
      // 		selectedMarker = true;
      // 		layer.dispatchEvent(new Event('marker:click'));
      // 	} else if (geom instanceof ol.geom.Polygon) {
      // 		this.trigger('shape:click', { shape: feature });
      // 	}
      // }

      let triggered = false;
      this.map.forEachFeatureAtPixel(e.pixel, (feature, layer) => {
        if (!triggered) {
          const geom = feature.getGeometry();
          const props = feature.getProperties();
          const id = (0, _utils.get)(props, 'id') || (0, _utils.get)(props, 'properties.id');
          const dataKey = (id || '').replace(/^aeriswx-/, '');

          if (geom instanceof ol.geom.Point) {
            selectedMarker = true;
            layer.dispatchEvent(new _Event.default('marker:click'));
            triggered = true;
          } else if (geom instanceof ol.geom.SimpleGeometry) {
            const data = this._shapeDataById[dataKey];
            this.trigger('shape:click', {
              shape: feature,
              data
            });
            triggered = true;
          }
        }
      }, {
        hitTolerance: 10
      });

      if (triggered) {
        this._clickedMapLayer = true;
        setTimeout(() => {
          this._clickedMapLayer = false;
        }, 100);
      } else {
        this.trigger('click', this._dataForMapEvent('click', e));
      } // no marker nor shape was selected, hide any active popup


      if (!selectedMarker && this._activePopup) {
        this._activePopup.remove();
      }
    });
    this.map.on('moveend', e => {
      this.trigger('change:bounds');
      this.trigger('change:center');
    });
    this.map.on('zoomend', e => {
      this.trigger('change:zoom');
    });

    const handleFeatureMouseOut = () => {
      if (this._hoveredMapLayer) {
        const {
          type,
          feature
        } = this._hoveredMapLayer;
        this.trigger(`${type}:mouseout`, {
          [type]: feature,
          data: null
        });
        this._hoveredMapLayer = undefined;
      }
    }; // this.map.on('idle', e => this.trigger('idle'));


    this.map.on('pointermove', e => {
      let found = false;
      this.map.forEachFeatureAtPixel(e.pixel, (feature, layer) => {
        var _a, _b;

        if (!found) {
          const geom = feature.getGeometry();
          const props = feature.getProperties();
          const id = (0, _utils.get)(props, 'id') || (0, _utils.get)(props, 'properties.id');
          const dataKey = (id || '').replace(/^aeriswx-/, '');

          if (geom instanceof ol.geom.Point) {
            found = true;

            if (feature !== ((_a = this._hoveredMapLayer) === null || _a === void 0 ? void 0 : _a.feature)) {
              handleFeatureMouseOut();
              this.trigger('marker:mouseover', {
                marker: feature,
                data: null
              });
              this._hoveredMapLayer = {
                type: 'marker',
                feature
              };
            }
          } else if (geom instanceof ol.geom.SimpleGeometry) {
            found = true;

            if (feature !== ((_b = this._hoveredMapLayer) === null || _b === void 0 ? void 0 : _b.feature)) {
              handleFeatureMouseOut();
              const data = this._shapeDataById[dataKey];
              this.trigger('shape:mouseover', {
                shape: feature,
                data
              });
              this._hoveredMapLayer = {
                type: 'shape',
                feature
              };
            }
          }
        }
      });

      if (!found) {
        handleFeatureMouseOut();
      }
    });
  }

  _shouldTriggerEvent(name) {
    if (name === 'click') {
      return this._clickedMapLayer === false;
    }

    return true;
  }

  _dataForMapEvent(name, event) {
    if (!event) return null;
    let data = null;
    let coord;

    switch (name) {
      case 'pointermove':
      case 'click':
      case 'dblclick':
        coord = ol.proj.toLonLat(event.coordinate);
        data = {
          coord: {
            lat: coord[1],
            lon: coord[0]
          },
          point: {
            x: event.pixel[0],
            y: event.pixel[1]
          }
        };
        break;

      default:
        break;
    }

    return data;
  }

}

var _default = OpenLayersMapStrategy;
exports.default = _default;
module.exports = exports.default;