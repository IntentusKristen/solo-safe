"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _TileSource = _interopRequireDefault(require("../../../sources/TileSource"));

var _utils = require("../../../../../utils");

var _utils2 = require("../../../../utils");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* eslint-disable spaced-comment */
///<reference path="../../../../../../node_modules/@types/leaflet/index.d.ts" />

/* eslint-enable spaced-comment */

/**
 * `LeafletTileSource` is a subclass of `TileSource` that creates and manages a single tile layer to
 * be used with an `LeafletMapStrategy`.
 *
 * @export
 * @class LeafletTileSource
 * @extends {TileSource}
 */
class LeafletTileSource extends _TileSource.default {
  constructor() {
    super(...arguments);
    this._visible = true;
    this._exists = false;
  }

  get overlay() {
    return this._overlay;
  }

  set timestamp(value) {
    if (!this.enabled || !(0, _utils.isset)(value)) return;
    value = new Date(value.getFullYear(), value.getMonth(), value.getDate(), value.getHours(), value.getMinutes()); // eslint-disable-line max-len

    if (!this._timestamp || value.getTime() !== this._timestamp.getTime()) {
      this._timestamp = value;

      if (this.isAnimating() === false && this.isAnimationFrame === false) {
        this.animation.hide();
        this.updateVisibility();
      }

      if (this.overlay && this.canShow()) {
        this.overlay.setUrl(this.urlTemplate());
      }
    }
  }
  /**
   * Shows the layer associated with the source.
   *
   * @memberof LeafletTileSource
   */


  show() {
    if (this._hidden === false) return;
    this._hidden = false;

    if (this.overlay) {
      this.overlay.setOpacity(this._opacity);
    }
  }
  /**
   * Hides the layer associated with the source.
   *
   * @memberof LeafletTileSource
   */


  hide() {
    if (this._hidden === true) return;
    this._hidden = true;

    if (this.overlay) {
      this.overlay.setOpacity(0);
    }
  }
  /**
   * Flags the source for removal from the managing map strategy.
   *
   * @memberof LeafletTileSource
   */


  remove() {
    this.trigger('layer:remove', {
      layer: this.overlay
    });
  }
  /**
   * Changes the opacity of source's layer.
   *
   * @param {number} value
   * @memberof LeafletTileSource
   */


  setOpacity(value, update = true) {
    this._opacity = value;

    if (this.overlay && this.isVisible() && update === true) {
      this.overlay.setOpacity(value);
    }

    if (this.animation) {
      this.animation.setOpacity(value);
    }
  }
  /**
   * Changes the z-index of the source's layer.
   *
   * @param {number} value
   * @memberof LeafletTileSource
   */


  setOrder(value) {
    this.overlay.setZIndex(value);
  }

  createOverlay(service, opts = {}) {
    const overlay = L.tileLayer(service.url(), (0, _utils.extend)({}, opts, {
      subdomains: service.range().join('')
    }));
    overlay.on('add', () => {
      this._exists = true;
    }).on('remove', () => {
      this._exists = false;
    });
    return overlay;
  }
  /**
   * Animation Providers
   */


  animationLayerForDate(animation, date, wait = true) {
    return new Promise((resolve, reject) => {
      if (this.dataSource) {
        const source = this.dataSource.tileLayer(this.key, date, (0, _utils.extend)({}, this._opts, {
          id: `${this.identifier}-anim-${(0, _utils2.mapTimestampFromDate)(date)}`,
          opacity: 0,
          data: {
            service: this.service
          },
          animation: {
            enabled: false
          }
        }));
        source.isAnimationFrame = true;
        source.setOpacity(this._opacity, false);
        source.hide();

        if (wait) {
          source.overlay.on('load', () => {
            resolve(source);
          });
        } else {
          resolve(source);
        }

        source.on('layer:remove', () => {
          this.trigger('layer:remove', {
            layer: source.overlay
          });
        });
        this.trigger('layer:add', {
          layer: source.overlay
        });
      } else {
        reject(new Error('No map strategy data source provided'));
      }
    });
  }

}

var _default = LeafletTileSource;
exports.default = _default;
module.exports = exports.default;