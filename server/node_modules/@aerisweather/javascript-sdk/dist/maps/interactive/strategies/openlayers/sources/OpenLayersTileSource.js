"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _TileSource = _interopRequireDefault(require("../../../sources/TileSource"));

var _TileLayer = _interopRequireDefault(require("../layers/TileLayer"));

var _utils = require("../../../../../utils");

var _utils2 = require("../../../../utils");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* eslint-disable spaced-comment */
///<reference path="../../../../../../node_modules/@types/openlayers/index.d.ts" />

/* eslint-enable spaced-comment */

/**
 * `OpenLayersTileSource` is a subclass of `TileSource` that creates and manages a single tile
 * layer to be used with an `OpenLayersMapStrategy`.
 *
 * @export
 * @class OpenLayersTileSource
 * @extends {TileSource}
 */
class OpenLayersTileSource extends _TileSource.default {
  get overlay() {
    return this._overlay;
  }

  set timestamp(value) {
    if (!this.enabled || !(0, _utils.isset)(value)) return;
    value = new Date(value.getFullYear(), value.getMonth(), value.getDate(), value.getHours(), value.getMinutes()); // eslint-disable-line max-len

    if (!this._timestamp || value.getTime() !== this._timestamp.getTime()) {
      this._timestamp = value;

      if (this.isAnimating() === false && this.isAnimationFrame === false) {
        this.animation.hide();
        this.updateVisibility();
      }

      if (this.overlay && this.overlay.isHidden === false && this.canShow()) {
        let url = this.urlTemplate();

        if (url) {
          const range = this.service.range();
          const s = range.filter((v, idx) => idx === 0 || idx === range.length - 1).join('-');
          url = url.replace(/\{s\}/, `{${s}}`);
        }

        this.overlay.setUrl(url);
      }
    }
  }
  /**
   * Shows the layer associated with the source.
   *
   * @memberof OpenLayersTileSource
   */


  show() {
    if (this._hidden === false) return;
    this._hidden = false;

    if (this.overlay) {
      this.overlay.setOpacity(this._opacity);
      this.overlay.show();
    }
  }
  /**
   * Hides the layer associated with the source.
   *
   * @memberof OpenLayersTileSource
   */


  hide() {
    if (this._hidden === true) return;
    this._hidden = true;

    if (this.overlay) {
      this.overlay.hide();
    }
  }
  /**
   * Flags the source for removal from the managing map strategy.
   *
   * @memberof OpenLayersTileSource
   */


  remove() {
    this.trigger('layer:remove', {
      layer: this.overlay
    });
  }
  /**
   * Changes the opacity of source's layer.
   *
   * @param {number} value
   * @memberof OpenLayersTileSource
   */


  setOpacity(value, update = true) {
    // console.log('TileSource.setOpacity', this.key, value, this._hidden);
    this._opacity = value; // if the layer is hidden, always set renderable opacity to 0

    if (this._hidden) {
      value = 0;
    }

    if (this.overlay && update === true) {
      this.overlay.setOpacity(value);
    }

    if (this.animation) {
      this.animation.setOpacity(value);
    }
  }
  /**
   * Changes the z-index of the source's layer.
   *
   * @param {number} value
   * @memberof OpenLayersTileSource
   */


  setOrder(value) {
    if (this.overlay) {
      this.overlay.setZIndex(value);
    }
  }

  createOverlay(service, opts = {}) {
    const overlay = new _TileLayer.default(this.key, {
      type: 'tile',
      attribution: opts.attribution
    }, this.identifier);
    return overlay;
  }
  /**
   * Animation Providers
   */


  animationLayerForDate(animation, date, wait = true) {
    return new Promise((resolve, reject) => {
      if (this.dataSource) {
        const source = this.dataSource.tileLayer(this.key, date, (0, _utils.extend)((0, _utils.cloneDeep)(this._opts), {
          id: `${this.identifier}-anim-${(0, _utils2.mapTimestampFromDate)(date)}`,
          data: {
            service: this.service
          },
          animation: {
            enabled: false
          }
        }));
        source.isAnimationFrame = true;
        source.setOpacity(this._opacity, true);
        source.hide();

        if (wait === false) {
          resolve(source);
        }

        source.overlay.on('load', () => {
          if (wait) {
            resolve(source);
          }

          source.setOpacity(this._opacity, true);
        }); // forward source layer remove event up to the parent source

        source.on('layer:remove', () => {
          this.trigger('layer:remove', {
            layer: source.overlay
          });
        });
        this.trigger('layer:add', {
          layer: source.overlay,
          relativeTo: this.overlay.renderable,
          offset: 1
        }); // must set opacity and hidden after added to map so the internal layer is setup;
        // tiles won't load if layer is hidden, so just set opacity to 0 and then reset when
        // loading has completed
        // source.setOpacity(0);
        // source.setOpacity(this._opacity, false);
        // source.hide();
      } else {
        reject(new Error('No map strategy data source provided'));
      }
    });
  }

}

var _default = OpenLayersTileSource;
exports.default = _default;
module.exports = exports.default;