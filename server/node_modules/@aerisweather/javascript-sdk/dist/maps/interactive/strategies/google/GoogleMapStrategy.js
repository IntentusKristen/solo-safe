"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _MapStrategy = _interopRequireDefault(require("../MapStrategy"));

var Google = _interopRequireWildcard(require("."));

var _GoogleOverlayFactory = _interopRequireDefault(require("./GoogleOverlayFactory"));

var _GoogleTileSource = _interopRequireDefault(require("./sources/GoogleTileSource"));

var _utils = require("../../../../utils");

var _utils2 = require("../../../utils");

var _DOM = _interopRequireDefault(require("../../../../display/DOM"));

var _constants = require("../../../constants");

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// / <reference path="../../../../../node_modules/@types/googlemaps/index.d.ts" />
// declare global {
// 	const google: any
// }
let mapPanes;
/**
 * A map strategy for working with the third-party Google mapping library.
 *
 * @export
 * @class GoogleMapStrategy
 * @extends {EventDispatcher}
 * @implements {MapStrategy}
 */

class GoogleMapStrategy extends _MapStrategy.default {
  constructor(target, opts) {
    super(target, (0, _utils.extend)({
      accessToken: null
    }, opts));
    this.addAttributions = (0, _utils.debounce)(attributions => {
      if ((0, _DOM.default)('#awxjs-attribution').length > 0) return;
      const $el = (0, _DOM.default)('<div id="awxjs-attribution"></div>');
      this.map.controls[google.maps.ControlPosition.BOTTOM_LEFT].push($el[0]);
      const content = attributions.join(' | ');
      const style = {
        'background-color': 'rgba(255,255,255,0.6)',
        'font-size': '10px',
        'padding': '2px 4px 0',
        'white-space': 'nowrap'
      };
      $el.html(`<span style="${Object.keys(style).map(prop => `${prop}: ${style[prop]};`).join(' ')}">${content}</span>`);
    }, 500);
  }

  get strategy() {
    return 'google';
  }

  get $el() {
    return (0, _DOM.default)(this.map.getDiv());
  }

  loadDependencies() {
    return new Promise((resolve, reject) => {
      if (typeof google === 'undefined' || typeof google.maps === 'undefined') {
        const version = '1.3.1';
        Promise.all([(0, _utils.loadScript)(`https://maps.googleapis.com/maps/api/js?key=${this.opts.accessToken}`)]).then(() => {
          resolve();
        });
      } else {
        resolve();
      }
    });
  }

  setupMap(target) {
    this._factory = new _GoogleOverlayFactory.default();
    this._callout = new google.maps.InfoWindow();
    this._eventMapping = {
      click: 'click',
      dblclick: 'dblclick',
      mouseover: 'mouseover',
      mouseout: 'mouseout',
      mousemove: 'mousemove',
      zoom_changed: 'zoom',
      drag: 'move',
      dragstart: 'move:start',
      dragend: 'move:end'
    }; // set view properties from native map options if defined

    const mapOpts = this.opts.map;

    if (mapOpts) {
      const {
        center,
        zoom
      } = mapOpts;

      if ((0, _utils.isPlainObject)(center) && (0, _utils.isset)(center.lat) && (0, _utils.isset)(center.lng)) {
        (0, _utils.set)(this.opts, 'center', {
          lat: center.lat,
          lon: center.lng
        });
      }

      if (zoom) {
        (0, _utils.set)(this.opts, 'zoom', zoom);
      }
    } // constructor allows passing either an HTMLElement or instance of google.maps.Map
    // if an google.maps.Map instance is provided then don't create a new map instance


    if ((0, _utils2.isGoogle)(target)) {
      this._setInitialView = false;
      this._map = target;
    } else {
      if ((0, _utils.isString)(target)) {
        target = (0, _DOM.default)(target);
      }

      if ((0, _utils.isArray)(target) && target.length > 0) {
        target = target[0]; // eslint-disable-line no-restricted-globals
      } else if ((0, _utils.isDOM)(target)) {
        const obj = target;
        target = obj[0];
      }

      const removeZoomControl = (0, _utils.get)(this.opts, 'map.zoomControl') === false;
      this._map = new google.maps.Map(target, (0, _utils.extend)({
        disableDefaultUI: true,
        zoomControl: !removeZoomControl,
        zoomControlOptions: {
          position: google.maps.ControlPosition.LEFT_BOTTOM
        }
      }, this.opts.map));

      if (!(0, _utils.isset)(this.opts.center)) {
        (0, _utils.set)(this.opts, 'center', {
          lat: 43.0,
          lon: -93.0
        });
      }

      if (!(0, _utils.isset)(this.opts.zoom)) {
        (0, _utils.set)(this.opts, 'zoom', 7);
      }
    } // class _DummyOverlayView extends google.maps.OverlayView {
    // 	draw() {
    // 		mapPanes = this.getPanes();
    // 	}
    // }
    // const dummy = new _DummyOverlayView();
    // dummy.setMap(this._map);


    setTimeout(() => {
      this.trigger('map:ready');
    }, 250);
  }

  setBaseStyle(style) {
    console.warn('[Aeris] `setBaseStyle` is not supported for the Google Maps strategy');
  }

  setView(center, zoom) {
    this.map.setOptions({
      center: {
        lat: center.lat,
        lng: center.lon
      },
      zoom
    });
  }

  getCenter() {
    const coord = this.map.getCenter();
    return {
      lat: coord.lat(),
      lon: coord.lng()
    };
  }

  setCenter(coord) {
    this.map.setCenter({
      lat: coord.lat,
      lng: coord.lon
    });
  }

  getZoom() {
    return this.map.getZoom();
  }

  setZoom(zoom) {
    this.map.setZoom(zoom);
  }

  getBounds() {
    const b = this.map.getBounds();

    if (b) {
      const ne = b.getNorthEast();
      const sw = b.getSouthWest();
      return {
        north: ne.lat(),
        west: sw.lng(),
        south: sw.lat(),
        east: ne.lng()
      };
    }

    return null;
  }

  setBounds(bounds) {
    const sw = new google.maps.LatLng(bounds.south, bounds.west);
    const ne = new google.maps.LatLng(bounds.north, bounds.east);
    this.map.fitBounds(new google.maps.LatLngBounds(sw, ne), 0);
  }

  fitBounds(bounds, padding = [10, 10]) {
    const sw = new google.maps.LatLng(bounds.south, bounds.west);
    const ne = new google.maps.LatLng(bounds.north, bounds.east);
    const b = new google.maps.LatLngBounds(sw, ne);
    let opts;

    if (padding.length === 1) {
      opts = padding[0];
    } else if (padding.length === 2) {
      opts = {
        top: padding[1],
        right: padding[0],
        bottom: padding[1],
        left: padding[0]
      };
    } else if (padding.length === 4) {
      opts = {
        top: padding[0],
        right: padding[1],
        bottom: padding[2],
        left: padding[3]
      };
    }

    this.map.fitBounds(b, opts);
  }

  removeAttributions() {
    (0, _DOM.default)('#awxjs-attribution').remove();
  }
  /** Sources */


  isTile(source) {
    return source instanceof _GoogleTileSource.default;
  }

  isMarker(el) {
    if (el === null || el === void 0 ? void 0 : el.renderable) {
      return el.renderable instanceof google.maps.Marker;
    }

    return el instanceof google.maps.Marker;
  }

  isPolygon(el) {
    return el instanceof google.maps.Polygon;
  }

  isPolyline(el) {
    return el instanceof google.maps.Polyline;
  }

  addSource(source) {
    super.addSource(source);

    if (source instanceof _GoogleTileSource.default && mapPanes) {
      source.node = mapPanes.mapPane.lastElementChild;
      source.node.id = `awxjs-layer-${source.identifier}`;
    }

    if (this.opts.attribution) {
      this.addAttributions([_constants.AERIS_ATTRIBUTION]);
    }
  }

  removeSource(source) {
    super.removeSource(source);

    if (this.sources.length === 0) {
      this.removeAttributions();
    }
  }
  /** Overlays */


  addOverlay(overlay) {
    if (overlay instanceof Google.Tile) {
      overlay.enabled = true;
      overlay.addTo(this.map);
    } else if (overlay instanceof google.maps.ImageMapType) {
      this.map.overlayMapTypes.push(overlay);
    } else if (overlay instanceof google.maps.GroundOverlay) {
      overlay.setMap(this.map);
    }
  }

  removeOverlay(overlay) {
    if (overlay instanceof Google.Tile) {
      overlay.enabled = false;
      overlay.remove();
    } else if (overlay instanceof google.maps.ImageMapType) {
      const overlayIndex = this.map.overlayMapTypes.getArray().indexOf(overlay);

      if (overlayIndex !== -1) {
        this.map.overlayMapTypes.removeAt(overlayIndex);
      }
    } else if (overlay instanceof google.maps.GroundOverlay) {
      overlay.setMap(null);
    }
  }
  /** Markers */


  addMarker(marker, data) {
    if (marker instanceof Google.Marker) {
      marker.on('click', () => this.trigger("marker:click"
      /* MARKER_CLICK */
      , {
        data,
        marker
      }));
      marker.on('mouseover', () => this.trigger("marker:mouseover"
      /* MARKER_MOUSEOVER */
      , {
        data,
        marker
      }));
      marker.on('mouseout', () => this.trigger("marker:mouseout"
      /* MARKER_MOUSEOUT */
      , {
        data,
        marker
      }));
      marker.addTo(this.map);
    } else if (marker instanceof google.maps.Marker) {
      marker.setMap(this.map);
    }

    super.addMarker(marker, data);
  }

  removeMarker(marker) {
    if (marker instanceof Google.Marker) {
      marker.offAll();
      marker.remove();
    } else if (marker instanceof google.maps.Marker) {
      marker.setMap(null);
    }

    super.removeMarker(marker);
  }

  updateMarker(marker, options, layer = null) {
    if (!options) return;

    if (marker instanceof Google.Marker) {
      marker.update(options);
    }
  }

  bindCalloutToMarker(marker, content) {
    if (this.isMarker(marker)) {
      marker.addListener('click', () => {
        this._callout.setContent(content);

        this._callout.open(this.map, marker);
      });
    }
  }
  /** Polygons & Polylines */


  addShape(shape, data) {
    if (shape instanceof Google.Polygon || shape instanceof Google.Polyline) {
      shape.on('click', () => this.trigger("shape:click"
      /* SHAPE_CLICK */
      , {
        data,
        shape
      }));
      shape.on('mouseover', () => this.trigger("shape:mouseover"
      /* SHAPE_MOUSEOVER */
      , {
        data,
        shape
      }));
      shape.on('mouseout', () => this.trigger("shape:mouseout"
      /* SHAPE_MOUSEOUT */
      , {
        data,
        shape
      }));
      shape.addTo(this.map);
    } else if (this.isPolygon(shape) || this.isPolyline(shape)) {
      shape.setMap(this.map);
    }

    super.addShape(shape, data);
  }

  removeShape(shape) {
    if (shape instanceof Google.Polygon || shape instanceof Google.Polyline) {
      shape.offAll();
      shape.remove();
    } else if (this.isPolygon(shape) || this.isPolyline(shape)) {
      shape.setMap(null);
    }

    super.removeShape(shape);
  }

  showShape(shape) {
    this.addShape(shape);
  }

  hideShape(shape) {
    this.removeShape(shape);
  }
  /** Conversions */


  coordToPoint(coord) {
    if (!(0, _utils.isset)(coord)) {
      return null;
    } // GoogleMaps doesn't account for current zoom level when calling `fromLatLngToPoint`, so
    // we need to calculate the point based on the current zoom ourselves


    const proj = this.map.getProjection();
    const bounds = this.map.getBounds();
    const tr = proj.fromLatLngToPoint(bounds.getNorthEast());
    const bl = proj.fromLatLngToPoint(bounds.getSouthWest());
    const scale = Math.pow(this.map.getZoom(), 2);
    const p = proj.fromLatLngToPoint(new google.maps.LatLng(coord.lat, coord.lon));
    return {
      x: (p.x - bl.x) * scale,
      y: (p.y - tr.y) * scale
    };
  }

  pointToCoord(point) {
    if (!(0, _utils.isset)(point)) {
      return null;
    } // GoogleMaps doesn't account for current zoom level when calling `fromPointToLatLng`, so
    // we need to calculate the coordinate based on the current zoom ourselves


    const proj = this.map.getProjection();
    const bounds = this.map.getBounds();
    const tr = proj.fromLatLngToPoint(bounds.getNorthEast());
    const bl = proj.fromLatLngToPoint(bounds.getSouthWest());
    const scale = Math.pow(this.map.getZoom(), 2);
    const c = proj.fromPointToLatLng(new google.maps.Point(point.x / scale * bl.x, point.y / scale + tr.y));
    return {
      lat: c.lat(),
      lon: c.lng()
    };
  }
  /** Callout */


  showCallout(target, content, opts) {
    if ((0, _utils2.isCoordObject)(target)) {
      const popup = new google.maps.InfoWindow(Object.assign(Object.assign({}, opts), {
        position: new google.maps.LatLng(target.lat, target.lon),
        content
      }));
      popup.open(this.map);
    } else if (target instanceof google.maps.Marker) {
      const popup = new google.maps.InfoWindow(Object.assign(Object.assign({}, opts), {
        content
      }));
      popup.open(this.map, target);
    }
  }

  _setupEvents() {
    super._setupEvents();

    const handleBoundsChange = () => {
      this.trigger('change:bounds');
      this.trigger('change:center');
    };

    this.map.addListener('dragend', e => {
      handleBoundsChange();
    });
    this.map.addListener('zoom_changed', e => {
      handleBoundsChange();
      this.trigger('change:zoom');
    });
  }

  _dataForMapEvent(name, event) {
    if (!event) return null;
    const pixel = event.pixel || {
      x: undefined,
      y: undefined
    };
    let data = null;

    switch (name) {
      case 'mouseover':
      case 'mousemove':
      case 'mousedown':
      case 'mouseup':
      case 'click':
      case 'dblclick':
        data = {
          coord: {
            lat: event.latLng.lat(),
            lon: event.latLng.lng()
          },
          point: {
            x: pixel.x,
            y: pixel.y
          }
        };
        break;

      default:
        break;
    }

    return data;
  }

}

var _default = GoogleMapStrategy;
exports.default = _default;
module.exports = exports.default;