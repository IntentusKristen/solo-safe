"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _Layer = _interopRequireDefault(require("./Layer"));

var _utils = require("../../../../../utils");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

class GoogleTileLayer extends _Layer.default {
  setOpacity(value) {
    super.setOpacity(value);

    if (this.renderable) {
      this.renderable.setOpacity(value);
    }
  }

  setZIndex(index) {
    if (this.map && this.renderable) {
      const overlayIndex = this.map.overlayMapTypes.getArray().indexOf(this.renderable);

      if (overlayIndex !== -1) {
        this.map.overlayMapTypes.removeAt(overlayIndex);
        this.map.overlayMapTypes.insertAt(index, this.renderable);
      }
    }
  }

  updateVisibility(visible) {
    if (this.renderable) {
      this.renderable.setOpacity(visible ? this.opacity : 0);
    }
  }

  setUrl(url) {
    this.opts.url = url;

    if (this.map) {
      this.invalidate();
    }
  }

  invalidate() {
    const map = this.map;
    this.remove();
    setTimeout(() => {
      if (this.enabled) {
        this.addTo(map);
      }
    }, 200);
  }

  createRenderable() {
    const renderable = new google.maps.ImageMapType({
      name: this.id,
      opacity: this.opacity,
      tileSize: new google.maps.Size(256, 256),
      getTileUrl: (tileCoord, zoom) => {
        let url = this.opts.url;

        if (!(0, _utils.isset)(url)) {
          return null;
        }

        const vars = {
          x: tileCoord.x,
          y: tileCoord.y,
          z: zoom,
          s: Math.abs(tileCoord.x + tileCoord.y) % 4 + 1
        };
        Object.keys(vars).forEach(k => {
          url = url.replace(new RegExp(`{${k}}`), `${vars[k]}`);
        });
        return url;
      }
    });
    google.maps.event.addListenerOnce(renderable, 'tilesloaded', () => {
      this.trigger('load', {
        overlay: renderable
      });
    });
    return renderable;
  }

  addToMap(map) {
    if (this.renderable) {
      if (this.opts.zIndex >= 0) {
        // const overlayArray = this.map.overlayMapTypes.getArray()
        map.overlayMapTypes.insertAt(this.opts.zIndex, this.renderable);
      } else {
        map.overlayMapTypes.push(this.renderable);
      }
    }
  }

  removeFromMap(map) {
    if (this.renderable) {
      google.maps.event.clearListeners(this.renderable, 'tilesloaded');
      const overlayIndex = this.map.overlayMapTypes.getArray().indexOf(this.renderable);

      if (overlayIndex !== -1) {
        this.map.overlayMapTypes.removeAt(overlayIndex);
      }
    }
  }

}

var _default = GoogleTileLayer;
exports.default = _default;
module.exports = exports.default;