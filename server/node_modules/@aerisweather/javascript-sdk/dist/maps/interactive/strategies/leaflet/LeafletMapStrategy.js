"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _MapStrategy = _interopRequireDefault(require("../MapStrategy"));

var _LeafletOverlayFactory = _interopRequireDefault(require("./LeafletOverlayFactory"));

var Leaflet = _interopRequireWildcard(require("."));

var _utils = require("../../../utils");

var _utils2 = require("../../../../utils");

var _DOM = _interopRequireDefault(require("../../../../display/DOM"));

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// / <reference path="../../../../../node_modules/@types/leaflet/index.d.ts" />

/**
 * A map strategy for working with the third-party Leaflet mapping library.
 *
 * @export
 * @class LeafletMapStrategy
 * @extends {EventDispatcher}
 * @implements {MapStrategy}
 */
class LeafletMapStrategy extends _MapStrategy.default {
  constructor(target, opts) {
    super(target, (0, _utils2.extend)({
      style: null,
      map: {
        worldCopyJump: true
      }
    }, opts));
    this._clickedMapLayer = false;
  }

  get strategy() {
    return 'leaflet';
  }

  get $el() {
    return (0, _DOM.default)(this.map.getContainer());
  }

  loadDependencies() {
    return new Promise((resolve, reject) => {
      if (typeof L === 'undefined' || typeof L.map === 'undefined') {
        const version = '1.7.0';
        Promise.all([(0, _utils2.loadStyles)(`https://unpkg.com/leaflet@${version}/dist/leaflet.css`), (0, _utils2.loadScript)(`https://unpkg.com/leaflet@${version}/dist/leaflet.js`)]).then(() => {
          resolve();
        });
      } else {
        resolve();
      }
    });
  }

  setupMap(target) {
    this._factory = new _LeafletOverlayFactory.default();
    this._eventMapping = {
      load: 'load',
      unload: 'unload',
      resize: 'resize',
      click: 'click',
      dblclick: 'dblclick',
      mousedown: 'mousedown',
      mouseup: 'mouseup',
      mouseover: 'mouseover',
      mouseout: 'mouseout',
      mousemove: 'mousemove',
      zoom: 'zoom',
      zoomstart: 'zoom:start',
      zoomend: 'zoom:end',
      move: 'move',
      movestart: 'move:start',
      moveend: 'move:end',
      popupopen: 'popupopen',
      popupclose: 'popupclose'
    }; // set view properties from native map options if defined

    const mapOpts = this.opts.map;

    if (mapOpts) {
      const {
        center,
        zoom
      } = mapOpts;

      if (center && (0, _utils2.isset)(center.lat) && (0, _utils2.isset)(center.lng)) {
        (0, _utils2.set)(this.opts, 'center', {
          lat: center.lat,
          lon: center.lng
        });
      }

      if (zoom) {
        (0, _utils2.set)(this.opts, 'zoom', zoom);
      }
    } // constructor allows passing either an HTMLElement or instance of L.Map
    // if L.Map instance is provided then don't create a new map instance


    if ((0, _utils.isLeaflet)(target)) {
      this._setInitialView = false;
      this._map = target;
    } else {
      if ((0, _utils2.isString)(target)) {
        target = (0, _DOM.default)(target);
      }

      if ((0, _utils2.isArray)(target) && target.length > 0) {
        target = target[0]; // eslint-disable-line no-restricted-globals
      } else if ((0, _utils2.isDOM)(target)) {
        const obj = target;
        target = obj[0];
      }

      this._map = L.map(target, (0, _utils2.extend)({
        zoomControl: false
      }, this.opts.map));
      const removeZoomControl = (0, _utils2.get)(this.opts, 'map.zoomControl') === false;

      if (!removeZoomControl) {
        L.control.zoom({
          position: 'bottomleft'
        }).addTo(this._map);
      }

      if (!(0, _utils2.isset)(this.opts.center)) {
        (0, _utils2.set)(this.opts, 'center', {
          lat: 43.0,
          lon: -93.0
        });
      }

      if (!(0, _utils2.isset)(this.opts.zoom)) {
        (0, _utils2.set)(this.opts, 'zoom', 7);
      }

      this.map.createPane('base');
      this.map.getPane('base').style.zIndex = `199`;
      const baseUrl = (0, _utils2.get)(this.opts, 'style');

      if (!(0, _utils2.isEmpty)(baseUrl)) {
        this._baseLayer = L.tileLayer(baseUrl, {
          pane: 'base'
        });
      } else {
        this._baseLayer = L.tileLayer('https://{s}.tile.osm.org/{z}/{x}/{y}.png', {
          attribution: '&copy; <a href="http://osm.org/copyright">OpenStreetMap</a> contributors',
          pane: 'base'
        });
      }

      this._baseLayer.addTo(this.map);
    } // create 'admin' pane for AMP overlays


    this.map.createPane('admin');
    this.map.getPane('admin').style.zIndex = `210`;
    setTimeout(() => {
      this.trigger('map:ready');
    }, 250);
  }
  /**
   * Updates the base layer using tiles from the provided URL.
   *
   * @param {string} url
   * @memberof LeafletMapStrategy
   */


  setBaseStyle(url) {
    if ((0, _utils2.isEmpty)(url)) return;

    if (this._baseLayer) {
      this._baseLayer.remove();
    }

    this._baseLayer = L.tileLayer(url, {
      pane: 'base'
    });

    this._baseLayer.addTo(this.map);
  }

  setBaseUrl(url) {
    this.setBaseStyle(url);
  }

  setView(center, zoom) {
    if (!this._map) return;
    this.map.setView({
      lat: center.lat,
      lng: center.lon
    }, zoom);
  }

  getCenter() {
    if (!this._map) return null;

    const coord = this._map.getCenter();

    return {
      lat: coord.lat,
      lon: coord.lng
    };
  }

  setCenter(coord) {
    if (!this._map) return;

    this._map.setView({
      lat: coord.lat,
      lng: coord.lon
    }, this.getZoom());
  }

  getZoom() {
    if (!this._map) return 0;
    return this._map.getZoom();
  }

  setZoom(zoom) {
    if (!this._map) return;

    this._map.setZoom(zoom);
  }

  getBounds() {
    if (!this._map) return null;
    const b = this.map.getBounds();
    return {
      north: b.getNorth(),
      west: b.getWest(),
      south: b.getSouth(),
      east: b.getEast()
    };
  }

  setBounds(bounds) {
    if (!this._map) return;
    const sw = new L.LatLng(bounds.south, bounds.west);
    const ne = new L.LatLng(bounds.north, bounds.east);
    this.map.fitBounds(new L.LatLngBounds(sw, ne));
  }

  fitBounds(bounds, padding = [10, 10]) {
    if (!this._map) return;
    const sw = new L.LatLng(bounds.south, bounds.west);
    const ne = new L.LatLng(bounds.north, bounds.east);
    const b = new L.LatLngBounds(sw, ne);

    if (!b.isValid()) {
      console.warn(`[Aeris] Cannot fit bounds, invalid bounds - nw: ${bounds.north}, ${bounds.west}; se: ${bounds.south}, ${bounds.east}`);
      return;
    }

    const opts = {};

    if (padding.length === 2) {
      opts.padding = L.point(padding[0], padding[1]);
    } else if (padding.length === 4) {
      opts.paddingTopLeft = L.point(padding[3], padding[0]);
      opts.paddingBottomRight = L.point(padding[1], padding[2]);
    }

    this.map.fitBounds(b, opts);
  }
  /** Sources */


  isTile(source) {
    return source instanceof Leaflet.TileSource;
  }

  isMarker(el) {
    if (el === null || el === void 0 ? void 0 : el.renderable) {
      return el.renderable instanceof L.Marker;
    }

    return el instanceof L.Marker;
  }

  isPolygon(el) {
    if ((el === null || el === void 0 ? void 0 : el.renderable) && el.renderable instanceof Leaflet.Polygon) {
      return true;
    }

    return el instanceof Leaflet.Polygon;
  }

  isPolyline(el) {
    if ((el === null || el === void 0 ? void 0 : el.renderable) && el.renderable instanceof Leaflet.Polyline) {
      return true;
    }

    return el instanceof Leaflet.Polyline;
  }
  /** Overlays */


  addOverlay(overlay) {
    if (overlay instanceof L.Layer || overlay instanceof L.TileLayer) {
      overlay.addTo(this.map);
    }
  }

  removeOverlay(overlay) {
    if (overlay instanceof L.Layer || overlay instanceof L.TileLayer) {
      overlay.remove();
    }
  }
  /** Markers */


  addMarker(marker, data) {
    if (marker instanceof Leaflet.Marker) {
      marker.on('click', () => this.trigger("marker:click"
      /* MARKER_CLICK */
      , {
        data,
        marker
      }));
      marker.on('mouseover', () => this.trigger("marker:mouseover"
      /* MARKER_MOUSEOVER */
      , {
        data,
        marker
      }));
      marker.on('mouseout', () => this.trigger("marker:mouseout"
      /* MARKER_MOUSEOUT */
      , {
        data,
        marker
      }));
      marker.addTo(this.map);
    } else if (marker instanceof L.Marker) {
      marker.addTo(this.map);
    }

    super.addMarker(marker, data); // console.error(`Cannot add marker ${marker}, invalid map object`, marker);
  }

  removeMarker(marker) {
    if (marker instanceof Leaflet.Marker) {
      marker.offAll();
      marker.remove();
    } else if (marker instanceof L.Marker) {
      marker.remove();
    }

    super.removeMarker(marker);
  }

  updateMarker(marker, options, layer = null) {
    if (!options) return;

    if (marker instanceof Leaflet.Marker) {
      marker.update(options);
    }
  }

  bindCalloutToMarker(marker, content) {//
  }
  /** Polygons & Polylines */


  addShape(shape, data) {
    if (shape instanceof Leaflet.Polyline || shape instanceof Leaflet.Polygon) {
      shape.on('click', () => this.trigger("shape:click"
      /* SHAPE_CLICK */
      , {
        data,
        shape
      }));
      shape.on('mouseover', () => this.trigger("shape:mouseover"
      /* SHAPE_MOUSEOVER */
      , {
        data,
        shape
      }));
      shape.on('mouseout', () => this.trigger("shape:mouseout"
      /* SHAPE_MOUSEOUT */
      , {
        data,
        shape
      }));
      shape.addTo(this.map);
    }

    super.addShape(shape, data);
  }

  removeShape(shape) {
    if (shape instanceof Leaflet.Polyline || shape instanceof Leaflet.Polygon) {
      shape.offAll();
      shape.remove();
    }

    super.removeShape(shape);
  }

  showShape(shape) {
    this.addShape(shape);
  }

  hideShape(shape) {
    this.removeShape(shape);
  }
  /** Conversions */


  coordToPoint(coord) {
    if (!coord) return null;
    const p = this.map.latLngToContainerPoint({
      lat: coord.lat,
      lng: coord.lon
    });
    return {
      x: p.x,
      y: p.y
    };
  }

  pointToCoord(point) {
    if (!point) return null;
    const c = this.map.containerPointToLatLng([point.x, point.y]);
    return {
      lat: c.lat,
      lon: c.lng
    };
  }
  /** Callout */


  showCallout(target, content, opts) {
    if ((0, _utils.isCoordObject)(target)) {
      this.map.openPopup(content, new L.LatLng(target.lat, target.lon), opts);
    } else if (this.isMarker(target)) {
      target.unbindPopup().bindPopup(content, opts).openPopup();
    }
  }

  _setupEvents() {
    super._setupEvents();

    this.map.on('movestart', e => {
      ['before:change:bounds', 'before:change:center'].forEach(name => this.trigger(name));
    });
    this.map.on('moveend', e => {
      ['after:change:bounds', 'after:change:center', 'change:bounds', 'change:center'].forEach(name => this.trigger(name));
    });
    this.map.on('zoomstart', e => {
      ['before:change:zoom'].forEach(name => this.trigger(name));
    });
    this.map.on('zoomend', e => {
      ['after:change:zoom', 'change:zoom'].forEach(name => this.trigger(name));
    });
  }

  _shouldTriggerEvent(name) {
    if (name === 'click') {
      return this._clickedMapLayer === false;
    }

    return true;
  }

  _dataForMapEvent(name, event) {
    if (!event) return null;
    let data = null;

    switch (name) {
      case 'mouseover':
      case 'mousemove':
      case 'mousedown':
      case 'mouseup':
      case 'click':
      case 'dblclick':
        data = {
          coord: {
            lat: event.latlng.lat,
            lon: event.latlng.lng
          },
          point: {
            x: event.containerPoint.x,
            y: event.containerPoint.y
          }
        };
        break;

      default:
        break;
    }

    return data;
  }

}

var _default = LeafletMapStrategy;
exports.default = _default;
module.exports = exports.default;