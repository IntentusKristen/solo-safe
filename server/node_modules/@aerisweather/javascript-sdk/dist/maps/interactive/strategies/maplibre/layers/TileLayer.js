"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _Layer = _interopRequireDefault(require("./Layer"));

var _utils = require("../../../../../utils");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* eslint-disable spaced-comment */
/// <reference path="../../../../../../node_modules/maplibre-gl/dist/maplibre-gl.d.ts" />

/* eslint-enable spaced-comment */

/**
 * `TileLayer` is a container class that is responsible for creating and managing a Mapbox
 * source and associated layer representation on a Mapbox map.
 */
class MapboxTileLayer extends _Layer.default {
  constructor(layer, opts, id = undefined) {
    super(layer, (0, _utils.extend)({
      type: 'tile'
    }, opts), id);
    this._type = this.opts.type;
  }
  /**
   * Updates the tile or image url for the layer.
   *
   * @param {string} url
   * @memberof TileLayer
   */


  setUrl(url) {
    this.opts.url = url;

    if (this.map) {
      this.invalidate();
    }
  }
  /**
   * Updates the bounds for the layer when rendered as an image.
   *
   * @param {GeoBounds} bounds
   * @memberof TileLayer
   */


  setBounds(bounds) {
    this.opts.bounds = bounds;
  }
  /**
   * Updates the layer source using the specified image URL and coordinate bounds. Only used
   * for `image` layer types.
   *
   * @param {string} url
   * @param {GeoBounds} [bounds=undefined]
   * @returns
   * @memberof TileLayer
   */


  setImage(url, bounds = undefined) {
    this.opts.url = url;
    const map = this.map;
    if (!map) return;
    if (!bounds) bounds = this.opts.bounds;
    const source = map.getSource(this.sourceId);

    if (source) {
      source.updateImage({
        url,
        coordinates: [[bounds.west, bounds.north], [bounds.east, bounds.north], [bounds.east, bounds.south], [bounds.west, bounds.south]]
      });
    } else {
      this.invalidate();
    }
  }

  invalidate() {
    const {
      url,
      bounds
    } = this.opts;
    if (!url) return;

    if (this._type === 'image') {
      if (!bounds) {
        return;
      }

      this.source = {
        type: 'image',
        url,
        coordinates: [[bounds.west, bounds.north], [bounds.east, bounds.north], [bounds.east, bounds.south], [bounds.west, bounds.south]]
      };
    } else {
      this.source = {
        type: 'raster',
        tiles: [1, 2, 3, 4].map(s => url.replace(/\{s\}/, `${s}`)),
        tileSize: 256,
        attribution: this.opts.attribution || ''
      };
    }

    this.createRenderable();

    if (this.map) {
      const map = this.map;
      this.remove();
      this.addTo(map);
    }
  }

  updateVisibility(visible) {
    if (this.exists()) {
      this.map.setPaintProperty(this.layerId, 'raster-opacity', visible ? this.opacity : 0);
    }
  }

  createRenderable() {
    return {
      id: this.layerId,
      type: 'raster',
      source: this.sourceId,
      paint: {
        'raster-opacity': this.opacity,
        'raster-opacity-transition': {
          duration: 0,
          delay: 0
        },
        'raster-fade-duration': 0
      }
    };
  }

}

var _default = MapboxTileLayer;
exports.default = _default;
module.exports = exports.default;