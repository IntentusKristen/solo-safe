"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _TileSource = _interopRequireDefault(require("../../../sources/TileSource"));

var _utils = require("../../../../../utils");

var _utils2 = require("../../../../utils");

var _TileLayer = _interopRequireDefault(require("../layers/TileLayer"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* eslint-disable spaced-comment */
///<reference path="../../../../../../node_modules/@types/googlemaps/index.d.ts" />

/* eslint-enable spaced-comment */

/**
 * `GoogleTileSource` is a subclass of `TileSource` that creates and manages a single tile layer to
 * be used with an `GoogleMapStrategy`.
 *
 * @export
 * @class LeafletTileSource
 * @extends {TileSource}
 */
class GoogleTileSource extends _TileSource.default {
  constructor(key, service, opts) {
    var _a;

    super(key, service, opts);
    this._layerRemovedWhileLoading = false;
    /**
     * Animation Providers
     */

    this._tileLoadCheckInterval = null; // need to listen for reset events on the animation so that we can remove any actively
    // loading Google layer while in the middle of loading

    (_a = this.animation) === null || _a === void 0 ? void 0 : _a.on('reset', () => {
      if (this._loadingSource) {
        this.trigger('layer:remove', {
          layer: this._loadingSource.overlay
        });
      }
    });
  }

  get overlay() {
    return this._overlay;
  }

  set timestamp(value) {
    if (!this.enabled || !(0, _utils.isset)(value)) return;
    value = new Date(value.getFullYear(), value.getMonth(), value.getDate(), value.getHours(), value.getMinutes()); // eslint-disable-line max-len

    if (!this._timestamp || value.getTime() !== this._timestamp.getTime()) {
      this._timestamp = value;

      if (this.isAnimating() === false && this.isAnimationFrame === false) {
        this.animation.hide();
        this.updateVisibility();
      }

      if (this.overlay && this.overlay.isHidden === false && this.canShow()) {
        this.overlay.setUrl(this.urlTemplate());
      }
    }
  }
  /**
   * Shows the layer associated with the source.
   *
   * @memberof GoogleTileSource
   */


  show() {
    if (this._hidden === false) return;
    this._hidden = false;

    if (this.overlay) {
      this.overlay.setOpacity(this._opacity);
    }
  }
  /**
   * Hides the layer associated with the source.
   *
   * @memberof GoogleTileSource
   */


  hide() {
    if (this._hidden === true) return;
    this._hidden = true;

    if (this.overlay) {
      this.overlay.setOpacity(0);
    }
  }
  /**
   * Flags the source for removal from the managing map strategy.
   *
   * @memberof GoogleTileSource
   */


  remove() {
    this.trigger('layer:remove', {
      layer: this.overlay
    });
  }
  /**
   * Changes the opacity of source's layer.
   *
   * @param {number} value
   * @memberof GoogleTileSource
   */


  setOpacity(value, update = true) {
    this._opacity = value;

    if (this.overlay && update === true && this.isVisible()) {
      this.overlay.setOpacity(value);
    }

    if (this.animation) {
      this.animation.setOpacity(value);
    }
  }
  /**
   * Changes the z-index of the source's layer.
   *
   * @param {number} value
   * @memberof GoogleTileSource
   */


  setOrder(value) {
    this.overlay.setZIndex(value); // if (this.node && this.node instanceof HTMLElement) {
    // 	this.node.style.zIndex = value.toString();
    // }
  }

  createOverlay(service, opts = {}) {
    const overlay = new _TileLayer.default(this.key, {
      opacity: (0, _utils.isset)((0, _utils.get)(opts, 'style.opacity')) ? (0, _utils.get)(opts, 'style.opacity') : 1,
      zIndex: (0, _utils.get)(opts, 'style.zIndex')
    }, this.identifier);
    overlay.on('map:add', e => {
      const {
        map
      } = e.data || {};

      if (map) {
        google.maps.event.addListener(map.overlayMapTypes, 'remove_at', (index, removed) => {
          this._layerRemovedWhileLoading = true;
        });
      }
    });
    return overlay;
  }

  animationLayerForDate(animation, date, wait = true) {
    return new Promise((resolve, reject) => {
      if (this.dataSource) {
        const source = this.dataSource.tileLayer(this.key, date, (0, _utils.extend)({}, this._opts, {
          id: `${this.identifier}-anim-${(0, _utils2.mapTimestampFromDate)(date)}`,
          data: {
            service: this.service
          },
          style: {
            opacity: 0
          }
        }));
        source.isAnimationFrame = true; // source.setOpacity(this._opacity, false);

        source.hide();

        const onLoad = () => {
          resolve(source);
          this._loadingSource = null;
        };

        this._loadingSource = source;

        if (wait) {
          // hack to handle cases where layers are removed while other layers are loading, which mutates the map.overlayMapTypes
          // array and prevents the currently loading layer from triggering its `tilesloaded` event for some reason.
          this._tileLoadCheckInterval = setTimeout(() => {
            if (this._layerRemovedWhileLoading) {
              onLoad();
            }

            this._layerRemovedWhileLoading = false;
          }, 2000);
          source.overlay.once('load', () => {
            if (this._tileLoadCheckInterval) {
              window.clearInterval(this._tileLoadCheckInterval);
            }

            this._tileLoadCheckInterval = null;
            onLoad();
          });
        } else {
          onLoad();
        } // forward source layer remove event up to the parent source


        source.on('layer:remove', () => {
          this.trigger('layer:remove', {
            layer: source.overlay
          });
        });
        this.trigger('layer:add', {
          layer: source.overlay
        });
      } else {
        reject(new Error('No map strategy data source provided'));
      }
    });
  }

}

var _default = GoogleTileSource;
exports.default = _default;
module.exports = exports.default;