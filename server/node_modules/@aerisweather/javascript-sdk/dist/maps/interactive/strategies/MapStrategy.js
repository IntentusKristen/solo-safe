"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _EventDispatcher = _interopRequireDefault(require("../../../event/EventDispatcher"));

var _sources = require("../sources");

var _utils = require("../../../utils");

var _MapElement = _interopRequireDefault(require("../MapElement"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const Dependencies = {};
/**
 * An abstract map strategy class that provides the core functionality required for a specific
 * mapping strategy. This class should be subclassed per each strategy instead of being
 * instantiated directly.
 *
 * @export
 * @class MapStrategy
 * @extends {EventDispatcher}
 */

class MapStrategy extends _EventDispatcher.default {
  constructor(target, opts) {
    super();
    this._setInitialView = true;
    this._ready = false;
    opts = (0, _utils.extend)({
      zoom: 7
    }, opts);
    this._opts = opts;
    this._sources = {};
    this._sourceOrder = []; // Dynamically inject mapping library dependencies before initializing map.
    //
    // If we have multiple instanaces of this strategy on the same page, then we want to make sure
    // we're only loading the dependencies once, otherwise we can get some weird behavior and
    // errors (like Leaflet, etc) if we load the same library more than once.

    const key = this.strategy;

    if (!Dependencies[key]) {
      Dependencies[key] = {
        loading: false,
        callbacks: []
      };
    }

    if (Dependencies[key].loading) {
      Dependencies[key].callbacks.push(() => {
        this.init(target);
      });
    } else {
      Dependencies[key].loading = true;
      this.loadDependencies().then(() => {
        Dependencies[key].loading = false;
        this.init(target);
        Dependencies[key].callbacks.forEach(fn => fn());
        Dependencies[key].callbacks = [];
        delete Dependencies[key];
      });
    }
  }

  get strategy() {
    throw new Error('[Aeris] Subclasses must override `strategy`.');
  }
  /**
   * The HTML target in which the map is rendered to.
   */


  get $el() {
    return null;
  }
  /**
   * The third-party map view instance associated with the mapping strategy.
   */


  get map() {
    return this._map;
  }
  /**
   * A factory provider that is responsible for generating the necessary map content as
   * required by the mapping strategy.
   */


  get factory() {
    return this._factory;
  }

  get sources() {
    return Object.keys(this._sources).map(k => this._sources[k]);
  }

  get opts() {
    return this._opts;
  }
  /**
   * Returns whether the map and underlying map strategy have been fully setup and initialized.
   *
   * @returns {boolean}
   * @memberof MapStrategy
   */


  isReady() {
    return this._ready;
  }

  init(target) {
    this.setupMap(target);
    const config = {};

    if ((0, _utils.isset)(this._opts.zoom)) {
      config.zoom = this._opts.zoom;
    }

    if (this._opts.center) {
      config.center = {
        lat: this._opts.center.lat,
        lon: this._opts.center.lon
      };
    }

    if (!this._factory) {
      throw new Error('Cannot initialize map, overlay factory is undefined.');
    }

    this._setupEvents();

    if (this._setInitialView) {
      const zoom = (0, _utils.isset)(config.zoom) ? Math.max(0, config.zoom) : 8;
      const {
        lat,
        lon
      } = config.center || {};

      if ((0, _utils.isset)(lat) && (0, _utils.isset)(lon)) {
        this.setView({
          lat: parseFloat(lat),
          lon: parseFloat(lon)
        }, zoom);
      } else if (zoom > 0) {
        this.setZoom(zoom);
      }
    }

    this.on('map:ready', () => {
      this._ready = true;
      this.trigger('ready');
    });
  }

  loadDependencies() {
    return null;
  }

  setupMap(target) {
    throw new Error('Subclasses of MapStrategy must override setupMap()');
  }
  /**
   * Sets the current map view using the specified center coordinate and zoom level.
   *
   * @param {Coordinate} center
   * @param {number} zoom
   * @memberof MapStrategy
   */


  setView(center, zoom) {
    throw new Error('Subclasses of MapStrategy must override setView()');
  }
  /**
   * Returns the geographical center coordinate of the map view.
   *
   * @returns {Coordinate}
   * @memberof MapStrategy
   */


  getCenter() {
    throw new Error('Subclasses of MapStrategy must override getCenter()');
  }
  /**
   * Sets the geographical center coordinate of the map view.
   *
   * @param {Coordinate} coord
   * @memberof MapStrategy
   */


  setCenter(coord) {
    throw new Error('Subclasses of MapStrategy must override setCenter()');
  }
  /**
   * Returns the current zoom level of the map view.
   *
   * @returns {number}
   * @memberof MapStrategy
   */


  getZoom() {
    throw new Error('Subclasses of MapStrategy must override getZoom()');
  }
  /**
   * Sets the zoom level of the map view.
   *
   * @param {number} zoom
   * @memberof MapStrategy
   */


  setZoom(zoom) {
    throw new Error('Subclasses of MapStrategy must override setZoom()');
  }
  /**
   * Returns the geographical bounds for the visible region of the map view.
   *
   * @returns {GeoBounds}
   * @memberof MapStrategy
   */


  getBounds() {
    throw new Error('Subclasses of MapStrategy must override getBounds()');
  }
  /**
   * Sets the geographical bounds for the visible region of the map view.
   *
   * @param {GeoBounds} bounds
   * @memberof MapStrategy
   */


  setBounds(bounds) {
    throw new Error('Subclasses of MapStrategy must override setBounds()');
  }
  /**
   * Sets the minimum visible geographical bounds for the map view so that the specified bounds
   * are contained within the visible region with an optional inset.
   *
   * @param {GeoBounds} bounds
   * @param {number[]} padding
   * @memberof MapStrategy
   */


  fitBounds(bounds, padding) {
    throw new Error('Subclasses of MapStrategy must override fitBounds()');
  }
  /** Sources */

  /**
   * Adds the specified map content source to the map.
   *
   * @param {*} source
   * @memberof MapStrategy
   */


  addSource(source) {
    const id = source.identifier;
    this._sources[id] = source;

    if (this.isTile(source)) {
      this._sourceOrder.push(id);

      source.dataSource = this;
      this.addOverlay(source.overlay);
      source.on('layer:add', e => {
        this.addOverlay(e.data.layer);
      });
      source.on('layer:remove', e => {
        this.removeOverlay(e.data.layer);
      });
    } else if (this.isVector(source)) {
      source.on('markers:add', e => {
        const {
          markers,
          animation
        } = e.data;

        if (markers) {
          this.addMarkers(markers);
        }
      });
      source.on('markers:remove', e => {
        const {
          markers
        } = e.data;

        if (markers) {
          this.removeMarkers(markers);
        }
      });
      source.on('markers:update', e => {
        (e.data.markers || []).forEach(item => {
          const {
            id: markerId,
            renderable,
            value,
            style
          } = item; // eslint-disable-line object-curly-newline

          if (value) {
            this.updateMarker(renderable, {
              data: {
                value
              },
              style: style.marker || style
            }, markerId);
          }
        });
      });
      source.on('shapes:add', e => {
        const {
          shapes,
          animation
        } = e.data;

        if (shapes) {
          if (animation) {
            this.showShapes(shapes);
          } else {
            this.addShapes(shapes);
          }
        }
      });
      source.on('shapes:remove', e => {
        const {
          shapes,
          animation
        } = e.data;

        if (shapes) {
          if (animation) {
            this.hideShapes(shapes);
          } else {
            this.removeShapes(shapes);
          }
        }
      });
    }
  }
  /**
   * Removes the specified map content source from the map.
   *
   * @param {*} source
   * @memberof MapStrategy
   */


  removeSource(source) {
    const id = source.identifier;

    if (this.isTile(source)) {
      // this.removeOverlay(source.overlay);
      source.remove();

      const index = this._sourceOrder.indexOf(id);

      if (index >= 0) {
        this._sourceOrder.splice(index, 1);
      } // (<TileSource>source).destroy();

    } else if (this.isVector(source)) {
      this.removeMarkers(source.markers);
      this.removeShapes(source.shapes);
    }

    source.strategy = null;
    delete this._sources[id];
  }
  /**
   * Returns whether the element is a tile source object.
   *
   * @param el
   * @returns {boolean}
   * @memberof MapStrategy
   */


  isTile(source) {
    return false;
  }
  /**
   * Returns whether the element is a vector source object.
   *
   * @param el
   * @returns {boolean}
   * @memberof MapStrategy
   */


  isVector(source) {
    return source instanceof _sources.VectorSource;
  }

  isText(source) {
    return source instanceof _sources.TextSource;
  }
  /**
   * Returns whether the element is a native map marker instance.
   *
   * @param el
   * @returns {boolean}
   * @memberof MapStrategy
   */


  isMarker(el) {
    return false;
  }
  /**
   * Returns whether the element is a native map polygon instance.
   *
   * @param el
   * @returns {boolean}
   * @memberof MapStrategy
   */


  isPolygon(el) {
    return false;
  }
  /**
   * Returns whether the element is a native map polyline instance.
   *
   * @param el
   * @returns {boolean}
   * @memberof MapStrategy
   */


  isPolyline(el) {
    return false;
  }
  /** Overlays */

  /**
   * Adds the specified overlay layer to the map. The overlay must be an instance of the type
   * required by the configured map strategy and underlying third-party mapping library.
   *
   * @param {*} overlay
   * @param {number} index
   * @memberof MapStrategy
   */


  addOverlay(overlay) {
    throw new Error('Subclasses of MapStrategy must override addOverlay()');
  }
  /**
   * Adds a series of overlay layers to the map. The overlays must be an instance of the type
   * required by the configured map strategy and underlying third-party mapping library.
   *
   * @param {any[]} overlays
   * @memberof MapStrategy
   */


  addOverlays(overlays) {
    (overlays || []).forEach(overlay => this.addOverlay(overlay));
  }
  /**
   * Removes the specified overlay layer from the map. The overlay must be an instance of the
   * type required by the configured map strategy and underlying third-party mapping library.
   *
   * @param {*} overlay
   * @memberof MapStrategy
   */


  removeOverlay(overlay) {
    throw new Error('Subclasses of MapStrategy must override removeOverlay()');
  }
  /**
   * Removes a series of overlay layers from the map. The overlay must be an instance of the
   * type required by the configured map strategy and underlying third-party mapping library.
   *
   * @param {any[]} overlays
   * @memberof MapStrategy
   */


  removeOverlays(overlays) {
    (overlays || []).forEach(overlay => this.removeOverlay(overlay));
  }
  /** Markers */

  /**
   * Adds the marker to the map view. The provided marker must be an instance type required by
   * the current mapping strategy.
   *
   * @param marker
   * @param data
   */


  addMarker(marker, data) {
    if (marker instanceof _MapElement.default) {
      if (marker.renderable) {
        if (marker.style && marker.style.callout) {
          const callout = marker.style.callout;
          const content = (0, _utils.isFunction)(callout) ? callout(marker.data) : callout;
          this.bindCalloutToMarker(marker.renderable, content);
        }

        this.addMarker(marker.renderable, marker.data);
      }
    } else if ((0, _utils.isPlainObject)(marker)) {
      marker.style = marker.style || {};
      const {
        renderable,
        data: markerData,
        style: {
          callout
        }
      } = marker;

      if (renderable) {
        if (callout) {
          const content = (0, _utils.isFunction)(callout) ? callout(markerData) : callout;
          this.bindCalloutToMarker(marker.renderable, content);
        }

        this.addMarker(renderable, markerData);
      }
    }
  }
  /**
   * Adds an array of markers to the map view. The provided markers must be an instance type
   * required by the current mapping strategy.
   *
   * @param markers
   */


  addMarkers(markers) {
    (markers || []).forEach(marker => this.addMarker(marker));
  }
  /**
   * Removes the marker from the map view. The provided marker must be an instance type required
   * by the current mapping strategy.
   *
   * @param marker
   */


  removeMarker(marker) {
    if (marker instanceof _MapElement.default) {
      if (marker.renderable) {
        this.removeMarker(marker.renderable);
      }
    } else if ((0, _utils.isPlainObject)(marker)) {
      const {
        renderable
      } = marker;

      if (renderable) {
        this.removeMarker(renderable);
      }
    }
  }
  /**
   * Adds an array of markers from the map view. The provided markers must be an instance type
   * required by the current mapping strategy.
   *
   * @param markers
   */


  removeMarkers(markers) {
    (markers || []).forEach(marker => this.removeMarker(marker));
  }
  /**
   * Updates an existing marker using the specified options. The provided marker must already
   * exist on the map view and must be an instance type required by the current mapping strategy.
   *
   * @param marker
   * @param options
   */


  updateMarker(marker, options, layer = null) {
    if (marker instanceof _MapElement.default) {
      if (marker.renderable) {
        this.updateMarker(marker.renderable, options, layer);
      }
    } else if ((0, _utils.isPlainObject)(marker)) {
      const {
        renderable
      } = marker;

      if (renderable) {
        this.updateMarker(renderable, options, layer);
      }
    }
  }

  bindCalloutToMarker(marker, content) {// base implementation doesn't do anything...
  }
  /** Polygons & Polylines */

  /**
   * Adds a polygon or polyline to the map view. The provided shape must be an instance type
   * required by the current mapping strategy.
   *
   * @param {*} shape
   * @param {number} index
   * @memberof MapStrategy
   */


  addShape(shape, data) {
    if ((0, _utils.isArray)(shape)) {
      this.addShapes(shape, data);
    } else if (shape instanceof _MapElement.default) {
      if (shape.renderable) {
        this.addShape(shape.renderable, shape.data || data);
      }
    } else if ((0, _utils.isPlainObject)(shape)) {
      const {
        renderable,
        polygons,
        polylines,
        data: shapeData
      } = shape;

      if (polygons) {
        this.addShapes(polygons, shapeData);
      }

      if (polylines) {
        this.addShapes(polylines, shapeData);
      }

      if (renderable) {
        this.addShape(renderable, shapeData);
      }
    }
  }
  /**
   * Adds an array of polylines and/or polygons to the map view. The provided shapes must be an
   * instance type required by the current mapping strategy.
   *
   * @param {any[]} shapes
   * @memberof MapStrategy
   */


  addShapes(shapes, data) {
    (shapes || []).forEach(shape => this.addShape(shape, data));
  }
  /**
   * Removes the polyline or polygon from the map view. The provided shape must be an instance
   * type required by the current mapping strategy.
   *
   * @param {*} shape
   * @memberof MapStrategy
   */


  removeShape(shape) {
    if ((0, _utils.isArray)(shape)) {
      this.removeShapes(shape);
    } else if (shape instanceof _MapElement.default) {
      if (shape.renderable) {
        this.removeShape(shape.renderable);
      }
    } else if ((0, _utils.isPlainObject)(shape)) {
      const {
        renderable,
        polygons,
        polylines
      } = shape;

      if (polygons) {
        this.removeShapes(polygons);
      }

      if (polylines) {
        this.removeShapes(polylines);
      }

      if (renderable) {
        this.removeShape(renderable);
      }
    }
  }
  /**
   * Removes an array of polylines and/or polygons from the map view. The provided shape must be
   * an instance type required by the current mapping strategy.
   *
   * @param {any[]} shapes
   * @memberof MapStrategy
   */


  removeShapes(shapes) {
    (shapes || []).forEach(shape => this.removeShape(shape));
  }

  showShape(shape) {
    if ((0, _utils.isArray)(shape)) {
      this.showShape(shape);
    } else if (shape instanceof _MapElement.default) {
      if (shape.renderable) {
        this.showShape(shape.renderable);
      }
    } else if ((0, _utils.isPlainObject)(shape)) {
      const {
        shape: renderable,
        polygons,
        polylines
      } = shape;

      if (polygons) {
        this.showShapes(polygons);
      }

      if (polylines) {
        this.showShapes(polylines);
      }

      if (renderable) {
        this.showShape(renderable);
      }
    }
  }

  showShapes(shapes) {
    (shapes || []).forEach(shape => this.showShape(shape));
  }

  hideShape(shape) {
    if ((0, _utils.isArray)(shape)) {
      this.hideShape(shape);
    } else if (shape instanceof _MapElement.default) {
      if (shape.renderable) {
        this.hideShape(shape.renderable);
      }
    } else if ((0, _utils.isPlainObject)(shape)) {
      const {
        shape: renderable,
        polygons,
        polylines
      } = shape;

      if (polygons) {
        this.hideShapes(polygons);
      }

      if (polylines) {
        this.hideShapes(polylines);
      }

      if (renderable) {
        this.hideShape(renderable);
      }
    }
  }

  hideShapes(shapes) {
    (shapes || []).forEach(shape => this.hideShape(shape));
  }
  /** Callout */

  /**
   * Presents a callout bubble on the map from the specified target. The target can either be an
   * `Coordinate` object or a native marker object for the mapping strategy.
   *
   * @param {*} target
   * @param {*} content
   * @param {*} opts
   * @memberof MapStrategy
   */


  showCallout(marker, content, opts) {}
  /**
   * Utilities
   */

  /**
   * Converts the specified geographical coordinate to pixel coordinates within the map view's
   * container.
   *
   * @param {Coordinate} coord
   * @returns {Point}
   * @memberof MapStrategy
   */


  coordToPoint(coord) {
    throw new Error('Subclasses of MapStrategy must override coordToPoint()');
  }
  /**
   * Converts the specified pixel coordinates within the map view's container to geographical
   * coordinates on the map.
   *
   * @param {Point} point
   * @returns {Coordinate}
   * @memberof MapStrategy
   */


  pointToCoord(point) {
    throw new Error('Subclasses of MapStrategy must override pointToCoord()');
  }

  clear() {}

  _setupEvents() {
    const mapping = this._eventMapping;

    if (mapping) {
      let method = 'on';

      if (!(0, _utils.has)(this.map, method)) {
        if ((0, _utils.has)(this.map, 'addEventListener')) {
          method = 'addEventListener';
        } else if ((0, _utils.has)(this.map, 'addListener')) {
          method = 'addListener';
        }
      }

      if ((0, _utils.has)(this.map, method)) {
        Object.keys(mapping).forEach(key => {
          this.map[method](key, e => {
            const data = this._dataForMapEvent(key, e);

            const allow = this._shouldTriggerEvent(key);

            if (allow) {
              this.trigger(mapping[key], data);
            }
          });
        });
      }
    }
  }

  _shouldTriggerEvent(name) {
    return true;
  }

  _dataForMapEvent(name, event) {
    return null;
  }
  /* Data Sources */


  tileLayer(layer, date, opts) {
    if (!this.dataSource) return null;
    let index = (0, _utils.isset)(opts.zIndex) ? opts.zIndex : 1;

    const existing = this._sourceOrder.indexOf(layer);

    if (existing >= 0) {
      index = existing + 1;
    }

    let service = (0, _utils.get)(opts, 'data.service');

    if (!service) {
      service = this.dataSource.requestForMap(layer);
    }

    service.param('format', (0, _utils.get)(opts, 'style.format') || 'png');
    const source = this.factory.tileLayer(layer, service, (0, _utils.extend)((0, _utils.cloneDeep)(opts), {
      time: date,
      zIndex: index
    }));
    return source;
  }

}

var _default = MapStrategy;
exports.default = _default;
module.exports = exports.default;