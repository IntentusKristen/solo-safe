"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _TileSource = _interopRequireDefault(require("../../../sources/TileSource"));

var _TileLayer = _interopRequireDefault(require("../layers/TileLayer"));

var _utils = require("../../../../../utils");

var _utils2 = require("../../../../utils");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * `MapboxTileSource` is a subclass of `TileSource` that creates and manages a single tile layer to
 * be used with an `MapboxMapStrategy`.
 *
 * @export
 * @class MapboxTileSource
 * @extends {TileSource}
 */
class MapboxTileSource extends _TileSource.default {
  constructor(key, service, opts) {
    super(key, service, opts);
    const anim = this.animation;
    const animOverlay = new _TileLayer.default(key, (0, _utils.extend)(opts, {
      type: 'image'
    }), `${this.identifier}-anim`);
    anim === null || anim === void 0 ? void 0 : anim.on('show', e => {
      this.show();
    });
    anim === null || anim === void 0 ? void 0 : anim.on('hide', e => {
      this.hide();
    });
    anim === null || anim === void 0 ? void 0 : anim.on('load:image advance:image', e => {
      const image = e.data.img;

      if (image) {
        animOverlay.setImage(image.src);
      }
    });
    this._animationOverlay = animOverlay;
    this.on('overlay:ready', () => {
      const opacity = (0, _utils.get)(opts, 'style.opacity');
      const relativeTo = (0, _utils.get)(opts, 'style.belowLayer');

      if (opts.id) {
        this._overlay.id = opts.id;
        this._animationOverlay.id = `${opts.id}-anim`;
      }

      if ((0, _utils.isset)(opacity)) {
        this._overlay.setOpacity(opacity);

        this._animationOverlay.setOpacity(opacity);
      }

      this._overlay.parentId = relativeTo;
      this._animationOverlay.parentId = this._overlay.layerId;
    });
  }

  get overlay() {
    return this._overlay;
  }

  set timestamp(value) {
    var _a;

    if (!this.enabled || !(0, _utils.isset)(value)) return;
    value = new Date(value.getFullYear(), value.getMonth(), value.getDate(), value.getHours(), value.getMinutes()); // eslint-disable-line max-len

    if (!this._timestamp || value.getTime() !== this._timestamp.getTime()) {
      this._timestamp = value;

      if (this.isAnimating() === false && this.isAnimationFrame === false) {
        (_a = this.animation) === null || _a === void 0 ? void 0 : _a.hide();
        this.updateVisibility();
      }

      if (this.overlay && (this.canShow() || !this.overlay.exists())) {
        this.overlay.setUrl(this.urlTemplate());
      }
    }
  }
  /**
   * Shows the layer associated with the source.
   *
   * @memberof MapboxTileSource
   */


  show() {
    var _a;

    if (this._hidden === false) return;
    this._hidden = false;

    if (((_a = this.animation) === null || _a === void 0 ? void 0 : _a.isAnimating()) && this._animationOverlay) {
      this._animationOverlay.show();
    } else if (this.overlay) {
      this.overlay.show();
    }
  }
  /**
   * Hides the layer associated with the source.
   *
   * @memberof MapboxTileSource
   */


  hide() {
    if (this._hidden === true) return;
    this._hidden = true;

    if (this.overlay) {
      this.overlay.hide();
    }

    if (this._animationOverlay) {
      this._animationOverlay.hide();
    }
  }
  /**
   * Flags the source for removal from the managing map strategy.
   *
   * @memberof MapboxTileSource
   */


  remove() {
    this.trigger('layer:remove', {
      layer: this.overlay
    });
  }
  /**
   * Changes the opacity of source's layer.
   *
   * @param {number} value
   * @memberof MapboxTileSource
   */


  setOpacity(value, update = true) {
    var _a;

    this._opacity = value;

    if (this.overlay) {
      this.overlay.setOpacity(value);
    }

    if (this._animationOverlay) {
      this._animationOverlay.setOpacity(value);
    }

    (_a = this.animation) === null || _a === void 0 ? void 0 : _a.setOpacity(value);
  }
  /**
   * Changes the z-index of the source's layer.
   *
   * @param {number} value
   * @memberof MapboxTileSource
   */


  setOrder(value) {
    if (this.overlay) {
      this.overlay.setZIndex(value);
    }

    if (this._animationOverlay) {
      this._animationOverlay.setZIndex(value);
    }
  }

  createOverlay(service, opts = {}) {
    const overlay = new _TileLayer.default(this.key, (0, _utils.extend)(opts, {
      type: 'type'
    }), this.identifier);
    return overlay;
  }
  /**
   * Animation Providers
   */


  animationLayerForDate(animation, date, wait = true) {
    return new Promise((resolve, reject) => {
      if (this.dataSource) {
        const source = this.dataSource.tileLayer(this.key, date, (0, _utils.extend)({}, this._opts, {
          id: `${this.identifier}-anim-${(0, _utils2.mapTimestampFromDate)(date)}`,
          opacity: 0,
          data: {
            service: this.service
          },
          animation: {
            enabled: false
          }
        }));
        source.isAnimationFrame = true;
        source.setOpacity(this._opacity, false);
        source.hide();

        if (wait) {
          const map = this.overlay.map;
          map.on('sourcedata', e => {
            const {
              sourceId,
              isSourceLoaded
            } = e || {};

            if (sourceId === source.overlay.sourceId && isSourceLoaded) {
              resolve(source);
            }
          });
        } else {
          resolve(source);
        }

        source.on('layer:remove', () => {
          this.trigger('layer:remove', {
            layer: source.overlay
          });
        });
        this.trigger('layer:add', {
          layer: source.overlay
        });
      } else {
        reject(new Error('No map strategy data source provided'));
      }
    });
  }

}

var _default = MapboxTileSource;
exports.default = _default;
module.exports = exports.default;