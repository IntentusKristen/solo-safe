"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _MapLayer = _interopRequireDefault(require("../../../layers/MapLayer"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * `Layer` is a container class that is responsible for creating and managing a Maplibre
 * source and associated layer representation on a Maplibre map.
 */
class MaplibreLayer extends _MapLayer.default {
  /**
   * Source identifier on the map.
   *
   * @readonly
   * @type {string}
   * @memberof Layer
   */
  get sourceId() {
    return `${this.layerId}-source`;
  }
  /**
   * The parent layer identifier for the layer, if any. When specified, this layer will be
   * rendered on the map below the layer associated with the parent identifier.
   *
   * @type {string}
   * @memberof Layer
   */


  get parentId() {
    return this._relativeTo;
  }

  set parentId(value) {
    this._relativeTo = value;
  }

  setOpacity(value) {
    super.setOpacity(value);

    if (this.exists() && !this.isHidden) {
      if (this.renderable.type === 'raster') {
        this.map.setPaintProperty(this.layerId, 'raster-opacity', value);
      } else if (this.renderable.type === 'fill') {
        this.map.setPaintProperty(this.layerId, 'fill-opacity', value);
      }
    }
  }

  setZIndex(value) {
    if (this.exists()) {
      const layers = this.map.getStyle().layers;
      let index = 0;
      layers.forEach((layer, i) => {
        if (layer.type === 'line' && /^admin-/.test(layer.id) && index === 0) {
          index = i;
        }
      });
      const target = layers.map(layer => layer.id)[index + value];
      this.map.removeLayer(this.layerId);
      this.map.addLayer(this.renderable, target);
    }
  }

  exists() {
    const map = this.map;

    if (!map) {
      return false;
    }

    return map.getLayer(this.layerId) !== undefined && map.getSource(this.sourceId) !== undefined;
  }

  invalidate() {
    throw new Error('Subclasses must override `invalidate`');
  }

  createRenderable() {
    return null;
  }

  updateVisibility(visible) {
    if (this.exists()) {
      if (this.renderable.type === 'raster') {
        this.map.setPaintProperty(this.layerId, 'raster-opacity', this.opacity);
      }

      this.map.setLayoutProperty(this.layerId, 'visibility', visible ? 'visible' : 'none');
    }
  }

  addToMap(map) {
    if (this.exists()) {
      return;
    } // determine where to position this layer, typically below map labels/symbols but above roads


    if (!this._relativeTo) {
      const layers = map.getStyle().layers;
      layers.forEach((layer, index) => {
        if (layer.type === 'line' && /^admin-/.test(layer.id) && !this._relativeTo) {
          this._relativeTo = layer.id;
        }
      });
    }

    const contains = map.getLayer(this.layerId) !== undefined;

    if (!contains) {
      if (!this.source) {
        this.invalidate();
      } else {
        map.addSource(this.sourceId, this.source);

        if (!this._relativeTo || map.getLayer(this._relativeTo) !== undefined) {
          map.addLayer(this.renderable, this._relativeTo);
        }
      }
    }

    if (this.isHidden) {
      this.hide();
    }
  }

  removeFromMap(map) {
    const contains = map.getLayer(this.layerId) !== undefined;

    if (contains) {
      map.removeLayer(this.layerId);
      map.removeSource(this.sourceId);
    }
  }

}

var _default = MaplibreLayer;
exports.default = _default;
module.exports = exports.default;