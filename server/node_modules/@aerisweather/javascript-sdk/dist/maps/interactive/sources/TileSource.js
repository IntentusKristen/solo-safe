"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _EventDispatcher = _interopRequireDefault(require("../../../event/EventDispatcher"));

var _TileDataAnimator = _interopRequireDefault(require("./TileDataAnimator"));

var _utils = require("../../../utils");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * `TileSource` is an abstract object that is responsible for managing a single tile layer on a map view and providing
 * additional functionality for the layer, such as controlling a layer's opacity and loading and running animations.
 *
 * This class is intended to be subclassed by each supported mapping strategy in order to configure the appropriate underlying
 * layer instance that is added to the strategy's map view.
 */
class TileSource extends _EventDispatcher.default {
  /**
   * Initializes a new tile source instance configured with the specified AMP layer code and tile url template string.
   *
   * @param {string} layer
   * @param {string} url
   * @param {TileSourceOptions} [opts]
   * @memberof TileSource
   */
  constructor(key, service, opts) {
    var _a;

    super();
    this.isAnimationFrame = false;
    this._hidden = false;
    this.key = key;
    this.enabled = true;
    opts = (0, _utils.extend)({
      id: undefined,
      type: 'tile',
      subdomains: ['1', '2', '3', '4'],
      time: 0,
      offset: undefined,
      opacity: 1.0,
      future: false,
      alwaysShow: false,
      animation: {
        enabled: true,
        type: 'tile'
      }
    }, opts);

    if (opts.time) {
      if (!(0, _utils.isDate)(opts.time) && (0, _utils.isNumber)(opts.time)) {
        opts.time = new Date(new Date().getTime() + opts.time);
      }
    } // disable animation if a static offset is defined


    if ((0, _utils.isset)(opts.offset)) {
      opts.animation.enabled = false;
    }

    if ((0, _utils.isset)(service)) {
      service.offset(0);
    }

    this.key = key;
    this._service = service;
    this._opts = opts;
    const style = opts.style || {};
    this._opacity = style.opacity || 1;
    const animationEnabled = ((_a = opts.animation) === null || _a === void 0 ? void 0 : _a.enabled) === true;

    if (animationEnabled) {
      const animationOpts = (0, _utils.extend)({
        key,
        type: 'tile',
        enabled: true,
        future: false,
        alwaysShow: false,
        showWhenStopped: false
      }, (0, _utils.pick)(opts, ['future', 'alwaysShow']), opts.animation);
      this._animator = new _TileDataAnimator.default(this, animationOpts);
    }

    this.on('overlay:ready', () => {
      this.timestamp = this._opts.time;
    });
    this._overlay = this.createOverlay(service, opts);
    this.trigger('overlay:ready');
  }
  /**
   * Identifier associated with the data source.
   *
   * @type {string}
   * @memberof TileSource
   */


  get identifier() {
    return this._opts.id || this.key;
  }

  set identifier(value) {
    this._opts.id = value;
  }
  /** Tile template URL */


  get url() {
    return this.service.url();
  }
  /** Underlying map layer instance that is added to a map view */


  get overlay() {
    return this._overlay;
  }
  /** Current timestamp to use when requesting tile data */


  get timestamp() {
    return this._timestamp;
  }

  set timestamp(value) {
    this._timestamp = value;
  }

  get service() {
    return this._service;
  }
  /**
   * Returns the animation associated with the static layer.
   */


  get animation() {
    var _a;

    return (_a = this._animator) === null || _a === void 0 ? void 0 : _a.animation;
  }
  /**
   * Returns the url template string to use for tile requests based on the current timestamp.
   */


  urlTemplate() {
    if ((0, _utils.isset)(this._opts.offset)) {
      this.service.offset(`${this._opts.offset}`.replace(/\s/g, ''));
    } else {
      // convert date to GMT for timestamp
      let date = new Date(this._timestamp);
      date = new Date(date.getTime() + date.getTimezoneOffset() * 60 * 1000);
      this.service.offset((0, _utils.formatDate)(date, 'yyyyMMddHHmm00'));
    }

    return this.service.url();
  }

  isFuture() {
    return this._opts.future;
  }

  updateVisibility() {
    if (this.canShow()) {
      this.show();
    } else {
      this.hide();
    }
  }

  canShow() {
    const now = new Date().getTime();

    const time = this._timestamp.getTime();

    const delta = time - now;

    if (this._opts.alwaysShow) {
      return true;
    }

    return this.isFuture() && time > now || !this.isFuture() && time <= now;
  }

  isAnimationActive() {
    return this.animation && (this.animation.canAnimate() || this.animation.isAnimating());
  }

  isAnimating() {
    return this.animation && this.animation.isAnimating();
  }
  /**
   * Shows the tile layer.
   */


  show() {
    throw new Error('Implementation must override abstract `show`');
  }
  /**
   * Hides the tile layer.
   */


  hide() {
    throw new Error('Implementation must override abstract `hide`');
  }

  remove() {
    throw new Error('Implementation must override abstract `remove`');
  }
  /**
   * Returns whether the source is currently visible.
   *
   * @returns {boolean}
   * @memberof TileSource
   */


  isVisible() {
    return this._hidden === false;
  }
  /**
   * Updates the opacity of the tile layer.
   * @param value
   */


  setOpacity(value, update = true) {
    throw new Error('Implementation must override abstract `setOpacity:`');
  }
  /**
   * Updates the z-index order of the tile layer on the parent map view.
   * @param value
   */


  setOrder(value) {
    throw new Error('Implementation must override abstract `setOrder:`');
  }

  destroy() {
    this._overlay = null;
    this._service = null;
  }

  createOverlay(service, opts = {}) {
    return null;
  }
  /** Animation Provider */


  animationLayerForDate(animation, date, wait = true) {
    // throw new Error('Implementation must override abstract `animationLayerForDate:`');
    return null;
  }

}

var _default = TileSource;
exports.default = _default;
module.exports = exports.default;