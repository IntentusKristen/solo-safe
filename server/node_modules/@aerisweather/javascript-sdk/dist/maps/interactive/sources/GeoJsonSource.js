"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _VectorSource = _interopRequireDefault(require("./VectorSource"));

var _FeatureCollection = _interopRequireDefault(require("../../geo/FeatureCollection"));

var Geo = _interopRequireWildcard(require("../../geo"));

var _utils = require("../../../utils");

var _utils2 = require("./utils");

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * `GeoJsonSource` is an object that is responsible for loading data and managing a series of
 * vector elements on a map view from GeoJSON data.
 */
class GeoJsonSource extends _VectorSource.default {
  _process(data, parentId) {
    if (!this.strategy) throw new Error('No map strategy defined for VectorSource but one is required.');
    data = data || {};
    const dataFormatter = (0, _utils.get)(this.opts, 'data.formatter');

    if (dataFormatter) {
      data = dataFormatter(data);
    }

    const markers = {};
    const polygons = {};
    const polylines = {};

    if ((0, _utils.isArray)(data)) {
      if (data[0] && data[0].type === 'FeatureCollection') {
        data = data[0];
      } else {
        data = {
          type: 'FeatureCollection',
          features: data
        };
      }
    } // make sure final data is in the format of FeatureCollection for parsing


    if (data.type === 'Feature') {
      data = {
        type: 'FeatureCollection',
        features: [data]
      };
    } else if (data.type === 'GeometryCollection') {
      data = {
        type: 'FeatureCollection',
        features: (data.geometries || []).map(geometry => ({
          type: 'Feature',
          geometry
        }))
      };
    }

    if (!(0, _utils.isset)(data.type)) {
      console.warn(`Invalid data provided for GeoJsonSource with key ${this.key}, not a valid GeoJSON format`);
      return null;
    }

    const factory = this.strategy.factory;
    const collection = new _FeatureCollection.default(data);
    const {
      marker: markerStyle,
      polygon: polygonStyle,
      polyline: polylineStyle
    } = this.style; // convert features to map elements

    const features = collection.features || [];
    features.forEach((feature, featureIndex) => {
      const geometry = feature.geometry;
      const record = feature.properties || {};
      let group;
      const idKey = (0, _utils.get)(this.opts, 'data.properties.id');
      const groupKey = (0, _utils.get)(this.opts, 'data.properties.category'); // update id based on property if defined

      if ((0, _utils.isset)(idKey)) {
        feature.id = (0, _utils.get)(record, idKey);
      } // determine group the feature belongs in if defined


      if ((0, _utils.isset)(groupKey)) {
        group = (0, _utils.get)(record, groupKey);
        const groupData = (0, _utils.set)({}, groupKey, group);

        if (!polygons[group]) {
          polygons[group] = {
            data: Object.assign(Object.assign({}, groupData), {
              awxjs_source: this.key
            }),
            elements: []
          };
        }

        if (!polylines[group]) {
          polylines[group] = {
            data: Object.assign(Object.assign({}, groupData), {
              awxjs_source: this.key
            }),
            elements: []
          };
        }
      }

      record.id = `${this.key}`;

      if (feature.id) {
        record.id = `${record.id}-${feature.id}`;
      } else {
        record.id = `${record.id}-${featureIndex}`;
      }

      if (geometry instanceof Geo.Point) {
        const style = (0, _utils.isFunction)(markerStyle) ? markerStyle(record) : markerStyle;
        const result = (0, _utils2.generateMarker)(this.key, record, geometry.coordinates, style, factory);
        markers[record.id] = result;
      } else if (geometry instanceof Geo.MultiPoint) {
        geometry.coordinates.forEach((coord, index) => {
          const markerRecord = Object.assign(Object.assign({}, record), {
            id: `${record.id}-${index}`
          });
          const style = (0, _utils.isFunction)(markerStyle) ? markerStyle(markerRecord) : markerStyle;
          const result = (0, _utils2.generateMarker)(this.key, markerRecord, coord, style, factory);
          markers[record.id] = result;
        });
      } else if (geometry instanceof Geo.LineString) {
        const result = (0, _utils2.generatePolyline)(this.key, record, geometry.coordinates, polylineStyle, factory);

        if (group) {
          polylines[group].elements.push(result);
        } else {
          polylines[record.id] = result;
        }
      } else if (geometry instanceof Geo.MultiLineString) {
        geometry.coordinates.forEach((lineCoord, index) => {
          const elementRecord = Object.assign(Object.assign({}, record), {
            id: `${record.id}-${index}`
          });
          const result = (0, _utils2.generatePolyline)(this.key, elementRecord, lineCoord, polylineStyle, factory);

          if (group) {
            polylines[group].elements.push(result);
          } else {
            polylines[record.id] = result;
          }
        });
      } else if (geometry instanceof Geo.Polygon) {
        const result = (0, _utils2.generatePolygon)(this.key, record, geometry, polygonStyle, factory);

        if (group) {
          polylines[group].elements.push(result);
        } else {
          polygons[record.id] = result;
        }
      } else if (geometry instanceof Geo.MultiPolygon) {
        // geometry.polygons.forEach((polygon, index) => {
        // 	const elementRecord = {...record, id: `${record.id}-${index}`};
        // 	const result = this._generatePolygon(elementRecord, polygon, polygonStyle);
        // 	if (group) {
        // 		polygons[group].polygons.push(result);
        // 	} else {
        // 		polygons[result.id] = result;
        // 	}
        // });
        // const elementRecord = {...record, id: `${record.id}-${index}`};
        const result = (0, _utils2.generatePolygon)(this.key, record, geometry, polygonStyle, factory);

        if (group) {
          polylines[group].elements.push(result);
        } else {
          polygons[record.id] = result;
        }
      }
    });
    return {
      markers: Object.keys(markers).map(key => markers[key]),
      polygons: Object.keys(polygons).map(key => polygons[key]),
      polylines: Object.keys(polylines).map(key => polylines[key])
    };
  }

}

var _default = GeoJsonSource;
exports.default = _default;
module.exports = exports.default;