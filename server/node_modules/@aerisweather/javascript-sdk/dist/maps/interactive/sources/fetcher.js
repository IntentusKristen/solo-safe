"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getDataFetcher = void 0;

var _ApiRequest = _interopRequireDefault(require("../../../network/api/ApiRequest"));

var _Http = _interopRequireDefault(require("../../../network/Http"));

var _utils = require("../../../utils");

var _strings = require("../../../utils/strings");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const getDataFetcher = ({
  service,
  url,
  dataKeypath,
  restrictToTimeline = true,
  onLoad = () => {},
  onError = () => {}
}) => {
  let fetcher;

  if (service) {
    fetcher = (b, from, to, params, callback) => {
      const request = (0, _utils.isFunction)(service) ? service() : service;

      if (!(0, _utils.isset)(request) || request instanceof _ApiRequest.default === false) {
        console.error('[Aeris] Invalid ApiRequest returned for data source');
        return;
      }

      const limit = (params === null || params === void 0 ? void 0 : params.limit) || request.param('limit') || 300;
      const sort = (params === null || params === void 0 ? void 0 : params.sort) || request.param('sort') || 'dt:-1'; // update request params if provided before setting primary source params

      if (params) {
        request.setParams(params);
      } // set action if not defined already on the request


      const action = request.getAction();

      if (!action) {
        request.action("within"
        /* WITHIN */
        );
      } // only set place using bounds if a `within` action


      if (request.getAction() === "within"
      /* WITHIN */
      ) {
          if (b) {
            request.place((0, _strings.toBounds)(b));
          } else {
            return;
          }
        }

      if (restrictToTimeline) {
        request.from(from).to(to).limit(limit).sort(sort);
      }

      request.get().then(result => {
        onLoad((0, _utils.get)(result.data, dataKeypath) || result.data, callback);
      }).catch(e => onError(e, callback));
    };
  } else if (url) {
    fetcher = (b, from, to, params, callback) => {
      const requestUrl = (0, _utils.isFunction)(url) ? url(params) : url;

      _Http.default.request(requestUrl).then(res => {
        onLoad((0, _utils.get)(res.data, dataKeypath) || res.data, callback);
      }).catch(e => onError(e, callback));
    };
  }

  return fetcher;
};

exports.getDataFetcher = getDataFetcher;