"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _utils = require("../../../utils");

var _TextAnimation = _interopRequireDefault(require("../../anim/TextAnimation"));

var _MapElement = require("../MapElement");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var __awaiter = void 0 && (void 0).__awaiter || function (thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function (resolve) {
      resolve(value);
    });
  }

  return new (P || (P = Promise))(function (resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }

    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }

    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }

    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};

class TextDataAnimator {
  constructor(source, opts) {
    this.source = source;
    const anim = new _TextAnimation.default();
    anim.provider = this;
    anim.on('data:add', e => source.trigger('markers:add', {
      markers: e.data.items
    }));
    anim.on('data:remove', e => source.trigger('markers:remove', {
      markers: e.data.items
    }));
    anim.on('data:update', e => source.trigger('markers:update', {
      markers: e.data.items
    }));
    this.animation = anim;
    source.on('data:load:start reset', () => {
      this._animationMarkers = null;
    });
  }
  /**
   * Requests data required for animating text values across an animation's time range. This data
   * set is usually different than that returned by `load()`.
   *
   * @returns A Promise containing the resulting marker data objects.
   */


  _loadAnimationData() {
    const source = this.source;
    return new Promise((resolve, reject) => {
      const limit = source.service.param('limit') || 300;
      const plimit = source.service.param('plimit');
      const sort = source.service.param('sort') || 'dt:-1';
      const style = source.style.marker || source.style;
      source.service.action("within"
      /* WITHIN */
      ).plimit(100).limit(limit).sort(sort).get().then(result => {
        source.service.plimit(plimit);
        const elements = {};
        const results = (0, _utils.get)(result, 'data') || [];

        if ((0, _utils.isArray)(results)) {
          // use existing marker references but use the multi-period data instead
          results.forEach(item => {
            const record = source.processRecord(item);
            const loc = record.loc || {};
            const coord = {
              lat: loc.lat,
              lon: loc.long || loc.lon
            };
            const id = record.id || `${coord.lat},${coord.long}`;
            const el = source.markersById ? source.markersById[id] : null;
            const itemStyle = (0, _utils.isFunction)(style) ? style(record) : style;

            if (el) {
              elements[id] = new _MapElement.MarkerMapElement((0, _utils.extend)({}, el.data, record), el.style, el.renderable);
            } else if ((0, _utils.isset)(itemStyle.spacing) === false) {
              const marker = source.strategy.factory.marker(source.key, {
                lat: coord.lat,
                lon: coord.lon
              }, itemStyle);
              elements[id] = new _MapElement.MarkerMapElement(Object.assign(Object.assign({}, record), {
                awxjs_source: source.key
              }), itemStyle, marker);
            }
          });
        }

        resolve(elements);
      }).catch(e => {
        console.error('Error requesting animation data for TextSource', e); // eslint-disable-line no-console

        reject(e);
      });
    });
  }
  /**
   * Animation Provider
   */


  animationData(animation) {
    return __awaiter(this, void 0, void 0, function* () {
      const source = this.source;

      const processAnimationData = () => {
        const markers = this._animationMarkers;
        const timeProp = ((0, _utils.get)(source.opts, 'data.properties.timestamp') || '').replace(/^periods\./, '');
        let valueProp = (0, _utils.get)(source.opts, 'data.properties.value');

        if (!(0, _utils.isFunction)(valueProp)) {
          valueProp = (valueProp || '').replace(/^periods\./, '');
        }

        const items = Object.keys(markers).reduce((result, id) => {
          const {
            data,
            renderable
          } = markers[id];

          if (data && data.periods) {
            let lastVal;
            const periods = data.periods.reduce((p, record) => {
              const ts = (0, _utils.get)(record, timeProp) * 1000;
              let val = '';

              if ((0, _utils.isFunction)(valueProp)) {
                val = valueProp(record);
              } else {
                val = (0, _utils.get)(record, valueProp);
              }

              if (val !== lastVal) {
                p[ts] = val;
                lastVal = val;
              }

              return p;
            }, {});
            result[id] = {
              data: periods,
              renderable,
              style: source.style
            };
            return result;
          }

          return null;
        }, {});
        return items;
      };

      const loadAnimationData = () => new Promise((resolve, reject) => {
        this._loadAnimationData().then(items => {
          this._animationMarkers = items;
          resolve(items);
        });
      });

      return new Promise((resolve, reject) => {
        if (!this._animationMarkers) {
          if (source.isLoading) {
            source.once('data:load', () => {
              loadAnimationData().then(items => {
                const result = processAnimationData();
                resolve(result);
              });
            });
          } else {
            loadAnimationData().then(items => {
              const result = processAnimationData();
              resolve(result);
            });
          }
        } else {
          const result = processAnimationData();
          resolve(result);
        }
      });
    });
  }

}

var _default = TextDataAnimator;
exports.default = _default;
module.exports = exports.default;