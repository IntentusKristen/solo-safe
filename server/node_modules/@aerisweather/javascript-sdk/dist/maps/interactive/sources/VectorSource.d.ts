import EventDispatcher from '../../../event/EventDispatcher';
import ApiRequest from '../../../network/api/ApiRequest';
import DataAnimation from '../../anim/DataAnimation';
import { MarkerMapElement, PolygonMapElement, PolylineMapElement } from '../MapElement';
import { VectorSourceOptions, AnimatableSource, VectorStyle } from '../../types';
import { PolygonGroup, PolylineGroup, VectorElementType } from '../../types/datasource.type';
import { AnyMapElement, MapElementGroup } from '../../types/interactive.type';
import { AnyMapStrategy } from '../../types/mapstrategy.type';
import { LayerDataType } from '../../types/layer.type';
/**
 * `VectorSource` is an object that is responsible for loading data and managing a series of
 * vector elements on a map view.
 */
declare class VectorSource extends EventDispatcher implements AnimatableSource<DataAnimation> {
    /**
     * Identifier associated with the data source.
     *
     * @type {string}
     * @memberof VectorSource
     */
    key: string;
    code: string;
    /**
     * Current markers being managed by the data source.
     *
     * @readonly
     * @type {*}
     * @memberof VectorSource
     */
    get markers(): Array<MarkerMapElement>;
    /**
     * Returns an object containing all active markers keyed by their unique identifiers.
     *
     * @readonly
     * @type {{ [id: string]: any }}
     * @memberof VectorSource
     */
    get markersById(): Record<string, MarkerMapElement>;
    /**
     * Current polygons being managed by the data source.
     *
     * @readonly
     * @type {*}
     * @memberof VectorSource
     */
    get polygons(): Array<PolygonMapElement | PolygonGroup>;
    /**
     * Current polygons being managed by the data source.
     *
     * @readonly
     * @type {*}
     * @memberof VectorSource
     */
    get polylines(): Array<PolylineMapElement | PolylineGroup>;
    /**
     * Current polygons and polylines being managed by the data source.
     *
     * @readonly
     * @type {ShapeDef[]}
     * @memberof VectorSource
     */
    get shapes(): Array<AnyMapElement>;
    /**
     * Style configuration provider.
     *
     * @type {VectorStyle}
     * @memberof VectorSource
     */
    style?: VectorStyle;
    /**
     * Map strategy the source is associated with.
     *
     * @type {MapStrategy}
     * @memberof VectorSource
     */
    get strategy(): AnyMapStrategy;
    set strategy(value: AnyMapStrategy);
    private _strategy;
    /**
     * Whether the data source requests data for the visible map bounds. If `true`, then data will
     * be reloaded whenever the map's visible region changes.
     *
     * Default value is `false`.
     *
     * @type {boolean}
     * @memberof VectorSource
     */
    requiresBounds: boolean;
    /**
     * API service used to request data for the data source.
     *
     * @readonly
     * @type {ApiRequest}
     * @memberof VectorSource
     */
    get service(): ApiRequest;
    /**
     * Returns the animation associated with the static layer.
     *
     * @readonly
     * @type {DataAnimation}
     * @memberof VectorSource
     */
    get animation(): DataAnimation;
    /**
     * Whether the data source is enabled.
     *
     * @type {boolean}
     * @memberof VectorSource
     */
    get enabled(): boolean;
    set enabled(value: boolean);
    get isLoading(): boolean;
    get animationEnabled(): boolean;
    readonly opts: VectorSourceOptions;
    protected _data: any;
    protected _animator: any;
    private _service;
    private _request;
    private _enabled;
    private _loading;
    protected _result: LayerDataType;
    protected _markers: Record<string, MarkerMapElement>;
    protected _polygons: Record<string, PolygonMapElement | MapElementGroup<PolygonMapElement>>;
    protected _polylines: Record<string, PolylineMapElement | MapElementGroup<PolylineMapElement>>;
    protected _opacity: number;
    protected _opacityByType: Record<VectorElementType, number>;
    private _refreshTimer;
    private _lastLoadParams;
    private _visibleBounds;
    private _lastVisibleMapObjects;
    private _animateOnLoad;
    constructor(key: string, opts?: VectorSourceOptions);
    /**
     * Returns whether the source currently has data cached from a previous request.
     *
     * @returns {boolean}
     * @memberof VectorSource
     */
    hasData(): boolean;
    setData(data: any): void;
    setOpacity(value?: number): void;
    /**
     * Requests data for the layer based on the provided geographical map bounds and date range.
     *
     * @param bounds
     * @param from
     * @param to
     * @returns A Promise containing the resulting marker data objects.
     */
    load(params: {
        [key: string]: any;
    }, animateOnLoad?: boolean, appendData?: any): Promise<LayerDataType>;
    /**
     * Reloads the data source using the last request parameters.
     *
     * @memberof VectorSource
     */
    reload(params?: any, appendData?: any): void;
    render(): void;
    /**
     * Resets the data source by removing all map elements and clearing cached data.
     *
     * @memberof VectorSource
     */
    reset(): void;
    /**
     * Reloads the data source by updating the data configuration.
     *
     * @param {*} [data]
     * @memberof VectorSource
     * @see VectorSourceOptions
     */
    update(data?: any): void;
    protected _onLoad(data: any, callback: any, appendData?: any): void;
    protected _onError(e: any, callback: any): void;
    protected _visibleMapObjects(): {
        markers: any[];
        shapes: any[];
    };
    protected _mapObjects(): any[];
    /**
     * Generates and returns map vector objects from the specified data.
     * @param data
     */
    protected _process(data: any, parentId?: string): LayerDataType;
    protected _processRecord(record: any): any;
    protected _startAutoUpdateIfNeeded(): void;
    protected _stopAutoUpdate(): void;
}
export default VectorSource;
