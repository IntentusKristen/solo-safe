"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _EventDispatcher = _interopRequireDefault(require("../../../event/EventDispatcher"));

var _CoordinateBounds = _interopRequireDefault(require("../../../geo/CoordinateBounds"));

var _MapElement = require("../MapElement");

var _Feature = _interopRequireDefault(require("../../geo/Feature"));

var _geo = require("../../geo");

var _utils = require("../../../utils");

var _utils2 = require("./utils");

var _fetcher = require("./fetcher");

var _VectorDataAnimator = _interopRequireDefault(require("./VectorDataAnimator"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const getElementStyle = (style, record = {}) => {
  const result = (0, _utils.isFunction)(style) ? style(record) : style;
  return result || {};
};

const DEFAULT_STYLE = {
  marker: {
    svg: {
      shape: {
        type: 'circle',
        fill: {
          color: '#000'
        }
      }
    },
    size: [6, 6]
  },
  polygon: {
    fill: {
      color: '#000',
      opacity: 1
    },
    stroke: {
      color: '#000',
      width: 2
    }
  },
  polyline: {
    stroke: {
      color: '#000',
      width: 2
    }
  }
};
/**
 * `VectorSource` is an object that is responsible for loading data and managing a series of
 * vector elements on a map view.
 */

class VectorSource extends _EventDispatcher.default {
  constructor(key, opts) {
    var _a;

    super();
    /**
     * Whether the data source requests data for the visible map bounds. If `true`, then data will
     * be reloaded whenever the map's visible region changes.
     *
     * Default value is `false`.
     *
     * @type {boolean}
     * @memberof VectorSource
     */

    this.requiresBounds = false;
    this._animateOnLoad = false;
    this.key = key;
    this.enabled = true;
    this.opts = (0, _utils.extend)({
      data: null,
      style: opts.style || Object.assign({}, DEFAULT_STYLE),
      requiresBounds: false,
      restrictToTimeline: true,
      animation: {
        key,
        enabled: false
      },
      refresh: 0
    }, opts);
    this._opacityByType = {
      marker: 1,
      polyline: 1,
      polygon: 1
    };
    this.style = this.opts.style;

    if (this.style) {
      const initialOpacity = (_a = this.style) === null || _a === void 0 ? void 0 : _a.opacity;

      if ((0, _utils.isset)(initialOpacity)) {
        this._opacity = initialOpacity;
      } // store the opacity for each element type based on the specified style if provided


      ['polyline', 'polygon'].forEach(type => {
        var _a, _b;

        const styleRef = getElementStyle(this.style[type]);
        const typeOpacity = ((_a = styleRef.fill) === null || _a === void 0 ? void 0 : _a.opacity) || ((_b = styleRef.stroke) === null || _b === void 0 ? void 0 : _b.opacity);

        if ((0, _utils.isset)(typeOpacity)) {
          this._opacityByType[type] = typeOpacity;
        }
      });
    }

    const animationOpts = this.opts.animation;

    if (animationOpts.enabled) {
      this._animator = new _VectorDataAnimator.default(this, animationOpts);
    }

    let service = (0, _utils.get)(this.opts, 'data.service');

    if ((0, _utils.isFunction)(service)) {
      service = service();
    }

    this._service = service;
    this.requiresBounds = (0, _utils.get)(this.opts, 'requiresBounds');
  }
  /**
   * Current markers being managed by the data source.
   *
   * @readonly
   * @type {*}
   * @memberof VectorSource
   */


  get markers() {
    var _a;

    return (_a = this._result) === null || _a === void 0 ? void 0 : _a.markers;
  }
  /**
   * Returns an object containing all active markers keyed by their unique identifiers.
   *
   * @readonly
   * @type {{ [id: string]: any }}
   * @memberof VectorSource
   */


  get markersById() {
    return this._markers;
  }
  /**
   * Current polygons being managed by the data source.
   *
   * @readonly
   * @type {*}
   * @memberof VectorSource
   */


  get polygons() {
    var _a;

    return (_a = this._result) === null || _a === void 0 ? void 0 : _a.polygons;
  }
  /**
   * Current polygons being managed by the data source.
   *
   * @readonly
   * @type {*}
   * @memberof VectorSource
   */


  get polylines() {
    var _a;

    return (_a = this._result) === null || _a === void 0 ? void 0 : _a.polylines;
  }
  /**
   * Current polygons and polylines being managed by the data source.
   *
   * @readonly
   * @type {ShapeDef[]}
   * @memberof VectorSource
   */


  get shapes() {
    var _a, _b;

    let elements = [];

    if ((_a = this.polygons) === null || _a === void 0 ? void 0 : _a.length) {
      if (this.polygons[0].elements) {
        this.polygons.forEach(group => {
          elements = elements.concat(group.elements);
        });
      } else {
        elements = elements.concat(this.polygons);
      }
    }

    if ((_b = this.polylines) === null || _b === void 0 ? void 0 : _b.length) {
      if (this.polylines[0].elements) {
        this.polylines.forEach(group => {
          elements = elements.concat(group.elements);
        });
      } else {
        elements = elements.concat(this.polylines);
      }
    }

    return elements;
  }
  /**
   * Map strategy the source is associated with.
   *
   * @type {MapStrategy}
   * @memberof VectorSource
   */


  get strategy() {
    return this._strategy;
  }

  set strategy(value) {
    if (value) {
      this._strategy = value;
      value.on('move:end', e => {
        this._visibleBounds = _CoordinateBounds.default.fromBounds(value.getBounds()); // this._updateVisibleMapObjects();
      });
    }
  }
  /**
   * API service used to request data for the data source.
   *
   * @readonly
   * @type {ApiRequest}
   * @memberof VectorSource
   */


  get service() {
    return this._service;
  }
  /**
   * Returns the animation associated with the static layer.
   *
   * @readonly
   * @type {DataAnimation}
   * @memberof VectorSource
   */


  get animation() {
    var _a;

    return (_a = this._animator) === null || _a === void 0 ? void 0 : _a.animation;
  }
  /**
   * Whether the data source is enabled.
   *
   * @type {boolean}
   * @memberof VectorSource
   */


  get enabled() {
    return this._enabled;
  }

  set enabled(value) {
    this._enabled = value;

    if (value === false) {
      this._stopAutoUpdate();
    } else {
      this._startAutoUpdateIfNeeded();
    }
  }

  get isLoading() {
    return this._loading;
  }

  get animationEnabled() {
    return (0, _utils.isset)(this.animation) && this.animation.isEnabled();
  }
  /**
   * Returns whether the source currently has data cached from a previous request.
   *
   * @returns {boolean}
   * @memberof VectorSource
   */


  hasData() {
    return !(0, _utils.isEmpty)(this.markers) || !(0, _utils.isEmpty)(this.polygons) || !(0, _utils.isEmpty)(this.polylines);
  }

  setData(data) {
    this._data = (0, _utils.isPlainObject)(data) ? (0, _utils.cloneDeep)(data) : data;
    this.render();
  }

  setOpacity(value = 1) {
    this._opacity = value; // update opacity for each shape element if enabled
    // opacity is applied to the initial style.opacity for that element

    this.shapes.filter(element => element.adjustOpacity).forEach(element => {
      if (element instanceof _MapElement.PolylineMapElement) {
        element.renderable.setOpacity(this._opacityByType.polyline * value);
      } else if (element instanceof _MapElement.PolygonMapElement) {
        element.renderable.setOpacity(this._opacityByType.polygon * value);
      }
    });
  }
  /**
   * Requests data for the layer based on the provided geographical map bounds and date range.
   *
   * @param bounds
   * @param from
   * @param to
   * @returns A Promise containing the resulting marker data objects.
   */


  load(params, animateOnLoad = false, appendData) {
    var _a;

    const dataConfig = (_a = this.opts) === null || _a === void 0 ? void 0 : _a.data;

    if (!dataConfig) {
      return new Promise((resolve, reject) => {
        reject(new Error('Invalid configuration for VectorSource'));
      });
    }

    params = (0, _utils.extend)({}, (0, _utils.get)(this.opts, 'data.request.parameters'), this._lastLoadParams, params); // save params overrides by default or if `params.save` is not `false`

    if (!(0, _utils.isset)(params.save) || params.save !== false) {
      this._lastLoadParams = params;
    }

    this._animateOnLoad = animateOnLoad;
    const {
      service,
      url,
      items
    } = dataConfig;
    const {
      bounds,
      from,
      to
    } = params;

    if (this.requiresBounds && !(0, _utils.isset)(bounds)) {
      throw new Error(`[Aeris] Vector source ${this.key} requires coordinate bounds when loading but bounds were not provided.`);
    }

    if (bounds) {
      this._visibleBounds = _CoordinateBounds.default.fromBounds(bounds);
    }

    if (items) {
      return new Promise((resolve, reject) => {
        this._onLoad(items, (result, error) => {
          if (result) {
            resolve(result);
          } else {
            reject(error);
          }
        });
      });
    }

    const fetcher = (0, _fetcher.getDataFetcher)({
      service,
      url,
      dataKeypath: (0, _utils.get)(this.opts, 'data.properties.root'),
      restrictToTimeline: this.opts.restrictToTimeline,
      onLoad: (data, callback) => {
        this._onLoad(data, callback, appendData);
      },
      onError: (err, callback) => {
        this._onError(err, callback);
      }
    });

    if (service) {
      this._service = (0, _utils.isFunction)(service) ? service() : service;
    }

    if (!(0, _utils.isset)(fetcher)) {
      throw new Error(`[Aeris] Cannot load data for VectorSource with key {${this.key}} due to an invalid configuration. Check that you have provided a valid "data.service" or "data.url" in your configuration. Refer to the docs for more info: https://www.aerisweather.com/support/docs/toolkits/aeris-js-sdk/map-modules/data-sources/`);
    }

    if (!this._request) {
      this._request = (0, _utils.debounce)((b, _from, _to, _params, callback) => {
        this._loading = true;
        fetcher(b, _from, _to, _params, callback);
      }, 1500);
    }

    return new Promise((resolve, reject) => {
      if (this._request) {
        const requestFrom = (0, _utils.get)(this.opts, 'data.request.parameters.from') || from;
        const requestTo = (0, _utils.get)(this.opts, 'data.request.parameters.to') || to;
        this._loading = true;
        this.trigger('data:load:start', {
          layer: this.key
        });

        this._request(bounds, requestFrom, requestTo, params, (results, error) => {
          this.trigger('data:load:done', {
            layer: this.key
          });

          if (error) {
            reject(error);
          } else {
            resolve(results);
          }

          this._startAutoUpdateIfNeeded();
        });
      } else {
        reject(new Error('Invalid configuration for VectorSource'));
      }
    });
  }
  /**
   * Reloads the data source using the last request parameters.
   *
   * @memberof VectorSource
   */


  reload(params, appendData) {
    this.load(params, false, appendData);
  }

  render() {
    if (!(0, _utils.isset)(this._data)) return; // trigger event so existing map objects are removed from map

    let markers = this.markers;
    let shapes = this.shapes;

    if (!(0, _utils.isEmpty)(markers)) {
      this.trigger('markers:remove', {
        markers
      });
    }

    if (!(0, _utils.isEmpty)(shapes)) {
      this.trigger('shapes:remove', {
        shapes
      });
    }

    this._result = this._process(this._data); // update map elements with current opacity value

    this.setOpacity(this._opacity); // now add new map objects

    markers = this.markers;
    shapes = this.shapes;

    if (!(0, _utils.isEmpty)(markers)) {
      this.trigger('markers:add', {
        markers
      });
    }

    if (!(0, _utils.isEmpty)(shapes)) {
      this.trigger('shapes:add', {
        shapes
      });
    }
  }
  /**
   * Resets the data source by removing all map elements and clearing cached data.
   *
   * @memberof VectorSource
   */


  reset() {
    const markers = this.markers;
    const shapes = this.shapes;

    if (!(0, _utils.isEmpty)(markers)) {
      this.trigger('markers:remove', {
        markers
      });
    }

    if (!(0, _utils.isEmpty)(shapes)) {
      this.trigger('shapes:remove', {
        shapes
      });
    }

    if (this.animation) {
      this.animation.reset();
    }

    this._loading = false;
    this._result = {};
    this.trigger('data:load:done', {
      layer: this.key
    });
    this.trigger('reset');
  }
  /**
   * Reloads the data source by updating the data configuration.
   *
   * @param {*} [data]
   * @memberof VectorSource
   * @see VectorSourceOptions
   */


  update(data) {
    if (data) {
      this.opts.data = (0, _utils.extend)(this.opts.data, data);
      this._request = null;
    }

    this.reload();
  } // protected _updateVisibleMapObjects() {
  // 	const { markers: visibleMarkers, shapes: visibleShapes } = this._lastVisibleMapObjects;
  // 	const { markers, shapes } = this._visibleMapObjects();
  // 	console.log('VECTOR', this._visibleBounds, 'VISIBLE', markers, shapes);
  // 	let markersToRemove = visibleMarkers.filter((marker) => markers.indexOf(marker) === -1);
  // 	let shapesToRemove = visibleShapes.filter((shape) => shapes.indexOf(shape) === -1);
  // 	if (!isEmpty(markersToRemove)) {
  // 		this.trigger('markers:remove', { markersToRemove });
  // 	}
  // 	if (!isEmpty(shapesToRemove)) {
  // 		this.trigger('shapes:remove', { shapesToRemove });
  // 	}
  // 	if (!isEmpty(markers)) {
  // 		this.trigger('markers:add', { markers });
  // 	}
  // 	if (!isEmpty(shapes)) {
  // 		this.trigger('shapes:add', { shapes });
  // 	}
  // 	console.log(markersToRemove, shapesToRemove);
  // 	this._lastVisibleMapObjects = { markers, shapes };
  // }


  _onLoad(data, callback, appendData) {
    if (this.enabled === false) {
      return;
    }

    if (data) {
      if (appendData) {
        if ((0, _utils.isArray)(data)) {
          data = [...appendData, ...data];
        } else if ((0, _utils.isPlainObject)(data)) {
          data = Object.assign(Object.assign({}, appendData), data);
        }
      }

      this.setData(data);
    }

    this._loading = false;
    this.trigger('data:load', {
      layer: this.key,
      results: data
    });

    if ((0, _utils.isFunction)(callback)) {
      callback(this._result, null);
    }

    if (this._animateOnLoad && this.animation) {
      this.animation.reset();
      this.animation.play();
    }

    this._animateOnLoad = false;
  }

  _onError(e, callback) {
    console.error('[Aeris] Vector source request failed', e);

    if (e.stack) {
      console.log(e.stack); // eslint-disable-line no-console
    }

    this._loading = false;
    this.trigger('data:error', {
      error: e
    });

    if (callback) {
      callback(null, e);
    }
  }

  _visibleMapObjects() {
    let markers = this.markers;
    let shapes = this.shapes;
    markers = markers.filter(marker => {
      const coord = marker.coord;

      if (coord) {
        return this._visibleBounds.contains(coord);
      }

      return true;
    });
    shapes = shapes.filter(shape => {
      const bounds = shape.bounds;

      if (bounds) {
        return this._visibleBounds.contains(bounds);
      }

      return true;
    });
    return {
      markers,
      shapes
    };
  }

  _mapObjects() {
    let existing = [];

    if (this.polygons) {
      existing = existing.concat(this.polygons);
    }

    if (this.polylines) {
      existing = existing.concat(this.polylines);
    }

    if (existing.length === 0) {
      return null;
    }

    const results = Object.keys(existing).reduce((prev, key) => prev.concat(existing.map(item => {
      if (item.polygons) {
        return item.polygons.map(p => p.polygon);
      }

      if (item.polylines) {
        return item.polylines.map(p => p.polyline);
      }

      if (item.polygon) {
        return item.polygon;
      }

      if (item.polyline) {
        return item.polyline;
      }

      return item;
    })), []);
    return (0, _utils.flatten)(results);
  }
  /**
   * Generates and returns map vector objects from the specified data.
   * @param data
   */


  _process(data, parentId) {
    if (!this.strategy) throw new Error('No map strategy defined for VectorSource but one is required.');
    data = data || {};
    const dataFormatter = (0, _utils.get)(this.opts, 'data.formatter');

    if (dataFormatter) {
      data = dataFormatter(data);
    }

    const markers = {};
    const polygons = {};
    const polylines = {};

    if ((0, _utils.isPlainObject)(data) && data.type === 'FeatureCollection') {
      console.warn(`[Aeris] Data for layer {${this.key}} is in GeoJSON format. Use GeoJsonSource (or "geojson" type) for this layer instead.`);
      return null;
    }

    if ((0, _utils.isArray)(data)) {
      const {
        marker: markerStyle,
        polygon: polygonStyle,
        polyline: polylineStyle
      } = this.style;
      const coords = [];
      const props = (0, _utils.get)(this.opts, 'data.properties') || {};
      const geomFn = (0, _utils.get)(this.opts, 'data.geometry');
      data.forEach((item, index) => {
        let id = `awxjs-shape-${this.key}-${index}`;
        let category;
        let path;
        let points;

        if (props) {
          if (props.id) {
            id = (0, _utils.get)(item, props.id);
          }

          if (props.category && /^\[path\]/.test(props.category) === false) {
            category = (0, _utils.get)(item, props.category);
          }

          if (props.path) path = (0, _utils.get)(item, props.path);

          if (markerStyle) {
            if (props.points) {
              const key = props.points;

              if (!parentId && (0, _utils.isArray)(key)) {
                points = [];
                key.forEach(k => {
                  const result = (0, _utils.get)(item, k);

                  if (result && (0, _utils.isArray)(result)) {
                    points = points.concat(result);
                  }
                });
              } else {
                points = (0, _utils.get)(item, key);
              }
            } else {
              points = [item];
            }
          }
        } // process markers


        if (points && markerStyle) {
          const coordFn = (0, _utils.get)(this.opts, 'data.coordinate');
          points.forEach(element => {
            const record = this._processRecord(element);

            const loc = record.loc || (coordFn && (0, _utils.isFunction)(coordFn) ? coordFn(record) : {});

            if (loc) {
              const coord = {
                lat: loc.lat,
                lon: loc.long || loc.lon
              };
              const style = (0, _utils.isFunction)(markerStyle) ? markerStyle(record) : markerStyle;
              record.id = record.id || `${this.key}-${id}-${coord.lat}_${coord.lon}`; // determine if we should add this marker based on the spacing configuration from the style

              let allow = true;

              if (style && style.spacing > 0) {
                const point = this.strategy.coordToPoint(coord);
                coords.forEach(c => {
                  const p = this.strategy.coordToPoint(c);
                  const dist = Math.sqrt(Math.pow(point.x - p.x, 2) + Math.pow(point.y - p.y, 2));

                  if (dist < style.spacing) {
                    allow = false;
                  }
                });
              }

              if (allow) {
                // convert record to Feature
                const feature = new _Feature.default({
                  type: 'Point',
                  coordinates: [coord.lon, coord.lat]
                });
                feature.properties = record;
                const geometry = feature.geometry;

                if (geometry instanceof _geo.Point) {
                  if ((0, _utils.isValidCoord)(geometry.coordinates)) {
                    const result = (0, _utils2.generateMarker)(this.key, feature.properties, geometry.coordinates, style, this.strategy.factory);

                    if (result) {
                      markers[record.id] = result;
                      coords.push(coord);
                    }
                  }
                }
              }
            }
          });
        } // process polygons


        if (path && (polygonStyle || polylineStyle)) {
          const reversedCoord = (0, _utils.get)(this.opts, 'data.reversedCoord') || false;
          let paths = path;

          if (!(0, _utils.isArray)(paths)) {
            paths = [paths];
          } else if (paths.length > 0 && (0, _utils.isArray)(paths[0]) && paths[0].length === 2 && (0, _utils.isNumber)(paths[0][0])) {
            // handle case where a path definition is provided as an array of
            // LatLon arrays, in which case we need to wrap it into another array
            // e.g. [[lat, lon], [lat, lon]]
            paths = [paths];
          } // if a geometry function is defined, update the path definition
          // this is used to handle cases where the actual geometry is provided on a subproperty
          // under the layer's primary `path` property key


          if (geomFn && (0, _utils.isFunction)(geomFn)) {
            paths = paths.map(element => ({
              type: 'Feature',
              properties: element,
              geometry: geomFn(element)
            }));
          }

          const features = paths.map(featurePath => {
            // convert an array of coordinates to a Polygon geometry instance
            if ((0, _utils.isArray)(featurePath) && featurePath[0].length === 2) {
              const featureCoords = reversedCoord ? path.map(p => [p[1], p[0]]) : featurePath;
              featurePath = {
                type: 'Polygon',
                coordinates: [featureCoords]
              };
            }

            const feature = new _Feature.default(featurePath);
            feature.properties = (0, _utils.extend)({}, item, feature.properties);
            return feature;
          });
          features.forEach(feature => {
            let geometry = feature.geometry;
            let groupKeyPath = props.category;
            let group = category; // if no parent category, check if the individual path definitions have the category defined

            if (!group && groupKeyPath) {
              groupKeyPath = groupKeyPath.replace(/^\[path\]\./, '');
              group = (0, _utils.get)(feature.properties, groupKeyPath);
            } // convert single geometries to arrays


            if (geometry instanceof _geo.Polygon) {
              geometry = new _geo.MultiPolygon([geometry.toArray(true)]);
            } else if (geometry instanceof _geo.LineString) {
              geometry = new _geo.MultiLineString([geometry.toArray(true)]);
            } // create map elements for each geometry


            if (geometry instanceof _geo.MultiPolygon) {
              const recordId = `${feature.properties.id || id}`;
              const record = Object.assign(Object.assign({}, feature.properties), {
                id: recordId
              });
              const element = (0, _utils2.generatePolygon)(this.key, record, geometry, polygonStyle, this.strategy.factory);

              if (group) {
                let groupStore = polygons[group];

                if (!groupStore) {
                  const groupData = (0, _utils.set)({}, groupKeyPath, group);
                  groupStore = {
                    data: Object.assign(Object.assign(Object.assign({}, groupData), record), {
                      awxjs_source: this.key
                    }),
                    elements: []
                  };
                  polygons[group] = groupStore;
                }

                groupStore.elements.push(element);
              } else if (id) {
                polygons[id] = element;
              }
            } else if (geometry instanceof _geo.MultiLineString) {
              geometry.lines.forEach((line, idx) => {
                const record = Object.assign(Object.assign({}, feature.properties), {
                  id: `${feature.properties.id || id}-${idx}`
                });
                const element = (0, _utils2.generatePolyline)(this.key, record, line.coordinates, polylineStyle, this.strategy.factory);

                if (group) {
                  let groupStore = polygons[group];

                  if (!groupStore) {
                    const groupData = (0, _utils.set)({}, groupKeyPath, group);
                    groupStore = {
                      data: Object.assign(Object.assign({}, groupData), {
                        awxjs_source: this.key
                      }),
                      elements: []
                    };
                    polylines[group] = groupStore;
                  }

                  groupStore.elements.push(element);
                } else if (id) {
                  polylines[id] = element;
                }
              });
            }
          });
        } // process polylines


        if (points && polylineStyle) {
          const segments = (0, _utils2.generateLineSegments)(points, (0, _utils.get)(this.opts, 'data.properties.category'), (0, _utils.get)(this.opts, 'data.coordinate'));
          segments.forEach(segment => {
            const result = (0, _utils2.generatePolyline)(this.key, segment.data, segment.coords, polylineStyle, this.strategy.factory);
            polylines[result.id] = result;
          });
        }
      });
    }

    this._markers = markers;
    this._polygons = polygons;
    this._polylines = polylines;
    return {
      markers: Object.keys(markers).map(key => markers[key]),
      polygons: Object.keys(polygons).map(key => polygons[key]),
      polylines: Object.keys(polylines).map(key => polylines[key])
    };
  }

  _processRecord(record) {
    return record;
  }

  _startAutoUpdateIfNeeded() {
    this._stopAutoUpdate(); // setup update timer if auto-refresh is enabled


    const refresh = (0, _utils.get)(this.opts, 'refresh');

    if (this.enabled && refresh > 0) {
      this._refreshTimer = setTimeout(() => {
        this.reload();
      }, refresh * 1000);
    }
  }

  _stopAutoUpdate() {
    if (this._refreshTimer) {
      clearTimeout(this._refreshTimer);
      this._refreshTimer = null;
    }
  }

}

var _default = VectorSource;
exports.default = _default;
module.exports = exports.default;