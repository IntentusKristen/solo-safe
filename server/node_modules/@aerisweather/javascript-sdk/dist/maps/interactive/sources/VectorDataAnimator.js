"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _utils = require("../../../utils");

var _DataAnimation = _interopRequireDefault(require("../../anim/DataAnimation"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

class VectorDataAnimator {
  constructor(source, opts) {
    this._animatableData = [];
    this._nonAnimatableData = [];
    this.source = source;

    const groupElements = elements => {
      const markers = elements.filter(item => {
        if (item.renderable) {
          return source.strategy.isMarker(item.renderable);
        }

        return source.strategy.isMarker(item);
      });
      const shapes = elements.filter(item => {
        if (item.renderable) {
          return source.strategy.isPolygon(item.renderable) || source.strategy.isPolyline(item.renderable);
        }

        return source.strategy.isPolygon(item) || source.strategy.isPolyline(item);
      });
      return {
        markers,
        shapes
      };
    };

    const anim = new _DataAnimation.default();
    anim.provider = this;
    anim.on('play', () => {
      const {
        markers,
        shapes
      } = groupElements(this._nonAnimatableData);

      if (markers.length > 0) {
        source.trigger('markers:remove', {
          markers,
          animation: anim
        });
      }

      if (shapes.length > 0) {
        source.trigger('shapes:remove', {
          shapes,
          animation: anim
        });
      }
    });
    anim.on('stop', () => {
      const {
        markers,
        shapes
      } = groupElements(this._nonAnimatableData);

      if (markers.length > 0) {
        source.trigger('markers:add', {
          markers,
          animation: anim
        });
      }

      if (shapes.length > 0) {
        source.trigger('shapes:add', {
          shapes,
          animation: anim
        });
      }
    });
    anim.on('reset', () => {
      if (source.enabled) {
        if (source.markers) {
          source.trigger('markers:add', {
            markers: source.markers,
            animation: anim
          });
        }

        if (source.shapes) {
          source.trigger('shapes:add', {
            shapes: source.shapes,
            animation: anim
          });
        }
      }

      this._animatableData = [];
      this._nonAnimatableData = [];
    });
    anim.on('data:add', e => {
      const {
        markers,
        shapes
      } = groupElements(e.data.items);

      if (markers.length > 0) {
        source.trigger('markers:add', {
          markers,
          animation: anim
        });
      }

      if (shapes.length > 0) {
        source.trigger('shapes:add', {
          shapes,
          animation: anim
        });
      }
    });
    anim.on('data:remove', e => {
      const {
        markers,
        shapes
      } = groupElements(e.data.items);

      if (markers.length > 0) {
        source.trigger('markers:remove', {
          markers,
          animation: anim
        });
      }

      if (shapes.length > 0) {
        source.trigger('shapes:remove', {
          shapes,
          animation: anim
        });
      }
    });
    this.animation = anim;
  }
  /**
   * Animation Provider
   */


  animationData(animation) {
    const source = this.source;

    const processAnimationData = () => {
      // const { markers, shapes } = this._visibleMapObjects();
      const markers = Object.keys(source.markersById).map(key => source.markersById[key]);
      const shapes = source.shapes;
      let result = [];

      if (markers) {
        const elements = markers.map(item => {
          var _a, _b;

          const {
            data,
            renderable,
            style
          } = item;

          if (!data || !renderable) {
            return null;
          }

          let timestamp;
          const tsKey = ((_b = (_a = source.opts.data) === null || _a === void 0 ? void 0 : _a.properties) === null || _b === void 0 ? void 0 : _b.timestamp) || 'timestamp';

          if ((0, _utils.has)(data, tsKey)) {
            timestamp = (0, _utils.get)(data, tsKey) * 1000;
          } else {
            this._nonAnimatableData.push(renderable);
          }

          return {
            timestamp,
            renderable,
            style,
            data
          };
        }).filter(item => item && Number.isNaN(item.timestamp) === false);

        if (elements) {
          result = result.concat(elements);
        }
      }

      if (shapes) {
        const processShapes = elements => elements.map(item => {
          var _a, _b;

          const {
            data,
            renderable,
            style
          } = item;

          if (!data) {
            return null;
          }

          const keypath = ((_b = (_a = source.opts.data) === null || _a === void 0 ? void 0 : _a.properties) === null || _b === void 0 ? void 0 : _b.timestamp) || 'timestamp';
          let timestamp;
          let tsKey;

          if (typeof keypath === 'object' && keypath.from) {
            tsKey = keypath.from;
          } else if (typeof keypath === 'string') {
            tsKey = keypath;
          }

          if ((0, _utils.has)(data, tsKey)) {
            timestamp = (0, _utils.get)(data, tsKey) * 1000;
          } else {
            this._nonAnimatableData.push(renderable);
          }

          return {
            timestamp,
            renderable,
            style,
            data
          };
        }).filter(item => item && Number.isNaN(item.timestamp) === false);

        shapes.forEach(shape => {
          const _shapes = shape.polygons;

          if ((0, _utils.isset)(_shapes)) {
            const elements = processShapes(_shapes);

            if (elements) {
              result = result.concat(elements);
            }
          } else {
            const elements = processShapes([shape]);

            if (elements) {
              result = result.concat(elements);
            }
          }
        });
      }

      this._animatableData = result;
      return result;
    };

    return new Promise((resolve, reject) => {
      if (source.isLoading) {
        source.once('data:load', () => {
          const result = processAnimationData();
          resolve(result);
        });
      } else if (this._animatableData && this._animatableData.length > 0) {
        resolve(this._animatableData);
      } else if (!source.markers) {
        resolve(null);
      } else {
        const result = processAnimationData();
        resolve(result);
      }
    });
  }

}

var _default = VectorDataAnimator;
exports.default = _default;
module.exports = exports.default;