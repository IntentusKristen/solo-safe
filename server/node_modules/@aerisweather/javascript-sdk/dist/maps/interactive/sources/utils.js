"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.generateLineSegments = exports.generatePolygon = exports.generatePolyline = exports.generateMarker = void 0;

var _utils = require("../../../utils");

var _geo = require("../../geo");

var _MapElement = require("../MapElement");

const generateMarker = (key, record, coord, style, factory) => {
  const marker = factory.marker(key, {
    lat: coord.lat,
    lon: coord.lon
  }, style); // don't create map element if returned marker instance is null

  if (!marker) {
    return null;
  }

  const data = Object.assign(Object.assign({}, record), {
    awxjs_source: key
  });
  const element = new _MapElement.MarkerMapElement(data, style, marker);
  element.geometry = new _geo.Point([coord.lon, coord.lat]);
  return element;
};

exports.generateMarker = generateMarker;

const generatePolyline = (key, record, points, style, factory) => {
  const elementStyle = (0, _utils.isFunction)(style) ? style(record) : style;
  const polyline = factory.polyline(record.id, points, elementStyle);
  const data = Object.assign(Object.assign({}, record), {
    awxjs_source: key
  });
  const element = new _MapElement.PolylineMapElement(data, elementStyle, polyline); // element.geometry = geometry;

  return element;
};

exports.generatePolyline = generatePolyline;

const generatePolygon = (key, record, geometry, style, factory) => {
  const generateDef = geometries => geometries.map((geom, index) => ({
    id: `${record.id}-${index}`,
    outer: geom.outer.coordinates,
    inner: geom.inner.map(inner => inner.coordinates)
  }));

  let shapes = [];

  if (geometry instanceof _geo.MultiPolygon) {
    shapes = generateDef(geometry.polygons);
  } else if (geometry instanceof _geo.Polygon) {
    shapes = generateDef([geometry]);
  } // const shape: PolygonDef = {
  // 	id: record.id,
  // 	outer: geometry.outer.coordinates,
  // 	inner: geometry.inner.map((inner) => inner.coordinates)
  // };


  const elementStyle = (0, _utils.isFunction)(style) ? style(record) : style;
  const polygon = factory.polygon(key, shapes, elementStyle);
  const data = Object.assign(Object.assign({}, record), {
    awxjs_source: key
  });
  const element = new _MapElement.PolygonMapElement(data, elementStyle, polygon);
  element.geometry = geometry;
  return element;
};

exports.generatePolygon = generatePolygon;

const generateLineSegments = (points, groupKeyPath, coordFn) => {
  // determines if segments in the same category should be joined into a single line
  const joinLines = false;
  const segments = [];
  let segmentBounds;
  let segmentCoords = [];
  let segmentData;
  let lastGroup;
  let lastCoord;
  points.forEach((point, index) => {
    const loc = point.loc || (coordFn && (0, _utils.isFunction)(coordFn) ? coordFn(point) : {});
    const coord = (0, _utils.isEmpty)(loc) && point.lat && point.lon ? point : {
      lat: loc.lat,
      lon: loc.long || loc.lon
    };
    const group = groupKeyPath ? point[groupKeyPath] : 'none';

    if (!(0, _utils.isset)(lastCoord) || coord.lat !== lastCoord.lat || coord.lon !== lastCoord.lon) {
      segmentCoords.push(coord);

      if (index === 0) {
        segmentBounds = {
          north: coord.lat,
          south: coord.lat,
          west: coord.lon,
          east: coord.lon
        };
      } else {
        segmentBounds.north = Math.max(segmentBounds.north, coord.lat);
        segmentBounds.south = Math.min(segmentBounds.south, coord.lat);
        segmentBounds.west = Math.min(segmentBounds.west, coord.lon);
        segmentBounds.east = Math.max(segmentBounds.east, coord.lon);
      }

      let resetSegment = true;

      if (joinLines) {
        if (index === 0) {
          segmentData = point;
          resetSegment = true;
        } else if (index === points.length - 1) {
          segments.push({
            coords: segmentCoords,
            data: point,
            bounds: segmentBounds
          });
        } else if (group !== lastGroup) {
          segments.push({
            coords: segmentCoords,
            data: segmentData,
            bounds: segmentBounds
          });
          segmentData = point;
          resetSegment = true;
        }
      } else {
        segments.push({
          coords: segmentCoords,
          data: point,
          bounds: segmentBounds
        });
        resetSegment = true;
      }

      if (resetSegment) {
        segmentCoords = [];
        segmentCoords.push(coord);
        segmentBounds = {
          north: coord.lat,
          south: coord.lat,
          west: coord.lon,
          east: coord.lon
        };
      }
    }

    lastGroup = group;
    lastCoord = coord;
  });
  return segments;
};

exports.generateLineSegments = generateLineSegments;