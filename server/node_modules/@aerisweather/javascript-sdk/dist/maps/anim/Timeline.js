"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _Animation = _interopRequireDefault(require("./Animation"));

var _TileAnimation = _interopRequireDefault(require("./TileAnimation"));

var _ImageAnimation = _interopRequireDefault(require("./ImageAnimation"));

var _utils = require("../../utils");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * A `Timeline` object is a subclass of `Animation` that manages, syncs and controls multiple
 * animations. All animations within are controlled by a single timeline, resulting in animations
 * being synced across time during playback.
 */
class Timeline extends _Animation.default {
  /**
   * Initializes a new timeline instance with the provided configuration.
   *
   * @param {TimelineOptions} [opts=null]
   * @memberof Timeline
   */
  constructor(opts = null) {
    super(opts);
    this._loading = false;
    this._animations = {};
  }
  /**
   * The animation instances being managed by this timeline.
   *
   * @type {{ [key: string]: Animation }}
   * @memberof Timeline
   */


  get animations() {
    return this._animations || {};
  }

  set animations(value) {
    this.stop();
    this._animations = value;

    this._each(anim => {
      anim.timeline = this;
    });
  }
  /**
   * Returns the timeline animation associated with the specified key, if exists.
   *
   * @param {string} key
   * @returns {Animation}
   * @memberof Timeline
   */


  get(key) {
    return this._animations[key];
  }

  opt(key, value) {
    if (value) {
      // some options we need to also update on child animations
      const commonKeys = ['intervals'];
      (0, _utils.set)(this.opts, key, value);

      if (commonKeys.indexOf(key) !== -1) {
        this._each(anim => {
          anim.opt(key, value);
        });
      }

      return this;
    }

    return (0, _utils.get)(this.opts, key);
  }
  /**
   * Adds an animation instance to the timeline for the specified key.
   *
   * @param {string} key
   * @param {Animation} animation
   * @memberof Timeline
   */


  add(key, animation) {
    this.stop();
    animation.timeline = this;
    this._animations[key] = animation;
  }
  /**
   * Removes an animation instance from the timeline.
   *
   * @param {Animation} animation
   * @memberof Timeline
   */


  remove(animation) {
    Object.keys(this._animations).forEach(key => {
      const anim = this._animations[key];

      if (anim === animation) {
        this.removeBy(key);
      }
    });
  }
  /**
   * Removes an animation instance from the timeline for the specified key.
   *
   * @param {string} key
   * @memberof Timeline
   */


  removeBy(key) {
    const anim = this._animations[key];

    if (anim) {
      this.stop();
      anim.timeline = undefined;
    }

    delete this._animations[key];
  }
  /**
   * Begins playing the animation if not currently running.
   *
   * Playback will wait for all internal animation instances to become ready, which means each
   * animation will need to load its required animation data before the timeline can begin
   * playback.
   *
   * @returns
   * @memberof Timeline
   */


  play() {
    let ready = true;
    const waiting = [];
    const loading = []; // if from and to are the same times, just go to that time and don't animate

    if (!this.canAnimate()) {
      return;
    } // can't start timeline animation if internal animations aren't ready
    // (e.g. need to load data or imagery)


    this._each(anim => {
      const showLoading = this.opt('showLoading');
      const showFutureWhileLoading = this.containsPast() === false;

      if (anim instanceof _TileAnimation.default) {
        const tileAnimation = anim;
        tileAnimation.showWhenLoading = showLoading;

        if (anim.isFuture()) {
          tileAnimation.showWhenLoading = showFutureWhileLoading || tileAnimation.alwaysShow();
        }
      } else if (anim instanceof _ImageAnimation.default) {
        const imageAnimation = anim;
        imageAnimation.showWhenLoading = showLoading;

        if (anim.isFuture()) {
          imageAnimation.showWhenLoading = showFutureWhileLoading || imageAnimation.alwaysShow();
        }
      }

      if (anim.isEnabled()) {
        if (!anim.isReady()) {
          ready = false;
          waiting.push(anim);
          loading.push(anim);
          anim.once("ready"
          /* READY */
          , () => {
            waiting.splice(waiting.indexOf(anim), 1);
            loading.splice(loading.indexOf(anim), 1);

            if (waiting.length === 0) {
              setTimeout(() => {
                this.trigger("ready"
                /* READY */
                );
                this.play();
              }, 100);
            }
          });
        } else if (anim.isLoading() || anim.needsData()) {
          loading.push(anim);
          anim.once("load:done"
          /* LOAD_DONE */
          , () => {
            loading.splice(loading.indexOf(anim), 1);

            if (loading.length === 0) {
              this._loading = false;
              this.trigger("load:done"
              /* LOAD_DONE */
              );
            }
          });
        } // calling `play` on an animation starts the data loading process but doesn't
        // actually begin playback since it's tied to an animation timeline


        anim.play();
      }
    });

    if (this._loading === false && loading.length > 0) {
      this._loading = true;
      this.trigger("load:start"
      /* LOAD_START */
      );
    } else if (this._loading && loading.length === 0) {
      this._loading = false;
      this.trigger("load:done"
      /* LOAD_DONE */
      );
    }

    if (ready) {
      // this._loading = false;
      // this.trigger(AnimationEvent.LOAD_DONE);
      this._each(anim => {
        anim.play();
      });

      super.play();
    }
  }
  /**
   * Stops playing the animation if currently running.
   *
   * Starting the animation again using `start()` after calling `stop()` will restart the
   * animation from the beginning.
   *
   * @memberof Timeline
   */


  stop() {
    this._each(anim => {
      anim.stop();
    });

    super.stop();

    if (this._loading) {
      this.trigger("load:done"
      /* LOAD_DONE */
      );
    }

    this._loading = false;
  }
  /**
   * Pauses the animation at the current position.
   *
   * To resume playback from a paused animation's current position, use `resume()`.
   *
   * @memberof Timeline
   */


  pause() {
    this._each(anim => {
      anim.pause();
    });

    super.pause();
  }
  /**
   * Restarts the animation from the beginning.
   *
   * @memberof Timeline
   */


  restart() {
    this._each(anim => {
      anim.restart();
    });

    super.restart();
  }
  /**
   * Resets the animation to its original state.
   *
   * @memberof Timeline
   */


  reset(updateTime = false) {
    this.stop();
    this._loading = false;

    this._each(anim => {
      anim.reset(updateTime);
    });

    super.reset(updateTime);
  }
  /**
   * Returns whether internal animations are currently loading data required for playback.
   *
   * @returns {boolean}
   * @memberof Timeline
   */


  isLoading() {
    return this._loading;
  }
  /**
   * Advances the animation to the specified time.
   *
   * @param {*} time
   * @returns
   * @memberof Timeline
   */


  goToTime(time) {
    this._each(anim => {
      anim.goToTime(time);
    });

    return super.goToTime(time);
  }
  /**
   * Sets the start date of the animation.
   *
   * @param {(Date | number)} date
   * @returns
   * @memberof Timeline
   */


  setStartDate(date) {
    this._each(anim => {
      anim.setStartDate(date);
    });

    return super.setStartDate(date);
  }
  /**
   * Sets the start date of the animation based on the specified offset relative to now, in
   * milliseconds.
   *
   * @param {number} offset
   * @returns
   * @memberof Timeline
   */


  setStartOffset(offset) {
    this._each(anim => {
      anim.setStartOffset(offset);
    });

    return super.setStartOffset(offset);
  }
  /**
   * Sets the end date of the animation.
   *
   * @param {(Date | number)} date
   * @returns
   * @memberof Timeline
   */


  setEndDate(date) {
    this._each(anim => {
      anim.setEndDate(date);
    });

    return super.setEndDate(date);
  }
  /**
   * Sets the end date of the animation based on the specified offset relative to now, in
   * milliseconds.
   *
   * @param {number} offset
   * @returns
   * @memberof Timeline
   */


  setEndOffset(offset) {
    this._each(anim => {
      anim.setEndOffset(offset);
    });

    return super.setEndOffset(offset);
  }
  /**
   * Updates the animation's start and end times based on the configured offsets and the current
   * time and date.
   *
   * @memberof Timeline
   */


  refresh() {
    super.refresh();

    this._each(anim => {
      anim.now = this.now;
    });
  }
  /**
   * @ignore
   * Performs a function on each internal animation instance.
   *
   * @private
   * @param {(anim: Animation) => void} fn
   * @memberof Timeline
   */


  _each(fn) {
    Object.keys(this.animations).forEach(key => {
      const anim = this._animations[key];
      fn(anim);
    });
  }
  /**
   * @ignore
   * Called when the animation time range has changed.
   *
   * @protected
   * @memberof Timeline
   */


  _onTimingChange() {
    super._onTimingChange();

    this._each(anim => {
      anim.from = this.from;
      anim.to = this.to;
    });
  }

}

var _default = Timeline;
exports.default = _default;
module.exports = exports.default;