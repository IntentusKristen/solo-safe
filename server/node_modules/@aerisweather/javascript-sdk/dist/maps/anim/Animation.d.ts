import Timeline from './Timeline';
import EventDispatcher from '../../event/EventDispatcher';
import { Animatable, AnimationOptions } from '../types/animation.interface';
/**
 * An `Animation` object provides the core functionality necessary for a single time-based animation. The animation
 * is defined by a specified start and end date.
 */
declare class Animation extends EventDispatcher implements Animatable {
    totalIntervals: number;
    protected opts: AnimationOptions;
    /**
     * The key associated with the animation, if any.
     *
     * @readonly
     * @type {string}
     * @memberof Animation
     */
    get key(): string;
    private _timeline;
    /**
     * Parent timeline managing this animation, if any.
     *
     * @type {Timeline}
     * @memberof Animation
     */
    get timeline(): Timeline;
    set timeline(value: Timeline);
    /**
     * Starting Epoch timestamp in milliseconds.
     *
     * @type {number}
     * @memberof Animation
     */
    get from(): number;
    set from(value: number);
    /**
     * Ending Epoch timestamp in milliseconds.
     *
     * @type {number}
     * @memberof Animation
     */
    get to(): number;
    set to(value: number);
    /**
     * Current time value that represents now. This value is used to determine past/future time
     * periods within the full time range.
     *
     * @type {Date}
     * @memberof Animation
     */
    get now(): Date;
    set now(value: Date);
    /**
     * Total time in seconds for the animation to complete. The animation speed will be determined
     * by the duration and total intervals, so a longer duration will result in a slower animation
     * speed for the same number of intervals.
     *
     * @type {number}
     * @memberof Animation
     */
    get duration(): number;
    set duration(value: number);
    /**
     * Delay duration in seconds to hold the last interval of the animation before restarting from
     * the beginning.
     *
     * @type {number}
     * @memberof Animation
     */
    get endDelay(): number;
    set endDelay(value: number);
    /**
     * Returns the total time, in milliseconds, of the animation based on the start and end timestamps.
     *
     * @readonly
     * @type {number}
     * @memberof Animation
     */
    get totalTime(): number;
    /**
     * Returns the current time of the animation's position in milliseconds.
     *
     * @readonly
     * @type {number}
     * @memberof Animation
     */
    get currentTime(): number;
    /**
     * Returns the current time offset from the beginning of the animation in milliseconds.
     *
     * @readonly
     * @type {number}
     * @memberof Animation
     */
    get currentOffset(): number;
    get increment(): number;
    /**
     * The animation's current position in the range of `0` to `1.0`, where `0` is the beginning
     * and `1.0` is the end.
     *
     * @type {number}
     * @memberof Animation
     */
    get position(): number;
    set position(value: number);
    private _startOffset;
    private _endOffset;
    private _now;
    private _elapsed;
    private _time;
    private _offset;
    protected _times: number[];
    protected _manualTimes: boolean;
    private _delay;
    private _increment;
    private _timer;
    private _restartTimer;
    private _paused;
    private _currentInterval;
    private _active;
    private _enabled;
    /**
     * Initializes a new animation instance with the provided configuration.
     *
     * @param {*} [opts=null]
     * @memberof Animation
     */
    constructor(opts?: AnimationOptions);
    /**
     * Sets or returns the configuration value for the specified key path.
     *
     * @param {string} key
     * @param {*} [value]
     * @returns {*}
     * @memberof Animation
     */
    opt(key: string, value?: any): any;
    /**
     * Either plays or stops the animation playback depending on the current state.
     *
     * @memberof Animation
     */
    toggle(): void;
    /**
     * Begins playing the animation if not currently running.
     *
     * @returns
     * @memberof Animation
     */
    play(): void;
    /**
     * Stops playing the animation if currently running.
     *
     * Starting the animation again using `start()` after calling `stop()` will restart the
     * animation from the beginning.
     *
     * @returns
     * @memberof Animation
     */
    stop(): void;
    /**
     * Pauses the animation at the current position.
     *
     * To resume playback from a paused animation's current position, use `resume()`.
     *
     * @memberof Animation
     */
    pause(): void;
    /**
     * Resumes playing the animation from the paused position.
     *
     * @memberof Animation
     */
    resume(): void;
    /**
     * Restarts the animation from the beginning.
     *
     * @memberof Animation
     */
    restart(): void;
    /**
     * Resets the animation to its original state.
     *
     * @memberof Animation
     */
    reset(updateTime?: boolean): void;
    /**
     * Called when an animation is first created, stopped or reset and determines the time interval
     * to display for the static position so that it's closest to the current time as possible.
     *
     * @memberof Animation
     */
    goToInit(): void;
    /**
     * Advances the animation to the specified time.
     *
     * @param {(number | Date)} time The time in milliseconds to update the animation's playhead
     * to, which must be within the `to` and `from` time range.
     * @returns {Animatable}
     * @memberof Animation
     */
    goToTime(time: number | Date): Animatable;
    /**
     * Returns an array of timestamps defining the interval steps that will be rendered during
     * playback.
     *
     * Total intervals returned will be evenly distributed across the animations time range based
     * on the value for `opts.intervals`.
     *
     * @returns {number[]}
     * @memberof Animation
     */
    neededIntervals(): number[];
    /**
     * Returns the current time interval in milliseconds.
     *
     * @returns {number}
     * @memberof Animation
     */
    currentInterval(): number;
    /**
     * Returns the current time interval as a `Date`.
     *
     * @returns {Date}
     * @memberof Animation
     */
    currentDate(): Date;
    /**
     * Returns the start date of the animation.
     *
     * @returns {Date}
     * @memberof Animation
     */
    startDate(): Date;
    /**
     * Sets the start date of the animation.
     *
     * @param {(Date|number)} date Either a `Date` instance or epoch time in milliseconds to
     * update the start time to
     * @returns
     * @memberof Animation
     */
    setStartDate(date: Date | number): this;
    /**
     * Returns the current start offset relative to now, in milliseconds.
     *
     * @returns {number}
     * @memberof Animation
     */
    startOffset(): number;
    /**
     * Sets the start date of the animation based on the specified offset relative to now, in
     * milliseconds.
     *
     * @param {number} offset
     * @returns
     * @memberof Animation
     */
    setStartOffset(offset: number): this;
    /**
     * Returns the end date of the animation.
     *
     * @returns {Date}
     * @memberof Animation
     */
    endDate(): Date;
    /**
     * Sets the end date of the animation.
     *
     * @param {(Date|number)} date Either a `Date` instance or epoch time in milliseconds to update
     * the end time to
     * @returns
     * @memberof Animation
     */
    setEndDate(date: Date | number): this;
    /**
     * Returns the current end offset relative to now, in milliseconds.
     *
     * @returns {number}
     * @memberof Animation
     */
    endOffset(): number;
    /**
     * Sets the end date of the animation based on the specified offset relative to now, in
     * milliseconds.
     *
     * @param {number} offset
     * @returns
     * @memberof Animation
     */
    setEndOffset(offset: number): this;
    setTimes(times: (Date | number)[], every?: number): void;
    /**
     * Updates the animation's start and end times based on the configured offsets and the current
     * time and date.
     *
     * @memberof Animation
     */
    refresh(): void;
    /**
     * Returns whether or not the animation can animation.
     *
     * This method will return `false` if the animation's `from` and `to` values are the same, or
     * if the animation is disabled.
     *
     * @returns {boolean}
     * @memberof Animation
     */
    canAnimate(): boolean;
    /**
     * Returns whether the animation should be visible for the specified time.
     *
     * This method will return `false` if the animation is specified as a future animation and the
     * `time` is in the past, or if the animation is not specified as a future animation and the
     * `time` is in the future.
     *
     * @param {number} [time]
     * @returns {boolean}
     * @memberof Animation
     */
    canShow(time?: number): boolean;
    /**
     * Returns whether the animation should be shown regardless of time.
     *
     * @returns {boolean}
     * @memberof Animation
     */
    alwaysShow(): boolean;
    /**
     * Sets whether the animation should be enabled.
     *
     * @param {boolean} enable
     * @memberof Animation
     */
    enabled(enable: boolean): void;
    /**
     * Returns whether the animation is currently enabled. Disabled animations would not animate
     * during playback.
     *
     * @returns {boolean}
     * @memberof Animation
     */
    isEnabled(): boolean;
    /**
     * Returns whether the animation should automatically begin playback after being created.
     *
     * @returns {boolean}
     * @memberof Animation
     */
    isAutoPlay(): boolean;
    /**
     * Returns whether the animation is ready for playback.
     *
     * Subclasses may override this value to indicate additional data or assets are required to be
     * loaded in order to begin playback.
     *
     * @returns {boolean}
     * @memberof Animation
     */
    isReady(): boolean;
    /**
     * Returns whether the animation is currently loading data or assets required for playback.
     *
     * @returns {boolean}
     * @memberof Animation
     */
    isLoading(): boolean;
    /**
     * Returns whether the animation is currently running.
     *
     * @returns {boolean}
     * @memberof Animation
     */
    isAnimating(): boolean;
    /**
     * Returns whether the animation is currently paused.
     *
     * @returns {boolean}
     * @memberof Animation
     */
    isPaused(): boolean;
    /**
     * Returns whether the animation has been specified as a future-only animation, meaning it's
     * only valid for time intervals into the future.
     *
     * @returns {boolean}
     * @memberof Animation
     */
    isFuture(): boolean;
    /**
     * Returns whether the animation's time range extends into the past.
     *
     * @returns {boolean}
     * @memberof Animation
     */
    containsPast(): boolean;
    /**
     * Returns whether the animation's time range extends into the future.
     *
     * @returns {boolean}
     * @memberof Animation
     */
    containsFuture(): boolean;
    startsAtNow(): boolean;
    endsAtNow(): boolean;
    needsData(): boolean;
    /**
     * @ignore
     * @protected
     * @memberof Animation
     */
    protected _startup(): void;
    /**
     * @ignore
     * Begins running the internal animation timer.
     *
     * @private
     * @returns
     * @memberof Animation
     */
    private _start;
    /**
     * @ignore
     * Stops and clears all running timers.
     *
     * @private
     * @memberof Animation
     */
    private _clearTimers;
    /**
     * @ignore
     * @protected
     * @memberof Animation
     */
    protected _onTimingChange(): void;
    /**
     * @ignore
     * Calculates the step increment to use on each timer interval update based on the animation
     * duration and delay.
     *
     * @private
     * @returns
     * @memberof Animation
     */
    private _updateTiming;
    protected _updateTimes(): void;
    protected _handleTimingChange(): void;
    protected _updateForTime(time: number): void;
    /**
     * Returns the closest valid animation interval to the specified time.
     *
     * @protected
     * @param {number} time
     * @returns {number}
     * @memberof Animation
     */
    protected _intervalClosestToTime(time: number): number;
    /**
     * Returns an array of step time intervals, in milliseconds, that will be used during playback.
     *
     * @protected
     * @returns {number[]}
     * @memberof Animation
     */
    protected _timesForIntervals(): number[];
}
export default Animation;
