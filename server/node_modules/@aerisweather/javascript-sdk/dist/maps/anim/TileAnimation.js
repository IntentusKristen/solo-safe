"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _Animation = _interopRequireDefault(require("./Animation"));

var _utils = require("../../utils");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * A `TileAnimation` object is a subclass of `Animation` that is responsible for loading and
 * managing a series of tile layers required for animation playback.
 */
class TileAnimation extends _Animation.default {
  /**
   * Initializes a new animation instance with the provided configuration.
   *
   * @param {TileAnimationOptions} [opts=null]
   * @memberof TileAnimation
   */
  constructor(opts = null) {
    opts = (0, _utils.extend)({}, {
      refresh: 0,
      showWhenLoading: true,
      showLoadingIntervals: false,
      bufferIntervals: -1,
      reverseLoadOrder: false,
      times: undefined
    }, opts);
    super(opts);
    this._layersByTime = null;
    this._isReset = false;
    this._loading = false;
    this._hasLoaded = false;
    this._visible = true;

    if ((0, _utils.isset)(this.opts.times)) {
      this.setTimes(this.opts.times);
    }

    this._startup();
  }

  get showWhenLoading() {
    return this.opts.showWhenLoading;
  }

  set showWhenLoading(value) {
    this.opts.showWhenLoading = value;
  }

  get bufferCount() {
    let totalBufferIntervals = this.opts.bufferIntervals;

    if (totalBufferIntervals === -1) {
      return this.totalIntervals;
    } // if animation is future and animation contains future and past, then we need to reduce the buffer intervals
    // for this animation by those required by the associated past animation


    if (this.isFuture() && this.containsPast()) {
      totalBufferIntervals = this.opts.bufferIntervals - (this.opts.intervals - this.totalIntervals);
    } // buffer count should never be greater than the times required for the animation


    return Math.max(0, Math.min(totalBufferIntervals, this.totalIntervals));
  }
  /**
   * Returns the animation data keyed by time interval.
   *
   * @returns {{ [key: number]: any }}
   * @memberof TileAnimation
   */


  dataByTime() {
    return this._layersByTime || {};
  }
  /**
   * Returns an array of cached raster data items for the animation.
   *
   * @returns {any[]}
   * @memberof TileAnimation
   */


  dataItems() {
    return Object.keys(this.dataByTime()).map(k => this._layersByTime[k]);
  }
  /**
   * Begins playing the animation if not currently running.
   *
   * If images required for playback have not been loaded, then all images will be requested
   * before playback can begin.
   *
   * @returns
   * @memberof TileAnimation
   */


  play() {
    if (this.isAnimating()) return; // // if from and to are the same times, just go to that time and don't animate
    // if (!this.canAnimate()) {
    // 	return;
    // }

    const totalIntervals = this.totalIntervals;
    const needed = this.bufferCount;

    if ((needed > 0 || this.bufferCount === 0) && (!this._hasImages() && totalIntervals > 0 || this._totalImages() < needed)) {
      this._load();

      return;
    }

    this.show();
    super.play();
  }
  /**
   * Stops playing the animation if currently running.
   *
   * Starting the animation again using `start()` after calling `stop()` will restart the
   * animation from the beginning.
   *
   * @memberof TileAnimation
   */


  stop() {
    super.stop();

    if (this._loading) {
      this.reset();
    }
  }
  /**
   * Resets the animation to its original state.
   *
   * All images that were cached during animation playback will be removed and new images will
   * have to be requested again when playback begins.
   *
   * @memberof TileAnimation
   */


  reset(updateTime = false) {
    super.reset(updateTime);
    this.hide();

    if (this._reloadTimer) {
      window.clearTimeout(this._reloadTimer);
    }

    this._isReset = true;
    this._loading = false;
    this._hasLoaded = false;
    this._layersByTime = null;
    this._currentLayer = null; // trigger removal of all layers associated with the animation

    if (this._layersByTime) {
      Object.keys(this._layersByTime).forEach(key => {
        const time = parseInt(key, 10);

        this._layersByTime[time].remove();

        delete this._layersByTime[time];
      });
    }
  }
  /**
   * Returns whether the animation is ready for playback.
   *
   * A tile animation is only ready once all images have been loaded.
   *
   * @returns {boolean}
   * @memberof TileAnimation
   */


  isReady() {
    const needed = this.bufferCount;

    const loaded = this._totalImages();

    return this.canBeginPlayback() && (this._hasImages() && loaded >= needed || needed === 0);
  }

  needsData() {
    return this._totalImages() < this.totalIntervals;
  }

  canBeginPlayback() {
    if (this.bufferCount >= 0) {
      return this._totalImages() >= this.bufferCount;
    }

    return !this.isLoading();
  }
  /**
   * Returns whether the animation can animate based on whether or not animation data has
   * loaded or is already cached.
   *
   * @returns {boolean}
   * @memberof TileAnimation
   */


  canAnimate() {
    let can = super.canAnimate();

    if (can && this._hasLoaded && this.needsData()) {
      can = false; // } else if (can && ((!this.isFuture() && !this.containsPast())) || (this.isFuture() && !this.containsFuture())) {
      // 	can = false;
    }

    return can;
  }
  /**
   * Returns whether the animation is currently loading data.
   *
   * @returns {boolean}
   * @memberof TileAnimation
   */


  isLoading() {
    return this._loading;
  }
  /**
   * Shows the animation content.
   *
   * @memberof TileAnimation
   */


  show() {
    this._visible = true;

    if (this._currentLayer) {
      this._currentLayer.show();
    }
  }
  /**
   * Hides the animation content.
   *
   * @memberof TileAnimation
   */


  hide() {
    this._visible = false;

    if (this._currentLayer) {
      this._currentLayer.hide();
    }
  }
  /**
   * Returns whether the animation element is currently visible.
   *
   * @returns {boolean}
   * @memberof TileAnimation
   */


  isVisible() {
    if (this._currentLayer) {
      return this._currentLayer.isVisible();
    }

    return true;
  }
  /**
   * Updates the opacity for all raster-related data associated with the animation.
   *
   * @param {number} value
   * @memberof ImageAnimation
   */


  setOpacity(value) {
    this.dataItems().forEach(item => {
      if ((0, _utils.has)(item, 'setOpacity')) {
        item.setOpacity(value, true);
      }
    });
  }
  /**
   * @ignore
   * Updates the animation by showing the appropriate tile layer for the specifyed time.
   *
   * @protected
   * @param {number} time
   * @memberof TileAnimation
   */


  _updateForTime(time) {
    if (this.canShow(this.currentTime)) {
      this.show();
    } else {
      this.hide();
    } // if (this.isAnimating() === false) return;


    if (this._visible === false) return;

    const layer = this._frameClosestToTime(time);

    if (layer && layer !== this._currentLayer) {
      layer.show();

      if (this._currentLayer) {
        this._currentLayer.hide();
      }

      this._currentLayer = layer;
    } // if (this.canShow(this.currentTime)) {
    // 	this.show();
    // } else {
    // 	this.hide();
    // }

  }
  /**
   * @ignore
   * Returns the tile layer closest to the specified time.
   *
   * @private
   * @param {number} time
   * @returns {ITileLayer}
   * @memberof TileAnimation
   */


  _frameClosestToTime(time) {
    if (Object.keys(this.dataByTime()).length === 0) {
      return null;
    }

    const times = Object.keys(this._layersByTime).sort().reverse().map(o => parseInt(o, 10)); // eslint-disable-line max-len

    let image = null;
    let closest = times[times.length - 1];
    let diff = Math.abs(time - closest);
    times.forEach(t => {
      const checkDiff = Math.abs(time - t);

      if (checkDiff < diff) {
        diff = checkDiff;
        closest = t;
      }
    });

    if (closest !== this._lastImageTime && this._layersByTime[closest]) {
      image = this._layersByTime[closest];
      closest = Math.round(closest);
      this._lastImageTime = closest;
      this.trigger("advance:image"
      /* ADVANCE_IMAGE */
      , {
        time: closest,
        layer: image
      });
    }

    return image;
  }
  /**
   * @ignore
   * Returns whether animation layers are available.
   *
   * @private
   * @returns {boolean}
   * @memberof TileAnimation
   */


  _hasImages() {
    return this._totalImages() > 0;
  }
  /**
   * @ignore
   * Returns the total number of animation layers.
   *
   * @private
   * @returns {number}
   * @memberof TileAnimation
   */


  _totalImages() {
    return Object.keys(this.dataByTime()).length;
  }
  /**
   * @ignore
   * Loads all tile layers based on the required time intervals.
   *
   * @private
   * @returns
   * @memberof TileAnimation
   */


  _load() {
    if (this._loading) {
      return;
    }

    let times = this.neededIntervals();

    if (!times || times.length === 0) {
      this._hasLoaded = true;
      this.trigger("load:done"
      /* LOAD_DONE */
      );
      this.trigger("ready"
      /* READY */
      );
      return;
    }

    this._isReset = false;
    this._loading = true;
    const bufferCount = this.bufferCount;

    if (this._layersByTime) {
      // reduce times by interval images we may already have cached
      Object.keys(this._layersByTime).forEach(key => {
        const time = parseInt(key, 10);
        const index = times.indexOf(time);

        if (index !== -1) {
          times.splice(index, 1);
        }
      });
    }

    const onLoadComplete = () => {
      this._loading = false;
      this._hasLoaded = true;
      this.trigger("load:done"
      /* LOAD_DONE */
      );

      if (bufferCount === -1 || bufferCount >= times.length) {
        this.trigger("ready"
        /* READY */
        );
      }

      if (!this.timeline) {
        this.play();
      }
    };

    if (times.length === 0) {
      onLoadComplete();
      return;
    } // if bufferCount is less than total times, then reverse times array so that
    // the most recent intervals are loaded and rendered first


    if (bufferCount >= 0 && this.opts.reverseLoadOrder === true) {
      times = times.reverse();
    }

    this.trigger("load:start"
    /* LOAD_START */
    , {
      times
    });

    const loadTimes = timesToLoad => {
      const wait = this.opts.showLoadingIntervals === false && bufferCount !== 0;
      timesToLoad.forEach(time => {
        this._loadInterval(time, true, wait, () => {
          if (this._totalImages() === times.length) {
            onLoadComplete();
          }
        });
      });
    };

    let loadingInterval = 0;

    const loadNextInterval = () => {
      const wait = this.opts.showLoadingIntervals === false || bufferCount !== 0 && loadingInterval <= this._totalImages();

      this._loadInterval(times[loadingInterval], true, wait, () => {
        loadingInterval += 1; // don't continue loading remaining intervals if animation was reset during load process

        if (!this._isReset) {
          if (loadingInterval >= times.length) {
            onLoadComplete(); // start refresh timer if needed

            if (this.opts.refresh > 0) {
              if (this._reloadTimer) {
                window.clearTimeout(this._reloadTimer);
              }

              this._reloadTimer = setTimeout(() => {
                this.reset();

                this._load();
              }, this.opts.refresh * 1000);
            }
          } else if (bufferCount > 0 && this._totalImages() === bufferCount) {
            this.trigger("ready"
            /* READY */
            );

            if (this.opts.showLoadingIntervals) {
              loadTimes(times.slice(loadingInterval));
            } else {
              loadNextInterval();
            }
          } else {
            loadNextInterval();
          }
        }
      });
    };

    if (bufferCount === 0) {
      this.trigger("ready"
      /* READY */
      );
      loadTimes(times);
    } else {
      loadNextInterval();
    }
  }
  /**
   * @ignore
   * Loads a single tile layer for the specified time.
   *
   * @private
   * @param {number} time
   * @param {boolean} cache
   * @param {() => void} callback
   * @returns
   * @memberof TileAnimation
   */


  _loadInterval(time, cache, wait, callback = null) {
    time = Math.round(time);

    if (!this._layersByTime) {
      this._layersByTime = {};
    } else if (this._layersByTime[time]) {
      // skip the request if we already have a cached image for this interval
      if (callback) {
        callback();
      }

      return;
    }

    const date = new Date(time);

    if (this.provider) {
      this.provider.animationLayerForDate(this, date, wait).then(layer => {
        // if animation was reset while loading the interval, then immediately remove it
        if (this._isReset) {
          layer.remove();
          return;
        }

        if (this.showWhenLoading && this._totalImages() < this.bufferCount) {
          if (this._currentLayer) {
            this._currentLayer.hide();
          }

          layer.show();
          this._currentLayer = layer;
        }

        this._layersByTime[time] = layer;
        this.trigger("load:image"
        /* LOAD_IMAGE */
        , {
          date: new Date(time),
          layer
        });
        this.trigger("load:progress"
        /* LOAD_PROGRESS */
        , {
          time,
          loaded: Object.keys(this._layersByTime).length,
          total: this.totalIntervals
        });

        if (callback) {
          callback();
        }
      }).catch(e => {
        console.error('Failed to load tile animation interval', e); // eslint-disable-line no-console
      });
    }
  }

}

var _default = TileAnimation;
exports.default = _default;
module.exports = exports.default;