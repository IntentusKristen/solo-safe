"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _Animation = _interopRequireDefault(require("./Animation"));

var _DOM = _interopRequireDefault(require("../../display/DOM"));

var _utils = require("../../utils");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * A `ImageAnimation` object is a subclass of `Animation` that is responsible for managing a
 * series of images required for animation playback.
 */
class ImageAnimation extends _Animation.default {
  /**
   * Initializes a new animation instance with the provided DOM target and configuration.
   *
   * @param {HTMLElement} target
   * @param {ImageAnimationOptions} [opts=null]
   * @memberof ImageAnimation
   */
  constructor(target, opts = undefined) {
    opts = (0, _utils.extend)({}, {
      refresh: 0,
      showWhenStopped: true,
      showWhenLoading: true
    }, opts);
    super(opts);
    this.element = target ? (0, _DOM.default)(target) : undefined;
    this._images = {};
    this._targets = {};
    this._idPrefix = 'awxb-map-layer-';
    this._isReset = false;
    this._loading = false;
    this._visible = true;
    this._hasLoaded = false;

    if (!(0, _utils.isEmpty)(opts.key)) {
      this._idPrefix += `${opts.key}-`;
    } // setup containers


    if (this.element) {
      this.element.addClass('amp-map');
    }

    this._startup();
  }

  get showWhenLoading() {
    return this.opts.showWhenLoading;
  }

  set showWhenLoading(value) {
    this.opts.showWhenLoading = value;
  }
  /**
   * Returns the animation data keyed by time interval.
   *
   * @returns {{ [key: number]: any }}
   * @memberof ImageAnimation
   */


  dataByTime() {
    return this._images;
  }
  /**
   * Returns an array of cached raster data items for the animation.
   *
   * @returns {any[]}
   * @memberof TileAnimation
   */


  dataItems() {
    return Object.keys(this.dataByTime()).map(k => this._images[k]);
  }
  /**
   * Begins playing the animation if not currently running.
   *
   * If images required for playback have not been loaded, then all images will be requested
   * before playback can begin.
   *
   * @returns
   * @memberof ImageAnimation
   */


  play() {
    if (this.isAnimating()) return; // if from and to are the same times, just go to that time and don't animate

    if (!this.canAnimate()) {
      return;
    }

    if (!this._hasImages() || this._totalImages() < this.totalIntervals) {
      this._load();

      return;
    } // this.show();


    super.play();
  }
  /**
   * Stops playing the animation if currently running.
   *
   * Starting the animation again using `start()` after calling `stop()` will restart the
   * animation from the beginning.
   *
   * @memberof ImageAnimation
   */


  stop() {
    super.stop();

    if (this._loading) {
      this.reset();
    }
  }
  /**
   * Resets the animation to its original state.
   *
   * @memberof ImageAnimation
   */


  reset(updateTime = false) {
    this._isReset = true;
    this._loading = false;
    this._hasLoaded = false;

    if (this._reloadTimer) {
      window.clearTimeout(this._reloadTimer);
    }

    if (this._loaders) {
      Object.keys(this._loaders).forEach(key => {
        this._loaders[key].onload = undefined;
      });
    }

    this._images = {};
    this._loaders = {};

    if (this.element) {
      this.element.empty();
    }

    super.reset(updateTime);
  } // goToTime(time: any) {
  // 	super.goToTime(time);
  // 	// // show or hide animation container depending on current interval and if it's future or not
  // 	// if (!this.canShow(time)) {
  // 	// 	this.hide();
  // 	// } else if (this._hasImages()) {
  // 	// 	this.show();
  // 	// }
  // 	return this;
  // }

  /**
   * Returns whether the animation is ready for playback.
   *
   * An image animation is only ready once all images have been loaded.
   *
   * @returns {boolean}
   * @memberof ImageAnimation
   */


  isReady() {
    const needed = this.totalIntervals;

    const loaded = this._totalImages();

    return !this.isLoading() && (this._hasImages() && loaded === needed || needed === 0);
  }
  /**
   * Returns whether the animation can animate based on whether or not animation data has
   * loaded or is already cached.
   *
   * @returns {boolean}
   * @memberof ImageAnimation
   */


  canAnimate() {
    let can = super.canAnimate();

    if (can && this._hasLoaded && !this._hasImages()) {
      can = false;
    } else if (can && !this.isFuture() && !this.containsPast() || this.isFuture() && !this.containsFuture()) {
      can = false;
    }

    return can;
  }
  /**
   * Returns whether the animation is currently loading data.
   *
   * @returns {boolean}
   * @memberof ImageAnimation
   */


  isLoading() {
    return this._loading;
  }
  /**
   * Shows the animation content.
   *
   * @memberof ImageAnimation
   */


  show() {
    this._visible = true;

    if (this.element) {
      this.element.show();
    } else if (this._currentImage) {
      (0, _DOM.default)(this._currentImage).show();
    }

    this.trigger('show');
  }
  /**
   * Hides the animation content.
   *
   * @memberof ImageAnimation
   */


  hide() {
    this._visible = false;

    if (this.element) {
      this.element.hide();
    } else if (this._currentImage) {
      (0, _DOM.default)(this._currentImage).hide();
    }

    this.trigger('hide');
  }
  /**
   * Returns whether the animation container is currently visible.
   *
   * @returns {boolean}
   * @memberof ImageAnimation
   */


  isVisible() {
    if (this.element) {
      let element = this.element;

      if ((0, _utils.isDOM)(this.element) && this.element.length > 0) {
        element = this.element[0];
      }

      return element.style.display !== 'none';
    }

    if (this._currentImage) {
      return this._currentImage.style.display !== 'none';
    }

    return true;
  }
  /**
   * Updates the opacity for all raster-related data associated with the animation.
   *
   * @param {number} value
   * @memberof ImageAnimation
   */


  setOpacity(value) {
    this.dataItems().forEach(item => {
      if ((0, _utils.has)(item, 'setOpacity')) {
        item.setOpacity(value);
      }
    });
  }

  _target(key) {
    return this._targets[key];
  }
  /**
   * @ignore
   * Sets the visibility of currently active image.
   *
   * @private
   * @param {boolean} visible
   * @memberof ImageAnimation
   */


  _setImageVisible(visible) {
    if (visible) {
      (0, _DOM.default)(this._currentImage).show();
    } else {
      (0, _DOM.default)(this._currentImage).hide();
    }
  }
  /**
   * @ignore
   * Updates the animation by showing the appropriate image for the specifyed time.
   *
   * @protected
   * @param {number} time
   * @memberof ImageAnimation
   */


  _updateForTime(time) {
    if (this.canShow(this.currentTime)) {
      this.show();
    } else {
      this.hide();
    } // if (this.isAnimating() === false) return;


    if (this._visible === false) return;

    const image = this._imageClosestToTime(time);

    if (image) {
      if (image !== this._currentImage) {
        (0, _DOM.default)(image).show();

        this._setImageVisible(false);

        this._currentImage = image;
      }
    } else if (!this.isAnimating() && this.opt('showWhenStopped') === true) {
      time = this._intervalClosestToTime(time);

      if (this.canShow(time)) {
        this._isReset = false;

        this._loadInterval(time, true, null);
      }
    } // if (this.canShow(this.currentTime)) {
    // 	this.show();
    // } else {
    // 	this.hide();
    // }

  }
  /**
   * @ignore
   * Returns the image closest to the specified time.
   *
   * @private
   * @param {number} time
   * @returns {*}
   * @memberof ImageAnimation
   */


  _imageClosestToTime(time) {
    let image = null;
    let closest = this.from;
    let diff = Math.abs(time - closest);

    if (!this._images) {
      return null;
    }

    Object.keys(this._images).forEach(imageTime => {
      const imageDiff = Math.abs(time - +imageTime);

      if (imageDiff < diff) {
        diff = imageDiff;
        closest = +imageTime;
      }
    });

    if (closest !== this._lastImageTime && this._images[closest]) {
      image = this._images[closest];
      closest = Math.round(closest);
      this._lastImageTime = closest;
      this.trigger("advance:image"
      /* ADVANCE_IMAGE */
      , {
        time: closest,
        img: image
      });
    }

    return image;
  }
  /**
   * @ignore
   * Returns whether animation images are available.
   *
   * @private
   * @returns {boolean}
   * @memberof ImageAnimation
   */


  _hasImages() {
    return this._totalImages() > 0;
  }
  /**
   * @ignore
   * Returns the total number of animation images.
   *
   * @private
   * @returns {number}
   * @memberof ImageAnimation
   */


  _totalImages() {
    if ((0, _utils.isUndefined)(this._images)) return 0;
    return Object.keys(this._images).filter(time => (0, _utils.isset)(this._images[time])).length;
  }
  /**
   * @ignore
   * Loads all images based on the required time intervals.
   *
   * @private
   * @returns
   * @memberof ImageAnimation
   */


  _load() {
    this._isReset = false;
    this._loading = true;
    const times = this.neededIntervals() || []; // reduce times by interval images we may already have cached

    Object.keys(this._images).forEach(key => {
      const time = parseInt(key, 10);
      const index = times.indexOf(time);

      if (index !== -1) {
        times.splice(index, 1);
      }
    });

    const onLoadComplete = () => {
      this._loading = false;
      this._hasLoaded = true;
      this.trigger("load:done"
      /* LOAD_DONE */
      );
      this.trigger("ready"
      /* READY */
      );

      if (!this.timeline) {
        this.play();
      }
    };

    if (times.length === 0) {
      onLoadComplete();
      return;
    } // set size of animation container


    if (this.element && this.opts.autosize === true && this.provider) {
      const size = this.provider.animationSizeForImage(this);
      this.element.css({
        width: `${size.width}px`,
        height: `${size.height}px`
      });
    } // if (this.canShow(this.currentTime)) {
    // 	this.show();
    // }


    this.trigger("load:start"
    /* LOAD_START */
    , {
      times
    });
    let loadingInterval = 0;

    const loadNextInterval = () => {
      this._loadInterval(times[loadingInterval], true, () => {
        loadingInterval += 1; // don't continue loading remaining intervals if animation was reset during load process

        if (!this._isReset) {
          if (loadingInterval >= times.length) {
            onLoadComplete(); // start refresh timer if needed

            if (this.opts.refresh > 0) {
              if (this._reloadTimer) {
                window.clearTimeout(this._reloadTimer);
              }

              this._reloadTimer = setTimeout(() => {
                this.reset();

                this._load();
              }, this.opts.refresh * 1000);
            }
          } else {
            loadNextInterval();
          }
        }
      });
    };

    loadNextInterval();
  }
  /**
   * @ignore
   * Loads a single image for the specified time.
   *
   * @private
   * @param {number} time
   * @param {boolean} cache
   * @param {() => void} callback
   * @returns
   * @memberof ImageAnimation
   */


  _loadInterval(time, cache, callback) {
    time = Math.round(time); // don't reload interval if it already exists in the DOM

    const el = document.getElementById(`${this._idPrefix}${time}`);

    if (el) {
      const $el = (0, _DOM.default)(el);
      $el.show();

      this._setImageVisible(false);

      this._currentImage = $el;

      this._setImageVisible(true);

      if (callback) {
        callback();
      }

      return;
    }

    if (!this._images) {
      this._images = {};
    }

    if (!this._loaders) {
      this._loaders = {};
    } // skip the request if we already have a cached image for this interval


    if (this._images[time]) {
      if (callback) {
        callback();
      }

      return;
    } // don't load if we already have a loader running for this interval


    if (this._loaders[time]) {
      return;
    }

    const date = new Date(time);
    let url;

    if (this.provider) {
      url = this.provider.animationUrlForDate(this, date);
    }

    const onFailure = failedTime => {
      this._images[failedTime] = new Image();
      this.trigger("load:error"
      /* LOAD_ERROR */
      , {
        date,
        interval: Object.keys(this._images).length - 1
      });

      if (callback) {
        callback();
      }
    };

    if (!url) {
      onFailure(time);
      return;
    }

    const image = new Image();
    this._loaders[time] = image;

    image.onload = () => {
      if (this._isReset) return;

      if (this._loaders[time]) {
        delete this._loaders[time];
      }

      const id = `${this._idPrefix}${time}`;
      let size = {
        width: image.width,
        height: image.height
      };

      if (this.provider) {
        size = this.provider.animationSizeForImage(this);
      }

      const img = `<img id="${id}" src="${image.src}" width="${size.width}" height="${size.height}" style="position:absolute;">`;

      if (this.element) {
        this.element.append(img);
      }

      if (cache) {
        this._images[time] = this._hasDOMTarget() ? (0, _DOM.default)(`#${id}`) : image;
      }

      this._setImageVisible(false);

      this._currentImage = this._hasDOMTarget() ? (0, _DOM.default)(`#${id}`) : image;

      if (callback) {
        callback();
      }

      const loadedCount = Object.keys(this._images).length;
      this.trigger("load:image"
      /* LOAD_IMAGE */
      , {
        date: new Date(time),
        src: image.src,
        img: image
      });
      this.trigger("load:progress"
      /* LOAD_PROGRESS */
      , {
        time,
        interval: loadedCount - 1,
        loaded: loadedCount,
        total: this.totalIntervals
      }); // if (callback) {
      // 	callback();
      // }
    };

    image.onerror = () => {
      onFailure(time);
    };

    image.src = url;
  }
  /**
   * @ignore
   * Returns whether a DOM target for the animation has been defined.
   *
   * @private
   * @returns
   * @memberof ImageAnimation
   */


  _hasDOMTarget() {
    return this.element && this.element.length > 0;
  }

}

var _default = ImageAnimation;
exports.default = _default;
module.exports = exports.default;