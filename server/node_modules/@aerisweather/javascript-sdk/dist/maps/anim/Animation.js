"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _EventDispatcher = _interopRequireDefault(require("../../event/EventDispatcher"));

var _utils = require("../../utils");

var _strings = require("../../utils/strings");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * An `Animation` object provides the core functionality necessary for a single time-based animation. The animation
 * is defined by a specified start and end date.
 */
class Animation extends _EventDispatcher.default {
  /**
   * Initializes a new animation instance with the provided configuration.
   *
   * @param {*} [opts=null]
   * @memberof Animation
   */
  constructor(opts = null) {
    super();
    this._startOffset = 0;
    this._endOffset = 0;
    this._elapsed = 0;
    this._time = 0;
    this._offset = 0;
    this._manualTimes = false;
    this._delay = 1 / 60;
    this._increment = 0;
    this._timer = null;
    this._restartTimer = null;
    this._paused = false;
    this._currentInterval = 0;
    this._active = false;
    this._enabled = true;
    opts = (0, _utils.extend)({}, {
      key: undefined,
      enabled: true,
      from: 0,
      to: 0,
      duration: 2,
      endDelay: 1,
      intervals: 10,
      autoplay: false,
      future: false,
      alwaysShow: false
    }, opts);
    this._now = new Date();

    const time = this._now.getTime(); // const offsetForDate = (date: Date, relativeTo: Date): number => date.getTime() - relativeTo.getTime();
    // convert strings to numbers as needed


    Object.keys(opts).forEach(key => {
      let val = opts[key]; // convert time string offsets to numerical second offsets

      if ((key === 'from' || key === 'to') && (0, _utils.isString)(val)) {
        const replacements = {
          year: ['y', 'yr'],
          month: ['mn', 'mth'],
          week: ['w', 'wk'],
          day: ['d'],
          hour: ['h', 'hr'],
          minute: ['m', 'min'],
          second: ['s', 'sec']
        };
        val = val.replace(/\s/g, '');
        Object.keys(replacements).forEach(name => {
          const abbr = replacements[name];

          if ((0, _utils.isArray)(abbr)) {
            abbr.forEach(v => {
              const regex = new RegExp(`^([\\d\\.-]+)${v}$`);
              val = val.replace(regex, `\$1${name}`);
            });
          }
        });

        if (/(year|month|week|day|hour|minute|second)/.test(val)) {
          val = (0, _utils.toTimeOffsetHours)(val) * 3600;
        }
      }

      if ((0, _utils.isNumeric)(val)) {
        val = parseFloat(val);
      } // // if from or to are < 3600, then assume an hour value was provided and convert to seconds
      // if ((key === 'from' || key === 'to') && Math.abs(val) < 3600) {
      // 	val *= 3600;
      // }


      opts[key] = val;
    }); // convert from/to date strings to Date objects

    if ((0, _utils.isString)(opts.from)) {
      opts.from = (0, _strings.toDate)(`${opts.from}`);
    }

    if ((0, _utils.isString)(opts.to)) {
      opts.to = (0, _strings.toDate)(`${opts.to}`);
    }

    this.opts = opts;

    if ((0, _utils.isDate)(opts.from)) {
      const date = opts.from;
      this._startOffset = date.getTime() - time;
      this.from = date.getTime();
    } else {
      this._startOffset = parseFloat(`${opts.from}`) * 1000;
      this.from = time + this._startOffset;
    }

    if ((0, _utils.isDate)(opts.to)) {
      const date = opts.to;
      this._endOffset = date.getTime() - time;
      this.to = date.getTime();
    } else {
      this._endOffset = parseFloat(`${opts.to}`) * 1000;
      this.to = time + this._endOffset;
    }

    this._enabled = opts.enabled;
    this.duration = opts.duration || 2;
    this.endDelay = opts.endDelay || 1;
    this.totalIntervals = opts.intervals || 10;
    this._time = this.from;
    this._times = [];

    this._startup();
  }
  /**
   * The key associated with the animation, if any.
   *
   * @readonly
   * @type {string}
   * @memberof Animation
   */


  get key() {
    return this.opts.key;
  }
  /**
   * Parent timeline managing this animation, if any.
   *
   * @type {Timeline}
   * @memberof Animation
   */


  get timeline() {
    return this._timeline;
  }

  set timeline(value) {
    this._timeline = value;

    if (value) {
      this.now = value.now;
      this.from = value.from;
      this.to = value.to; // update config options to match parent timeline

      ['duration', 'endDelay'].forEach(key => {
        this.opt(key, value.opt(key));
      });
      this.goToTime(value.currentTime);
    }
  }
  /**
   * Starting Epoch timestamp in milliseconds.
   *
   * @type {number}
   * @memberof Animation
   */


  get from() {
    return parseFloat(`${this.opts.from}`);
  }

  set from(value) {
    this.stop();
    this.opts.from = value;
    this._startOffset = value - this._now.getTime();

    this._onTimingChange();

    this.trigger("start:change"
    /* START_CHANGE */
    , {
      from: this.startDate(),
      to: this.endDate()
    });
  }
  /**
   * Ending Epoch timestamp in milliseconds.
   *
   * @type {number}
   * @memberof Animation
   */


  get to() {
    return parseFloat(`${this.opts.to}`);
  }

  set to(value) {
    this.stop();
    this.opts.to = value;
    this._endOffset = value - this._now.getTime();

    this._onTimingChange();

    this.trigger("end:change"
    /* END_CHANGE */
    , {
      from: this.startDate(),
      to: this.endDate()
    });
  }
  /**
   * Current time value that represents now. This value is used to determine past/future time
   * periods within the full time range.
   *
   * @type {Date}
   * @memberof Animation
   */


  get now() {
    return this._now;
  }

  set now(value) {
    this._now = value;
  }
  /**
   * Total time in seconds for the animation to complete. The animation speed will be determined
   * by the duration and total intervals, so a longer duration will result in a slower animation
   * speed for the same number of intervals.
   *
   * @type {number}
   * @memberof Animation
   */


  get duration() {
    return this.opts.duration;
  }

  set duration(value) {
    if (value !== this.opts.duration) {
      this.opts.duration = value;

      this._updateTiming();
    }
  }
  /**
   * Delay duration in seconds to hold the last interval of the animation before restarting from
   * the beginning.
   *
   * @type {number}
   * @memberof Animation
   */


  get endDelay() {
    return this.opts.endDelay;
  }

  set endDelay(value) {
    this.opts.endDelay = value;
  }
  /**
   * Returns the total time, in milliseconds, of the animation based on the start and end timestamps.
   *
   * @readonly
   * @type {number}
   * @memberof Animation
   */


  get totalTime() {
    return this.to - this.from;
  }
  /**
   * Returns the current time of the animation's position in milliseconds.
   *
   * @readonly
   * @type {number}
   * @memberof Animation
   */


  get currentTime() {
    return this._time;
  }
  /**
   * Returns the current time offset from the beginning of the animation in milliseconds.
   *
   * @readonly
   * @type {number}
   * @memberof Animation
   */


  get currentOffset() {
    return this._offset;
  }

  get increment() {
    return this._increment;
  }
  /**
   * The animation's current position in the range of `0` to `1.0`, where `0` is the beginning
   * and `1.0` is the end.
   *
   * @type {number}
   * @memberof Animation
   */


  get position() {
    return this._offset / this.totalTime;
  }

  set position(value) {
    this.goToTime(this.from + (this.to - this.from) * value);
  }
  /**
   * Sets or returns the configuration value for the specified key path.
   *
   * @param {string} key
   * @param {*} [value]
   * @returns {*}
   * @memberof Animation
   */


  opt(key, value) {
    if (value) {
      (0, _utils.set)(this.opts, key, value);

      if (key === 'intervals') {
        this.reset();
        this.totalIntervals = value;

        this._updateTimes();
      }

      return this;
    }

    return (0, _utils.get)(this.opts, key);
  }
  /**
   * Either plays or stops the animation playback depending on the current state.
   *
   * @memberof Animation
   */


  toggle() {
    if (this.isAnimating() || this.isLoading()) {
      this.stop();
    } else {
      this.play();
    }
  }
  /**
   * Begins playing the animation if not currently running.
   *
   * @returns
   * @memberof Animation
   */


  play() {
    if (this.isAnimating()) {
      return;
    } // if not resuming from paused state, start from beginning of the timeline


    if (!this._paused) {
      this.goToTime(this.from);
    } // if from and to are the same times, just go to that time and don't animate


    if (!this.canAnimate()) {
      return;
    }

    this._paused = false;
    this._active = true;

    this._updateTiming();

    this.trigger("play"
    /* PLAY */
    , {
      from: this.startDate(),
      to: this.endDate()
    });

    this._start();
  }
  /**
   * Stops playing the animation if currently running.
   *
   * Starting the animation again using `start()` after calling `stop()` will restart the
   * animation from the beginning.
   *
   * @returns
   * @memberof Animation
   */


  stop() {
    this._clearTimers();

    if (!this.isAnimating() && !this.isLoading()) {
      return;
    }

    this._paused = false;
    this._active = false;
    this.trigger("stop"
    /* STOP */
    );
    this.goToInit();
  }
  /**
   * Pauses the animation at the current position.
   *
   * To resume playback from a paused animation's current position, use `resume()`.
   *
   * @memberof Animation
   */


  pause() {
    this._clearTimers();

    this._paused = true;
    this.trigger("pause"
    /* PAUSE */
    );
  }
  /**
   * Resumes playing the animation from the paused position.
   *
   * @memberof Animation
   */


  resume() {
    if (this.isAnimating() && this._paused) {
      this._start();
    }

    this._paused = false;
    this.trigger("resume"
    /* RESUME */
    );
  }
  /**
   * Restarts the animation from the beginning.
   *
   * @memberof Animation
   */


  restart() {
    this._clearTimers();

    this._restartTimer = setTimeout(() => {
      this.goToTime(this.from);

      this._start();
    }, this.endDelay * 1000);
  }
  /**
   * Resets the animation to its original state.
   *
   * @memberof Animation
   */


  reset(updateTime = false) {
    if (this.isAnimating()) {
      this.stop();
    } else if (updateTime) {
      this.goToInit();
    }

    this.trigger("reset"
    /* RESET */
    );
  }
  /**
   * Called when an animation is first created, stopped or reset and determines the time interval
   * to display for the static position so that it's closest to the current time as possible.
   *
   * @memberof Animation
   */


  goToInit() {
    const now = this._now.getTime();

    let time = now;

    if (time > this.to) {
      time = this.to;
    } else if (time < this.from) {
      time = this.from;
    }

    if (this.from >= now) {
      time = this.from;
    } else if (this.to <= now) {
      time = this.to;
    }

    if (time > 0) {
      this.goToTime(time);
    }
  }
  /**
   * Advances the animation to the specified time.
   *
   * @param {(number | Date)} time The time in milliseconds to update the animation's playhead
   * to, which must be within the `to` and `from` time range.
   * @returns {Animatable}
   * @memberof Animation
   */


  goToTime(time) {
    let _time;

    if ((0, _utils.isDate)(time)) {
      _time = time.getTime();
    } else {
      _time = time;
    }

    this._offset = _time - this.from;

    const closest = this._intervalClosestToTime(_time);

    this._currentInterval = closest;
    this._time = _time;

    this._updateForTime(closest);

    console.log({
      time: this._time,
      offset: this._offset,
      position: this.position
    });
    this.trigger("advance"
    /* ADVANCE */
    , {
      time: this._time,
      offset: this._offset,
      position: this.position
    });
    return this;
  }
  /**
   * Returns an array of timestamps defining the interval steps that will be rendered during
   * playback.
   *
   * Total intervals returned will be evenly distributed across the animations time range based
   * on the value for `opts.intervals`.
   *
   * @returns {number[]}
   * @memberof Animation
   */


  neededIntervals() {
    return this._times.slice(0);
  }
  /**
   * Returns the current time interval in milliseconds.
   *
   * @returns {number}
   * @memberof Animation
   */


  currentInterval() {
    return this._currentInterval;
  }
  /**
   * Returns the current time interval as a `Date`.
   *
   * @returns {Date}
   * @memberof Animation
   */


  currentDate() {
    return new Date(this.currentTime);
  }
  /**
   * Returns the start date of the animation.
   *
   * @returns {Date}
   * @memberof Animation
   */


  startDate() {
    return new Date(this.from);
  }
  /**
   * Sets the start date of the animation.
   *
   * @param {(Date|number)} date Either a `Date` instance or epoch time in milliseconds to
   * update the start time to
   * @returns
   * @memberof Animation
   */


  setStartDate(date) {
    const time = (0, _utils.isDate)(date) ? date.getTime() : date;

    if (time > this.to) {
      console.error(`[Aeris] Animation start date cannot be set to a date after the current
				end date value. You may need to change the end date first.`);
      return this;
    }

    this.from = time; // const now = new Date().getTime();
    // if (this.from > now) {
    // 	this.goToTime(now);
    // } else if (this.currentTime < this.from) {
    // 	this.goToTime(this.from);
    // }

    return this;
  }
  /**
   * Returns the current start offset relative to now, in milliseconds.
   *
   * @returns {number}
   * @memberof Animation
   */


  startOffset() {
    return this._startOffset;
  }
  /**
   * Sets the start date of the animation based on the specified offset relative to now, in
   * milliseconds.
   *
   * @param {number} offset
   * @returns
   * @memberof Animation
   */


  setStartOffset(offset) {
    const time = this._now.getTime() + offset;

    if (time > this.to) {
      console.error(`[Aeris] Animation start offset cannot be set to a time offset after the
				current end date value. You may need to change the end date or time offset first.`);
      return this;
    }

    this.from = time;
    return this;
  }
  /**
   * Returns the end date of the animation.
   *
   * @returns {Date}
   * @memberof Animation
   */


  endDate() {
    return new Date(this.to);
  }
  /**
   * Sets the end date of the animation.
   *
   * @param {(Date|number)} date Either a `Date` instance or epoch time in milliseconds to update
   * the end time to
   * @returns
   * @memberof Animation
   */


  setEndDate(date) {
    const time = (0, _utils.isDate)(date) ? date.getTime() : date;

    if (time < this.from) {
      console.error(`[Aeris] Animation end date cannot be set to a date before the current
				start date value. You may need to change the start date first.`);
      return this;
    }

    this.to = time;

    const now = this._now.getTime();

    if (this.to > now) {
      this.goToTime(now);
    } else if (this.currentTime > this.to) {
      this.goToTime(this.to);
    }

    return this;
  }
  /**
   * Returns the current end offset relative to now, in milliseconds.
   *
   * @returns {number}
   * @memberof Animation
   */


  endOffset() {
    return this._endOffset;
  }
  /**
   * Sets the end date of the animation based on the specified offset relative to now, in
   * milliseconds.
   *
   * @param {number} offset
   * @returns
   * @memberof Animation
   */


  setEndOffset(offset) {
    const time = this._now.getTime() + offset;

    if (time < this.from) {
      console.error(`[Aeris] Animation end offset cannot be set to a time offset before the
				current start date value. You may need to change the start date or time offset first.`);
      return this;
    }

    this.to = time;
    return this;
  }

  setTimes(times, every = 1) {
    this.reset();

    if ((0, _utils.isset)(times)) {
      this._manualTimes = true;
      this._times = times.map(t => {
        if ((0, _utils.isset)(t.time)) {
          t = t.time;
        }

        if (t instanceof Date) {
          return t.getTime();
        }

        if ((0, _utils.isNumber)(t)) {
          return t;
        }

        return Number.NaN;
      }).filter((t, idx) => (0, _utils.isNumeric)(t) && idx % every === 0);
    } else {
      this._manualTimes = false;

      this._updateTimes();
    }
  }
  /**
   * Updates the animation's start and end times based on the configured offsets and the current
   * time and date.
   *
   * @memberof Animation
   */


  refresh() {
    this._now = new Date();
    this.from = this._now.getTime() + this._startOffset;
    this.to = this._now.getTime() + this._endOffset;
  }
  /**
   * Returns whether or not the animation can animation.
   *
   * This method will return `false` if the animation's `from` and `to` values are the same, or
   * if the animation is disabled.
   *
   * @returns {boolean}
   * @memberof Animation
   */


  canAnimate() {
    return this.to !== this.from && this.isEnabled();
  }
  /**
   * Returns whether the animation should be visible for the specified time.
   *
   * This method will return `false` if the animation is specified as a future animation and the
   * `time` is in the past, or if the animation is not specified as a future animation and the
   * `time` is in the future.
   *
   * @param {number} [time]
   * @returns {boolean}
   * @memberof Animation
   */


  canShow(time) {
    if (this.alwaysShow() === true) {
      return true;
    }

    if (!time) {
      time = this._time;
    }

    const now = this._now.getTime();

    const delta = time - now;

    if (this.isFuture()) {
      if (this.containsPast() === false || this.startsAtNow()) {
        return time >= now;
      }

      return time > now;
    } // if start time is the same as now, then don't show past animations


    if (this.startsAtNow() && this.containsFuture()) {
      return delta < 0;
    }

    return time <= now;
  }
  /**
   * Returns whether the animation should be shown regardless of time.
   *
   * @returns {boolean}
   * @memberof Animation
   */


  alwaysShow() {
    return this.opts.alwaysShow;
  }
  /**
   * Sets whether the animation should be enabled.
   *
   * @param {boolean} enable
   * @memberof Animation
   */


  enabled(enable) {
    this._enabled = enable;
  }
  /**
   * Returns whether the animation is currently enabled. Disabled animations would not animate
   * during playback.
   *
   * @returns {boolean}
   * @memberof Animation
   */


  isEnabled() {
    return this._enabled;
  }
  /**
   * Returns whether the animation should automatically begin playback after being created.
   *
   * @returns {boolean}
   * @memberof Animation
   */


  isAutoPlay() {
    return this.opts.autoplay;
  }
  /**
   * Returns whether the animation is ready for playback.
   *
   * Subclasses may override this value to indicate additional data or assets are required to be
   * loaded in order to begin playback.
   *
   * @returns {boolean}
   * @memberof Animation
   */


  isReady() {
    return true;
  }
  /**
   * Returns whether the animation is currently loading data or assets required for playback.
   *
   * @returns {boolean}
   * @memberof Animation
   */


  isLoading() {
    return false;
  }
  /**
   * Returns whether the animation is currently running.
   *
   * @returns {boolean}
   * @memberof Animation
   */


  isAnimating() {
    return this._active;
  }
  /**
   * Returns whether the animation is currently paused.
   *
   * @returns {boolean}
   * @memberof Animation
   */


  isPaused() {
    return this._paused;
  }
  /**
   * Returns whether the animation has been specified as a future-only animation, meaning it's
   * only valid for time intervals into the future.
   *
   * @returns {boolean}
   * @memberof Animation
   */


  isFuture() {
    return this.opts.future === true;
  }
  /**
   * Returns whether the animation's time range extends into the past.
   *
   * @returns {boolean}
   * @memberof Animation
   */


  containsPast() {
    return this.startDate().getTime() < this._now.getTime();
  }
  /**
   * Returns whether the animation's time range extends into the future.
   *
   * @returns {boolean}
   * @memberof Animation
   */


  containsFuture() {
    return this.endDate().getTime() > this._now.getTime();
  }

  startsAtNow() {
    const delta = Math.abs(this.startDate().getTime() - this.now.getTime());
    return delta <= 30000;
  }

  endsAtNow() {
    const delta = Math.abs(this.endDate().getTime() - this.now.getTime());
    return delta <= 30000;
  }

  needsData() {
    return false;
  }
  /**
   * @ignore
   * @protected
   * @memberof Animation
   */


  _startup() {
    this._updateTimes();

    if (this.opts.autoplay) {// this.play();
    } else {
      // determine the time interval to display initially before animation begins
      this.goToInit();
    }
  }
  /**
   * @ignore
   * Begins running the internal animation timer.
   *
   * @private
   * @returns
   * @memberof Animation
   */


  _start() {
    if (this.timeline) return;
    this._active = true;
    this._timer = setInterval(() => {
      const next = this._time + this._increment;

      if (next > this.to) {
        this.restart();
      } else {
        this.goToTime(next);
      }
    }, this._delay * 1000);
  }
  /**
   * @ignore
   * Stops and clears all running timers.
   *
   * @private
   * @memberof Animation
   */


  _clearTimers() {
    if (this._timer) {
      window.clearInterval(this._timer);
    }

    if (this._restartTimer) {
      window.clearTimeout(this._restartTimer);
    }

    this._timer = undefined;
    this._restartTimer = undefined;
  }
  /**
   * @ignore
   * @protected
   * @memberof Animation
   */


  _onTimingChange() {
    this._updateTiming();

    this._updateTimes();

    this._handleTimingChange();

    if (this.currentTime < this.from) {
      this.goToTime(this.from);
    } else if (this.currentTime > this.to) {
      this.goToTime(this.to);
    }
  }
  /**
   * @ignore
   * Calculates the step increment to use on each timer interval update based on the animation
   * duration and delay.
   *
   * @private
   * @returns
   * @memberof Animation
   */


  _updateTiming() {
    if (this.to < this.from) return;
    this._increment = (this.to - this.from) / this.duration * this._delay;
  }

  _updateTimes() {
    if (!this._manualTimes) {
      this._times = this._timesForIntervals();
    }
  }

  _handleTimingChange() {// subclasses should update the animation data for the specified time
  }

  _updateForTime(time) {// subclasses should update the animation data for the specified time
  }
  /**
   * Returns the closest valid animation interval to the specified time.
   *
   * @protected
   * @param {number} time
   * @returns {number}
   * @memberof Animation
   */


  _intervalClosestToTime(time) {
    let closest = this.from;
    let diff = Math.abs(time - closest);

    if (undefined === this._times) {
      this._updateTimes();
    }

    this._times.forEach(t => {
      const tdiff = Math.abs(time - t);

      if (tdiff < diff) {
        diff = tdiff;
        closest = t;
      }
    });

    return Math.round(closest);
  }
  /**
   * Returns an array of step time intervals, in milliseconds, that will be used during playback.
   *
   * @protected
   * @returns {number[]}
   * @memberof Animation
   */


  _timesForIntervals() {
    if (this.from === this.to) return []; // const now = new Date().getTime();
    // if (null !== this._startOffset) {
    // 	this.from = now + this._startOffset;
    // 	this._time = this.from;
    // }
    // if (null !== this._endOffset) {
    // 	this.to = now + this._endOffset;
    // }

    const times = [];

    const append = time => {
      if (this.canShow(time) && times.indexOf(time) === -1) {
        times.push(time);
      }
    }; // calculate time intervals needed


    const total = this.opts.intervals;
    const interval = Math.round((this.to - this.from) / (total - 1)); // hack to shift first interval 1 second after now for future animations to work around an issue where
    // Google Maps won't animate first frame if it's the same as now at the start of the animation

    const shift = this.isFuture() && this.startDate().getTime() === this.now.getTime() ? 60 * 1000 : 0;
    let lastTime = null;

    for (let i = 0; i < total - 1; i += 1) {
      const tshift = i === 0 ? shift : 0;
      const t = this.from + interval * i + tshift;

      if (i === 0 || t !== lastTime) {
        append(Math.round(t));
        lastTime = t;
      }
    }

    if (times.length > 0) append(this.to);
    this.totalIntervals = times.length;
    return times;
  }

}

var _default = Animation;
exports.default = _default;
module.exports = exports.default;