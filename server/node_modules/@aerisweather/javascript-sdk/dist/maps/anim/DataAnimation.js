"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _Animation = _interopRequireDefault(require("./Animation"));

var _utils = require("../../utils");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * A `DataAnimation` object is a subclass of `Animation` that is responsible for managing data
 * required for animation playback.
 */
class DataAnimation extends _Animation.default {
  /**
   * Initializes a new animation instance with the provided configuration.
   *
   * @param {AnimationOptions} [opts=null]
   * @memberof DataAnimation
   */
  constructor(opts = null) {
    opts = (0, _utils.extend)({}, {
      refresh: 0
    }, opts);
    super(opts);
    this.itemsByTime = {};
    this.lastInterval = 0;
    this.dataBeyondBounds = {
      before: [],
      after: []
    }; // add event handler to re-add all data elements that fall after the end of the timeline
    // range when the animation is stopped

    this.on('stop', () => {
      this.trigger("data:add"
      /* DATA_ADD */
      , {
        items: this.dataBeyondBounds.after.filter(item => item !== undefined)
      }); // eslint-disable-line max-len
    });
  }
  /**
   * Returns the animation data keyed by time interval.
   *
   * @returns {{ [key: number]: any }}
   * @memberof DataAnimation
   */


  dataByTime() {
    return this.itemsByTime;
  }
  /**
   * Updates the data for the animation.
   *
   * @param {*} data
   * @memberof DataAnimation
   */


  setData(data) {
    this.data = data;

    this._prepareDataItems(data);
  }
  /**
   * Begins playing the animation if not currently running.
   *
   * If data is not yet available for playback, then it will be requested from the animation
   * data provider.
   *
   * @returns
   * @memberof DataAnimation
   */


  play() {
    if (!this.canAnimate() && this.provider) {
      this.provider.animationData(this).then(data => {
        this.setData(data);
        this.lastInterval = this.to;
      });
      return;
    }

    super.play();
  }
  /**
   * @ignore
   * Updates the animation by showing the appropriate data for the specifyed time interval.
   *
   * @protected
   * @param {*} time
   * @returns
   * @memberof DataAnimation
   */


  _updateForTime(time) {
    if (!this.dataByTime()) return;
    if (!this.lastInterval) this.lastInterval = this.from;
    const interval = this.currentTime;
    if (interval === this.lastInterval) return;
    const from = Math.min(this.lastInterval, interval);
    const to = Math.max(this.lastInterval, interval); // let data = this._elementsInIntervalRange(from, to);

    let data;
    let remove = interval < this.lastInterval;

    if (interval === this.from) {
      // remove all items in range if we're restarting from the beginning
      remove = true;
      data = this._elementsInIntervalRange(this.from, this.to);
    } else {
      // otherwise get the elements within the new from/to range, unless we're removing in
      // which case we remove all elements within the `from` to bounds end
      data = this._elementsInIntervalRange(from, remove ? this.to : to);
    }

    if (data.length > 0) {
      if (remove) {
        const itemsToRemove = [].concat(this.itemsByTime[this.from]);
        itemsToRemove.forEach(item => {
          const index = data.indexOf(item);

          if (index !== -1) {
            data.splice(index, 1);
          }
        }); // add all elements that fall after end of timeline range so they get removed

        data = data.concat(this.dataBeyondBounds.after);
        this.trigger("data:remove"
        /* DATA_REMOVE */
        , {
          items: data.filter(item => item !== undefined)
        }); // eslint-disable-line max-len
      } else {
        this.trigger("data:add"
        /* DATA_ADD */
        , {
          items: data.filter(item => item !== undefined)
        }); // eslint-disable-line max-len
      }
    }

    this.lastInterval = interval;
  }

  restart() {
    this.lastInterval = this.to;
    super.restart();
  }
  /**
   * Resets the animation to its original state.
   *
   * All cached animation data will be removed and new data will have to be requested from the
   * data provider again when playback begins.
   *
   * @memberof DataAnimation
   */


  reset() {
    this.data = null;
    this.itemsByTime = {};
    super.reset();
  }
  /**
   * Returns whether the animation element is currently visible.
   *
   * @returns {boolean}
   * @memberof DataAnimation
   */


  isVisible() {
    return true;
  }
  /**
   * Returns whether the animation is ready for playback.
   *
   * A data animation is only ready once required data has been set.
   *
   * @returns {boolean}
   * @memberof DataAnimation
   */


  isReady() {
    return (0, _utils.isset)(this.data);
  }

  needsData() {
    return (0, _utils.isset)(this.data) === false;
  }
  /**
   * Returns whether the animation can animated based on whether or not data has been loaded
   * and already cached for playback.
   *
   * @returns {boolean}
   * @memberof DataAnimation
   */


  canAnimate() {
    const can = super.canAnimate();
    return can && this.dataByTime() && Object.keys(this.dataByTime()).length > 0;
  }
  /**
   * @ignore
   * Called when the animation `from` or `to` values have changed so that the animation intervals
   * can be recalculated and data processed into the corresponding time interval blocks.
   *
   * @protected
   * @memberof DataAnimation
   */


  _handleTimingChange() {
    if (this.data) {
      this._prepareDataItems(this.data);
    }
  }
  /**
   * @ignore
   * Prepares the data for animating by assigning each data element into the corresponding time
   * interval block.
   *
   * @protected
   * @param {*} items
   * @returns
   * @memberof DataAnimation
   */


  _prepareDataItems(items) {
    if (this.increment <= 0 || !(0, _utils.isArray)(items)) return;

    const intervals = this._prepareIntervals();

    const data = items;
    const timeKey = 'timestamp';
    this.dataBeyondBounds = {
      before: [],
      after: []
    }; // add data to interval arrays

    (data || []).forEach(item => {
      if ((0, _utils.has)(item, timeKey)) {
        const itemTime = (0, _utils.get)(item, timeKey);

        if (itemTime < this.from) {
          this.dataBeyondBounds.before.push(item);
        } else if (itemTime > this.to) {
          this.dataBeyondBounds.after.push(item);
        } else {
          const interval = this.dataIntervalClosestToTime(itemTime);

          if (itemTime < this.to && intervals[interval]) {
            intervals[interval].push(item);
          }
        }
      }
    });
    this.trigger("load:done"
    /* LOAD_DONE */
    );
    this.trigger("ready"
    /* READY */
    );
  }
  /**
   * @ignore
   * Calculates the time intervals required by the animation based on the animation time range
   * and step increment.
   *
   * @protected
   * @returns {{ [time: number]: any }}
   * @memberof DataAnimation
   */


  _prepareIntervals() {
    let time = this.from;
    const to = this.to; // setup intervals object and arrays

    const intervals = {};

    while (time < to) {
      intervals[Math.round(time)] = [];
      time += this.increment;
    }

    this.itemsByTime = intervals;
    return this.dataByTime();
  }
  /**
   * @ignore
   * Returns the data closest to the specified time interval.
   *
   * @protected
   * @param {number} time
   * @returns {number}
   * @memberof DataAnimation
   */


  dataIntervalClosestToTime(time) {
    const intervals = Object.keys(this.dataByTime()).sort().reverse().map(o => parseInt(o, 10)); // eslint-disable-line max-len

    let interval = 0;

    if (time < this.from || time > this.to) {
      interval = time;
    } else {
      intervals.forEach(value => {
        if (time >= value && interval === 0) {
          interval = value;
        }
      });
    } // the following will add data that falls before the start of the animation to the first
    // interval, which isn't necessarily what is wanted for now
    // if (interval === 0 && time < intervals[0]) {
    // 	interval = intervals[0];
    // }


    return interval;
  }
  /**
   * @ignore
   * Returns the data for the specified time range.
   *
   * @protected
   * @param {number} from
   * @param {number} to
   * @returns {any[]}
   * @memberof DataAnimation
   */


  _elementsInIntervalRange(from, to) {
    if (from === to) return [];
    let result = [];
    const intervals = Object.keys(this.dataByTime()).sort().map(o => parseInt(o, 10));
    const include = [];
    intervals.forEach(interval => {
      let add = false;

      if (to < from) {
        if (interval >= to && interval < from) {
          add = true;
        }
      } else if (interval === from && interval === to) {
        add = true;
      } else if (interval >= from && interval < to || interval === to) {
        add = true;
      } // make sure we aren't re-adding the same interval multiple times


      if (add && include.indexOf(interval) === -1) {
        include.push(interval);
        result = (result || []).concat(this.dataByTime()[interval]);
      }
    });
    return result;
  }

}

var _default = DataAnimation;
exports.default = _default;
module.exports = exports.default;