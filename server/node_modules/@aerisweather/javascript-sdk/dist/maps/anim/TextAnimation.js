"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _DataAnimation = _interopRequireDefault(require("./DataAnimation"));

var _utils = require("../../utils");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * A `TextAnimation` object is a subclass of `DataAnimation` that is responsible for managing a
 * series of text annotations required for animation playback.
 */
class TextAnimation extends _DataAnimation.default {
  /**
   * Initializes a new animation instance with the provided configuration.
   *
   * @param {AnimationOptions} [opts=null]
   * @memberof TextAnimation
   */
  constructor(opts = null) {
    opts = (0, _utils.extend)({}, {
      refresh: 0
    }, opts);
    super(opts);
  }
  /**
   * @ignore
   * Updates the animation by showing the appropriate data for the specifyed time interval.
   *
   * @protected
   * @param {*} time
   * @returns
   * @memberof TextAnimation
   */


  _updateForTime(time) {
    if (!this.dataByTime()) return;
    if (!this.lastInterval) this.lastInterval = this.from;
    const interval = this.currentTime; // if (interval === this.lastInterval) return;

    const from = Math.min(this.lastInterval, interval);
    const to = Math.max(this.lastInterval, interval);
    let elements; // if animation is restarting, we need to update all text elements with their initial value
    // so we need to grab the starting value by unique identifier to update the text values with

    if (interval < this.lastInterval) {
      const ids = [];
      const results = [];
      const intervals = Object.keys(this.dataByTime()).sort().map(o => parseInt(o, 10));
      intervals.forEach(t => {
        const items = this.dataByTime()[t];
        items.forEach(item => {
          if (ids.indexOf(item.id) === -1) {
            results.push(item);
            ids.push(item.id);
          }
        });
      });
      elements = results;
    } else {
      elements = this._elementsInIntervalRange(from, to);
    }

    if (elements.length > 0) {
      this.trigger("data:update"
      /* DATA_UPDATE */
      , {
        items: elements
      });
    }

    this.lastInterval = interval;
  }
  /**
   * @ignore
   * Prepares the data for animating by assigning each data element into the corresponding time
   * interval block.
   *
   * @protected
   * @param {*} items
   * @returns
   * @memberof TextAnimation
   */


  _prepareDataItems(items) {
    if (this.increment <= 0 || !(0, _utils.isPlainObject)(items)) return;

    const intervals = this._prepareIntervals();

    const data = items; // add data to interval arrays

    Object.keys(data).forEach(id => {
      const {
        renderable,
        data: item,
        style
      } = items[id];
      Object.keys(item).forEach(timestamp => {
        const ts = parseInt(timestamp, 10);
        const interval = this.dataIntervalClosestToTime(ts);

        if (ts < this.to && intervals[interval]) {
          intervals[interval].push({
            id,
            value: item[ts],
            renderable,
            style
          });
        }
      });
    });
    this.trigger("ready"
    /* READY */
    );
    this.trigger("load:done"
    /* LOAD_DONE */
    );
  }

}

var _default = TextAnimation;
exports.default = _default;
module.exports = exports.default;