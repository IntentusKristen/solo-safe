"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Mercator = void 0;

/**
 * @ignore
 */
const DegToRad = Math.PI / 180;
/**
 * @ignore
 */

const RadToDeg = 180 / Math.PI;
/**
 * @ignore
 */

const TILE_SIZE = 256;
/**
 * @ignore
 */

const _scale = zoom => TILE_SIZE * 0.5 / Math.PI * Math.pow(2, zoom);
/**
 * @ignore
 */


const _radians = value => value * DegToRad;
/**
 * @ignore
 */


const _degrees = value => value * RadToDeg;
/**
 * @ignore
 */


const _offset = (coord, zoom, size) => {
  const pi = Math.PI;
  const scale = TILE_SIZE * 0.5 / pi * Math.pow(2, zoom);

  const lat = _radians(coord.lat);

  const lon = _radians(coord.lon);

  const x = scale * (lon + pi);
  const y = scale * (pi - Math.log(Math.tan(pi * 0.25 + lat * 0.5)));
  return {
    x: size.width * 0.5 - x,
    y: size.height * 0.5 - y
  };
};
/**
 * @ignore
 */


const toFixed = (value, places = 4) => {
  const factor = Math.pow(10, places);
  return Math.round(value * factor) / factor;
};
/**
 * The `Mercator` module provides utility functions when working with a map in Mercator project,
 * such as converting between geographical coordinates and pixel coordinates and calculating
 * coordinate bounds.
 */


var Mercator;
exports.Mercator = Mercator;

(function (Mercator) {
  /**
   * Returns the coordinate for the specified pixel location on a map.
   *
   * @param {number} x
   * @param {number} y
   * @param {number} zoom
   * @param {Coordinate} [center=undefined]
   * @param {Size} [size=undefined]
   * @returns {Coordinate}
   */
  Mercator.pointToCoord = (x, y, zoom, center = undefined, size = undefined) => {
    const pi = Math.PI;

    const scale = _scale(zoom);

    const offset = center && size ? _offset(center, zoom, size) : {
      x: 0,
      y: 0
    };
    const x2 = x - offset.x;
    const y2 = y - offset.y;
    const lon = x2 / scale - pi;
    const lat = 2 * (Math.atan(Math.exp(pi - y2 / scale)) - pi * 0.25);
    return {
      lat: _degrees(lat),
      lon: _degrees(lon)
    };
  };
  /**
   * Returns the pixel location for the specified pixel location on a map.
   *
   * @param {number} lat
   * @param {number} lon
   * @param {number} zoom
   * @param {Coordinate} [center=undefined]
   * @param {Size} [size=undefined]
   * @returns {Point}
   */


  Mercator.coordToPoint = (lat, lon, zoom, center = undefined, size = undefined) => {
    lon *= DegToRad;
    lat *= DegToRad;
    const pi = Math.PI;

    const scale = _scale(zoom);

    const offset = center && size ? _offset(center, zoom, size) : {
      x: 0,
      y: 0
    };
    const x = scale * (lon + pi);
    const y = scale * (pi - Math.log(Math.tan(pi * 0.25 + lat * 0.5)));
    return {
      x: x + offset.x,
      y: y + offset.y
    };
  };
  /**
   * Returns the center coordinate for the specified coordinate bounds.
   *
   * @param {GeoBounds} bounds
   * @returns {Coordinate}
   */


  Mercator.getBoundsCenter = bounds => {
    let lon = (bounds.west + bounds.east) / 2; // handle international dateline crossover

    if (bounds.west > bounds.east) {
      lon = bounds.west - 360 + (bounds.west + bounds.east) / 2;
    }

    return {
      lat: (bounds.south + bounds.north) / 2,
      lon
    };
  };
  /**
   * Returns the zoom level that best fits the given coordinate bounds based on the map size.
   *
   * @param {GeoBounds} bounds
   * @param {Size} size
   * @returns {number}
   */


  Mercator.getBoundsZoomLevel = (bounds, size) => {
    const WORLD_HEIGHT = 256;
    const WORLD_WIDTH = 256;
    const ZOOM_MAX = 21;

    const latRad = lat => {
      const sin = Math.sin(lat * Math.PI / 180);
      const radX2 = Math.log((1 + sin) / (1 - sin)) / 2;
      return Math.max(Math.min(radX2, Math.PI), -Math.PI) / 2;
    };

    const zoom = (mapPx, worldPx, fraction) => {
      return Math.floor(Math.log(mapPx / worldPx / fraction) / Math.LN2);
    };

    const latFraction = (latRad(bounds.north) - latRad(bounds.south)) / Math.PI;
    const lonDiff = bounds.east - bounds.west;
    const lonFraction = (lonDiff < 0 ? lonDiff + 360 : lonDiff) / 360;
    const latZoom = zoom(size.height, WORLD_HEIGHT, latFraction);
    const lngZoom = zoom(size.width, WORLD_WIDTH, lonFraction);
    return Math.min(latZoom, lngZoom, ZOOM_MAX);
  };
  /**
   * Returns the map size for the given coordinate bounds and zoom level.
   *
   * @param {GeoBounds} bounds
   * @param {number} zoom
   * @returns {Size}
   */


  Mercator.getSizeForBounds = (bounds, zoom) => {
    const nw = Mercator.coordToPoint(bounds.north, bounds.west, zoom);
    const se = Mercator.coordToPoint(bounds.south, bounds.east, zoom);
    return {
      width: se.x - nw.x,
      height: se.y - nw.y
    };
  };
  /**
   * Returns a new coordinate bounds that best fits the given coordinate bounds based on the map
   * size and any amount of padding.
   *
   * @param {GeoBounds} bounds
   * @param {Size} size
   * @param {number} [padding=0]
   * @returns {GeoBounds}
   */


  Mercator.getBoundsThatFits = (bounds, size, padding = 0) => {
    const zoom = 0;
    const tl = Mercator.coordToPoint(bounds.north, bounds.west, zoom);
    const br = Mercator.coordToPoint(bounds.south, bounds.east, zoom);
    const bw = Math.abs(br.x - tl.x);
    const bh = Math.abs(br.y - tl.y);
    const center = {
      x: tl.x + bw / 2,
      y: tl.y + bh / 2
    };
    const targetSize = {
      width: bw,
      height: bh
    };
    const sizeRatio = size.height / size.width;
    const boundsRatio = toFixed(bh / bw, 2); // console.log('RATIO - SIZE', sizeRatio, 'BOUNDS', boundsRatio);

    const pxRatio = targetSize.width / size.width;

    if (sizeRatio !== boundsRatio) {
      if (size.width < size.height) {
        const ratio = size.width / size.height;
        targetSize.height = targetSize.width * (1 / ratio); // pxRatio = targetSize.width / size.width;
      } else {
        const ratio = size.height / size.width;
        targetSize.width = targetSize.height * (1 / ratio); // pxRatio = targetSize.height / size.height;
      }
    }

    targetSize.width += padding * pxRatio;
    targetSize.height += padding * pxRatio;
    const offset = {
      x: targetSize.width / 2,
      y: targetSize.height / 2
    };
    const nw = Mercator.pointToCoord(center.x - offset.x, center.y - offset.y, zoom);
    const se = Mercator.pointToCoord(center.x + offset.x, center.y + offset.y, zoom); // console.log('ADJ PX BOUNDS', 'CENTER', center, 'OFFSET', offset, 'TARGET SIZE', targetSize);
    // console.log('PX CALC', `${se.lat},${nw.lon},${nw.lat},${se.lon}`);

    return {
      north: toFixed(nw.lat),
      south: toFixed(se.lat),
      west: toFixed(nw.lon),
      east: toFixed(se.lon)
    };
  };
  /**
   * Returns the map tile coordinate that contains the given geographical coordinate based on a
   * specific zoom level.
   *
   * @param {Coordinate} coord
   * @param {number} zoom
   * @returns {Point}
   */


  Mercator.coordToTile = (coord, zoom) => {
    const pi = Math.PI;
    const lon = coord.lon;

    const lat = _radians(coord.lat);

    const x = Math.floor((lon + 180) / 360 * Math.pow(2, zoom));
    const y = Math.floor((1 - Math.log(Math.tan(lat) + 1 / Math.cos(lat)) / pi) / 2 * Math.pow(2, zoom));
    return {
      x,
      y
    };
  };
  /**
   * Returns the geographical coordinate for the top-left corner of the given map tile
   * coordinate based on a specific zoom level.
   *
   * @param {Point} tile
   * @param {number} zoom
   * @returns {Coordinate}
   */


  Mercator.tileToCoord = (tile, zoom) => {
    const n = Math.PI - 2 * Math.PI * tile.y / Math.pow(2, zoom);
    const lat = 180 / Math.PI * Math.atan(0.5 * (Math.exp(n) - Math.exp(-n)));
    const lon = tile.x / Math.pow(2, zoom) * 360 - 180;
    return {
      lat,
      lon
    };
  };
})(Mercator || (exports.Mercator = Mercator = {}));