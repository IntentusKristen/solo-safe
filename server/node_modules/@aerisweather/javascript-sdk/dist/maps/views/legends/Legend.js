"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _EventDispatcher = _interopRequireDefault(require("../../../event/EventDispatcher"));

var _utils = require("../../../utils");

var _DOM = _interopRequireDefault(require("../../../display/DOM"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * A legend implements the `LegendRenderable` interface and provides the base legend
 * functionality.
 *
 * @export
 * @class Legend
 * @implements {LegendRenderable}
 */
class Legend extends _EventDispatcher.default {
  /**
   * Initializes and returns a legend for the specified key and configuration options.
   *
   * @param {string} key
   * @param {LegendOptions} opts
   * @memberof Legend
   */
  constructor(key, opts) {
    super();
    this._key = key;
    this._opts = (0, _utils.extend)({
      size: undefined,
      autosize: false,
      format: 'svg',
      metric: false
    }, opts);

    if (!(0, _utils.isset)(this._opts.size)) {
      this._opts.autosize = true;
    }

    this._target = (0, _DOM.default)(`<div class="awxjs__legend awxjs__legend-${key}"></div>`);
    setTimeout(() => {
      this.update(this._opts);
    }, 500);
  }
  /**
   * Configuration options.
   *
   * @readonly
   * @type {LegendOptions}
   * @memberof Legend
   */


  get opts() {
    return this._opts;
  }
  /**
   * Key associated with the legend.
   *
   * @readonly
   * @type {string}
   * @memberof Legend
   */


  get key() {
    return this._key;
  }
  /**
   * Aeris account used when requesting data for dynamic legends.
   *
   * @readonly
   * @type {Account}
   * @memberof Legend
   */


  get account() {
    return this.opts.account;
  }
  /**
   * DOM element for the legend.
   *
   * @readonly
   * @type {*}
   * @memberof Legend
   */


  get $el() {
    return this._target;
  }
  /**
   * Shows the legend DOM element.
   *
   * @memberof Legend
   */


  show() {
    this.$el.show();
  }
  /**
   * Hides the legend DOM element.
   *
   * @memberof Legend
   */


  hide() {
    this.$el.hide();
  }
  /**
   * Sets the size of the legend.
   *
   * @param {Size} size
   * @memberof Legend
   */


  setSize(size) {
    this._opts.size = (0, _utils.extend)(this._opts.size, size);
    this.update();
  }

  getSize() {
    if (this.$el) {
      const bounds = this.$el.bounds();
      const h = this.$el.outerHeight(true);
      return {
        width: bounds.width,
        height: h
      };
    }

    return {
      width: 0,
      height: 0
    };
  }
  /**
   * Sets whether to display data values in Metric units.
   *
   * @param {boolean} metric
   * @memberof Legend
   */


  setMetric(metric) {
    this._opts.metric = metric;
    this.update(null, true);
  }
  /**
   * Returns the unit based on whether the legend is displaying values in Metric or Imperial.
   *
   * @returns {string}
   * @memberof Legend
   */


  units() {
    const key = this._opts.metric ? 'metric' : 'imperial';
    let unit = (0, _utils.get)(this._opts, `units.${key}`);

    if (unit && /^(f|c)$/.test(unit)) {
      unit = unit.toUpperCase();
    }

    return unit;
  }
  /**
   * Resets the legend by removing an existing image.
   *
   * @memberof Legend
   */


  reset() {
    this.$el.empty();
  }
  /**
   * Forces the legend to update if needed.
   *
   * @param {*} [opts]
   * @memberof Legend
   */


  update(opts, force = false) {}

  resize() {
    const size = this.getSize();
    const content = (0, _DOM.default)('.awxjs__legend-content', this.$el).children();

    if (content) {
      content.forEach(el => {
        size.width = Math.max(size.width, (0, _DOM.default)(el).outerWidth(true));
      });
    }

    this.$el.css('width', `${size.width}px`);
    this.trigger('resize', size);
  }

}

var _default = Legend;
exports.default = _default;
module.exports = exports.default;