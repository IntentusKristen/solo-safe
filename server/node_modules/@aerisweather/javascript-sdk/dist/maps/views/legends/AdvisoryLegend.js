"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _StyledLegend = _interopRequireDefault(require("./StyledLegend"));

var _ApiRequest = _interopRequireDefault(require("../../../network/api/ApiRequest"));

var _Mercator = require("../../proj/Mercator");

var _utils = require("../../../utils");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const boundsStrFromCenter = (lat, lon, zoom, size) => {
  const center = {
    lat,
    lon
  };

  const nw = _Mercator.Mercator.pointToCoord(0, 0, zoom, center, size);

  const se = _Mercator.Mercator.pointToCoord(size.width, size.height, zoom, center, size);

  nw.lat = parseFloat(nw.lat.toFixed(2));
  nw.lon = parseFloat(nw.lon.toFixed(2));
  se.lat = parseFloat(se.lat.toFixed(2));
  se.lon = parseFloat(se.lon.toFixed(2));
  return `${nw.lat},${nw.lon},${se.lat},${se.lon}`;
};
/**
 * An advisory legend is a legend object that is responsible for displaying and managing a point
 * legend based on dynamic advisory data that filters advisory elements based on specific filters
 * and/or VTEC codes.
 *
 * @export
 * @class AdvisoryLegend
 * @extends {Legend}
 */


class AdvisoryLegend extends _StyledLegend.default {
  /**
   * Forces the legend to update if needed.
   *
   * Typically this method is called with valid coordinate bounds passed to the `opts.within`
   * property in order to update the advisories displayed based on those within the specified
   * bounds.
   *
   * @param {*} [opts]
   * @memberof AdvisoryLegend
   */
  update(opts, force = false) {
    if (opts) {
      if (opts.within) {
        if (opts.within.bounds) {
          let {
            east,
            west
          } = opts.within.bounds;
          const lspan = Math.abs(east - west);
          const lcount = Math.floor(lspan / 360); // if we're spanning 360 deg lon or more, then override the west/east values to be
          // clamped at the valid -180 > 180 span

          if (lcount > 0) {
            west = -180;
            east = 180;
          }

          opts.within.bounds.west = west;
          opts.within.bounds.east = east;
        }

        this.opts.within = opts.within;
      }

      this._update();
    } else if ((0, _utils.isset)(this.opts.keys)) {
      super.update(opts, force);
    }
  }

  _update() {
    if (!this.account) {
      console.warn('[Aeris] Cannot render advisories/alerts legend, no valid Aeris account defined');
      return;
    }

    if (!this._request) {
      this._request = (0, _utils.debounce)(opts => {
        this._getVtecCodes(opts).then(codes => {
          this.opts.keys = codes.join(','); // hide the legend if we don't have any VTEC codes

          if (codes.length === 0) {
            // this.hide();
            // this.reset();
            const title = this.opts.title ? this.opts.title.replace(/\([^\)]+\)$/, '') : null;
            this.$el.html(`
							${title ? `<div class="awxjs__legend-title">${title}</div>` : ''}
							<div class="awxjs__legend-content">
								<div class="awxjs__legend-empty">No advisories within map bounds.</div>
							</div>
						`);
            this.resize();
          } else {
            this.show();
            this.update(null, true);
          }
        });
      }, 1000);
    }

    this._request(this.opts.within);
  }

  _getVtecCodes(opts = {}) {
    const {
      size
    } = opts;
    let {
      center,
      bounds,
      zoom
    } = opts;
    zoom = parseInt(zoom, 10);
    return new Promise((resolve, reject) => {
      if (!bounds) {
        if (!size || Number.isNaN(size.width) || Number.isNaN(size.height)) {
          reject(new Error('Size is not a number'));
          return;
        }

        if (!bounds && center) {
          if ((0, _utils.isString)(center) && /^[\d\.-]+,[\d\.-]+/.test(center)) {
            center = center.split(',');
            bounds = boundsStrFromCenter(center[0], center[1], zoom, size);
          } else if ((0, _utils.isObject)(center) && center.lat && center.lon) {
            bounds = boundsStrFromCenter(center.lat, center.lon, zoom, size);
          }
        }
      }

      if (bounds) {
        this._getAdvisories(bounds).then(codes => {
          resolve(codes);
        });
      } else if (center) {
        this._getPlace(center, size, zoom).then(b => {
          this._getAdvisories(b).then(codes => {
            resolve(codes);
          });
        });
      }
    });
  }

  _getPlace(loc, size, zoom) {
    return new Promise((resolve, reject) => {
      const request = new _ApiRequest.default({
        client: this.account.credentials()
      });
      request.endpoint('places').place(loc).limit(1).get().then(result => {
        if (result.data) {
          const {
            loc: {
              lat,
              long: lon
            }
          } = result.data;
          const boundsStr = boundsStrFromCenter(lat, lon, zoom, size);
          const bounds = boundsStr.split(',').map(val => parseFloat(val));

          if (bounds.length === 4) {
            resolve({
              north: bounds[0],
              west: bounds[1],
              south: bounds[2],
              east: bounds[3]
            });
          } else {
            reject();
          }
        }
      });
    });
  }

  _getAdvisories(bounds) {
    return new Promise((resolve, reject) => {
      const isSummary = this.account.canAccess('advisories_summary');
      let sortByName = true;

      const setupRequest = (requestBounds, summary) => {
        const request = new _ApiRequest.default({
          client: this.account.credentials()
        });

        if (summary) {
          request.endpoint('alerts/summary').fields('summary.typeCodes,summary.types.type,summary.types.code');
          request.sort('priority:1');
          sortByName = false;
        } else {
          request.endpoint('alerts').fields('details.type,details.name').limit(300);
        }

        if (requestBounds.west < -180 || requestBounds.west > 180) {
          requestBounds.west += 360 * Math.floor(requestBounds.west / 360);
        }

        request.action("within"
        /* WITHIN */
        ).bounds(requestBounds);
        return request;
      };

      const process = data => {
        const results = [];

        if (data) {
          if (isSummary) {
            data = data[0] || data; // vtecs = get(data, 'summary.typeCodes');

            const types = (0, _utils.get)(data, 'summary.types');
            (types || []).filter(item => (0, _utils.isset)(item) && (0, _utils.isset)(item.code)).forEach(item => {
              const {
                code,
                type
              } = item;
              const exists = results.some(result => result.code === code);

              if (code && exists === false) {
                results.push({
                  code,
                  name: type.toUpperCase()
                });
              }
            });
          } else {
            data.filter(item => (0, _utils.isset)(item) && (0, _utils.isset)(item.type)).forEach(advisory => {
              const {
                type: code,
                name: type
              } = advisory.details;
              const exists = results.some(result => result.code === code);

              if (code && exists === false) {
                results.push({
                  code,
                  name: type.toUpperCase()
                });
              }
            });
          }
        } // sort advisories by name


        const sorted = !sortByName ? results : results.sort((a, b) => {
          if (a.name < b.name) {
            return -1;
          }

          if (a.name > b.name) {
            return 1;
          }

          return 0;
        }); // return an array of VTEC codes for the sorted list

        const vtecs = sorted.reduce((prev, current) => {
          prev.push(current.code);
          return prev;
        }, []);
        return vtecs;
      }; // due to a limitation within the API, if the lspan is 180 or greater we need to split the
      // requests into two, each covering half the span; also if we cross the dateline


      const {
        west,
        east
      } = bounds;
      const lspan = west > east ? Math.abs(180 - west + (180 - Math.abs(east))) : Math.abs(east - west);

      if (lspan > 180 || west > east) {
        const offset = lspan / 2;
        const clampToDateline = west > east;
        const mid = west + offset;
        const batch = new _ApiRequest.default({
          client: this.account.credentials()
        });
        const leftRequest = setupRequest((0, _utils.extend)({}, bounds, {
          east: clampToDateline ? 180 : mid
        }), isSummary);
        const rightRequest = setupRequest((0, _utils.extend)({}, bounds, {
          west: clampToDateline ? -180 : mid
        }), isSummary);
        batch.addRequest(leftRequest);
        batch.addRequest(rightRequest);
        batch.get().then(result => {
          const responses = (0, _utils.get)(result, 'data.responses');
          let data = isSummary ? {
            summary: {
              types: [],
              typeCodes: []
            }
          } : [];

          if (responses) {
            responses.forEach(response => {
              response = response.response || response;

              if (response) {
                if (isSummary) {
                  const dataset = response[0] || response;
                  const {
                    types,
                    typeCodes
                  } = dataset.summary || {};
                  data.summary.types = data.summary.types.concat(types);
                  data.summary.typeCodes = data.summary.typeCodes.concat(typeCodes);
                } else if (!(0, _utils.isEmpty)(response)) {
                  data = data.concat(response);
                }
              }
            });
          }

          const vtecs = process(data || {});
          resolve(vtecs);
        });
      } else {
        const request = setupRequest(bounds, isSummary);
        request.get().then(result => {
          const vtecs = process(result.data || {});
          resolve(vtecs);
        });
      }
    });
  }

}

var _default = AdvisoryLegend;
exports.default = _default;
module.exports = exports.default;