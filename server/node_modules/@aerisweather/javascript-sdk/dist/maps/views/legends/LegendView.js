"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _EventDispatcher = _interopRequireDefault(require("../../../event/EventDispatcher"));

var _ = require(".");

var _Http = _interopRequireDefault(require("../../../network/Http"));

var _LegendStore = _interopRequireDefault(require("./LegendStore"));

var _utils = require("../../../utils");

var _DOM = _interopRequireDefault(require("../../../display/DOM"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var __awaiter = void 0 && (void 0).__awaiter || function (thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function (resolve) {
      resolve(value);
    });
  }

  return new (P || (P = Promise))(function (resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }

    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }

    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }

    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};

/**
 * A legend view is responsible for displaying and manging a series of legend elements.
 *
 * @export
 * @class LegendView
 * @extends {EventDispatcher}
 */
class LegendView extends _EventDispatcher.default {
  /**
   * Initializes and returns a legend view instance with the specified target and configuration
   * object.
   *
   * @param {*} target
   * @param {LegendOptions} [opts]
   * @memberof LegendView
   */
  constructor(target, opts) {
    super();
    this._loading = false;
    this._loadCallbacks = {};

    this._onResize = () => {
      this.trigger('resize', this.getSize());
    };

    if (!target) {
      throw new Error('[Aeris] Invalid DOM target specified for LegendView');
    }

    this._opts = (0, _utils.extend)({
      size: {
        width: 400,
        height: 40
      }
    }, opts);
    this._store = new _LegendStore.default();
    (0, _DOM.default)(target).append(`<div class="awxjs__legend-view"></div>`);
    this._target = (0, _DOM.default)('.awxjs__legend-view', target);
  }
  /**
   * The DOM element for the legend view.
   *
   * @readonly
   * @type {*}
   * @memberof LegendView
   */


  get $el() {
    return this._target;
  }

  get count() {
    return this._store.count;
  }
  /**
   * Adds a legend for the specified legend type code and options.
   *
   * @param {string} type
   * @param {LegendOptions} [opts]
   * @returns
   * @memberof LegendView
   */


  add(type, opts) {
    const key = this.getKey(type);
    let config; // load default legend styles if not already cached

    if (!this._configs) {
      this._loadCallbacks[type] = () => {
        this.add(type, opts);
      };

      if (this._loading === false) {
        this.loadStyles();
      }

      return;
    }

    opts = (0, _utils.extend)((0, _utils.cloneDeep)(this._opts), opts);

    if (opts.type === 'image') {
      config = opts;
    } // determine if we have a default style for the legend


    const legendStyle = this.configForType(type);

    if (legendStyle) {
      const {
        config: styleConfig
      } = legendStyle;

      if (!(0, _utils.isEmpty)(styleConfig)) {
        config = styleConfig;
      }

      if (!(0, _utils.isEmpty)(styleConfig.use)) {
        const parentStyle = this.configForType(styleConfig.use);
        config = Object.assign(Object.assign({}, parentStyle), config);
      }
    }

    if (!(0, _utils.isset)(config)) {
      // console.warn(`[Aeris] No configuration found for legend {${type}}, not adding to view`);
      return;
    }

    const legendOpts = (0, _utils.extend)(opts, {
      title: config.title,
      size: this._opts.size,
      autosize: this._opts.autosize,
      format: this._opts.format,
      metric: this._opts.metric
    }, config, opts);

    let legend = this._store.get(key); // just update the legend as needed if it already exists


    if (legend) {
      this._store.increment(key);

      legend.update(legendOpts);
      return;
    }

    if (config && !(0, _utils.isEmpty)(config)) {
      legend = this.createLegend(type, config, legendOpts);
      this.addLegend(legend);

      if (key !== type) {
        this._store.map(key, type);
      }
    }
  }
  /**
   * Returns the legend for the specified type code if it exists in the view.
   *
   * @param {string} type
   * @returns {LegendRenderable}
   * @memberof LegendView
   */


  get(type) {
    const key = this.getKey(type);

    if (key) {
      return this._store.get(key);
    }

    return null;
  }
  /**
   * Updates the legend view for the specified type codes and options. All previously existing
   * legends will be removed.
   *
   * @param {string[]} types
   * @param {*} [opts]
   * @memberof LegendView
   */


  set(types, opts) {
    types = types || [];
    this.removeAll(types);
    types.forEach(type => {
      if (!this.has(type)) {
        this.add(type, opts);
      } else {
        this.get(type).update(opts);
      }
    });
  }
  /**
   * Removes the legend for the specified type code.
   *
   * @param {string} type
   * @memberof LegendView
   */


  remove(type) {
    const key = this.getKey(type);

    if (key) {
      const legend = this._store.get(key);

      if (legend) {
        this._store.remove(key); // remove legend from the view if total references is 0


        if (this._store.refCount(key) === 0) {
          this.removeLegend(legend);
        }
      }

      if (legend instanceof _EventDispatcher.default) {
        legend.off('resize', this._onResize);
      }

      this._onResize();
    }

    if (this.count === 0) {
      this.$el.hide();
      this.trigger('empty');
    }
  }
  /**
   * Sets the legend using a static image URL. All previously existing legends will be removed.
   *
   * @param {string} url
   * @memberof LegendView
   */


  setUrl(url) {
    this.removeAll();
    this.$el.empty();
    this.$el.append(`<div class="awxjs__legend"><img src="${url}"></div>`);
  }
  /**
   * Adds a legend item to the view.
   *
   * @param {LegendRenderable} legend
   * @memberof LegendView
   */


  addLegend(legend) {
    const key = legend.key;

    this._store.add(key, legend);

    this.$el.append(legend.$el);
    this.$el.show();

    if (legend instanceof _EventDispatcher.default) {
      legend.on('resize', this._onResize);
    }

    this.trigger('add', {
      key: legend.key,
      count: this.count
    });

    this._onResize();
  }
  /**
   * Removes a legend item from the view.
   *
   * @param {LegendRenderable} legend
   * @memberof LegendView
   */


  removeLegend(legend) {
    if (legend) {
      legend.$el.remove();

      this._store.remove(legend.key, true);

      this.trigger('remove', {
        key: legend.key,
        count: this.count
      });
    }
  }
  /**
   * Removes all existing legends from the view.
   *
   * @param {string[]} [exclude]
   * @memberof LegendView
   */


  removeAll(exclude) {
    Object.keys(this._store.items).forEach(key => {
      let remove = true;

      if (exclude) {
        const altkeys = this._store.mapping.get(key) || [];

        if (exclude.indexOf(key) !== -1) {
          remove = false;
        } else if (altkeys) {
          altkeys.forEach(k => {
            if (exclude.indexOf(k) !== -1) {
              remove = false;
            }
          });
        }
      }

      if (remove) {
        this.remove(key);
      }
    });
  }
  /**
   * Returns whether the view contains a legend for the specified type code.
   *
   * @param {string} type
   * @returns {boolean}
   * @memberof LegendView
   */


  has(type) {
    const {
      key
    } = this.configForType(type);

    if (key) {
      return this._store.has(key);
    }

    return false;
  }
  /**
   * Forces an update of all existing legends.
   *
   * @param {{ [key: string]: any }} [opts]
   * @memberof LegendView
   */


  update(opts) {
    this._each((key, legend) => legend.update(opts));
  }
  /**
   * Sets whether the display data values in Metric units.
   *
   * @param {boolean} metric
   * @memberof LegendView
   */


  setMetric(metric) {
    this._opts.metric = metric;

    this._each((key, legend) => legend.setMetric(metric));
  }
  /**
   * Sets the size of the view and existing legends.
   *
   * @param {Size} size
   * @memberof LegendView
   */


  setSize(size) {
    this._opts.size = size;

    this._each((key, legend) => legend.setSize(size));
  }

  getSize() {
    let height = 0;
    let width = 0;

    this._each((key, legend) => {
      const size = legend.getSize();
      height += size.height;
      width = Math.max(width, size.width);
    });

    return {
      width,
      height
    };
  }
  /**
   * Sets the width of the view and all existing legends. The previous height value will be
   * used.
   *
   * @param {number} width
   * @memberof LegendView
   */


  setWidth(width) {
    const {
      height
    } = this._opts.size;
    this.setSize({
      width,
      height
    });
  }

  configForType(type) {
    if (!this._configs) return {
      key: null,
      config: null
    };
    let config = this._configs[type];
    let altkey;

    if (!config && /^f/.test(type)) {
      altkey = type.replace(/^f/, '');
      config = this._configs[altkey];
    }

    if (!config) {
      Object.keys(this._configs).forEach(key => {
        const defaults = this._configs[key];
        const enabled = defaults.enabled === true || !(0, _utils.isset)(defaults.enabled);

        if (enabled) {
          const layers = defaults.layers;

          if (layers) {
            layers.forEach(pattern => {
              const re = new RegExp(pattern);

              if (re.test(type)) {
                config = (0, _utils.cloneDeep)(defaults);
                altkey = key;
              }
            });

            if (config && !altkey) {
              altkey = key;
            }
          }
        }
      });
    }

    return {
      key: altkey || type,
      config: (0, _utils.cloneDeep)(config)
    };
  }

  _reset() {
    this.$el.empty();

    this._each((key, legend) => legend.reset());
  }

  _each(fn) {
    this._store.each(fn);
  }

  getKey(type) {
    let key = type; // determine if we have a different key to use from the style

    const legendStyle = this.configForType(type);

    if (legendStyle) {
      const {
        key: styleKey
      } = legendStyle;
      key = styleKey;
    }

    return key;
  }

  createLegend(type, config, opts) {
    const key = this.getKey(type);
    let legend;

    if (config.type === 'image') {
      legend = new _.ImageLegend(key, opts);
    } else if (config.grouped && config.items) {
      const typeOverrides = opts.types || {}; // determine if we need a grouped legend or a single one

      opts.types = config.items.reduce((prev, current) => {
        const {
          config: itemConfig
        } = this.configForType(current.key);
        const itemOpts = (0, _utils.extend)({
          factor: current.factor,
          size: {
            height: this._opts.size.height
          }
        }, itemConfig, typeOverrides[current.key]);
        itemOpts.size.width = Math.floor(this._opts.size.width * itemOpts.factor);
        prev[current.key] = itemOpts;
        return prev;
      }, {});
      legend = new _.GroupedLegend(key, opts);
    } else if (type === 'alerts' || type === 'advisories' || /^alerts-/.test(type)) {
      legend = new _.AdvisoryLegend(key, opts);

      if ((0, _utils.isset)(opts.within)) {
        setTimeout(() => {
          this.update({
            account: opts.account,
            within: opts.within
          });
        }, 500);
      }
    } else {
      legend = new _.StyledLegend(key, opts);
    }

    return legend;
  }

  loadStyles() {
    this._loading = true;
    return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
      if (this._configs) {
        resolve(this._configs);
        return;
      }

      _Http.default.request('https://legends.aerisapi.com/defaults.json').then(res => {
        if (res.data) {
          const configs = res.data;
          Object.keys(configs).forEach(key => {
            const config = configs[key];

            if (config.config) {
              // convert underscore keys to dot-notation
              Object.keys(config.config).forEach(configKey => {
                if (configKey.indexOf('_') !== -1) {
                  const setKey = configKey.replace(/^labels_/, 'label_').replace(/_/g, '.');
                  (0, _utils.set)(config.config, setKey, config.config[configKey]);
                  delete config.config[configKey];
                }
              });
              config.styles = (0, _utils.cloneDeep)(config.config);
              delete config.config;
            }
          });
          this._configs = configs;
          this._loading = false;
          resolve((0, _utils.cloneDeep)(this._configs));
          Object.keys(this._loadCallbacks).forEach(key => {
            const fn = this._loadCallbacks[key];
            fn();
          });
        }
      });
    }));
  }

}

var _default = LegendView;
exports.default = _default;
module.exports = exports.default;