"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _ImageLegend = _interopRequireDefault(require("./ImageLegend"));

var _utils = require("../../../utils");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * A styled legend is a legend that is responsible for rendering a legend image based on a specific
 * legend configuration and style.-
 *
 * @export
 * @class StyledLegend
 * @implements {LegendRenderable}
 */
class StyledLegend extends _ImageLegend.default {
  /**
   * Sets the size of the legend.
   *
   * @param {Size} size
   * @memberof StyledLegend
   */
  setSize(size) {
    this.opts.size = (0, _utils.extend)(this.opts.size, size);
    this.update();
  }
  /**
   * Returns the calculated legend url.
   *
   * @returns {string}
   * @memberof StyledLegend
   */


  url() {
    return this._url();
  }

  _url() {
    const config = this.opts;
    const style = (0, _utils.extend)({
      interval: 1,
      gutter: null,
      radius: 6,
      columns: 4,
      metric: false,
      orientation: "h"
      /* HORIZONTAL */
      ,
      cell: {
        size: {
          width: 2,
          height: 10
        }
      },
      label: {
        interval: 20,
        position: "b"
        /* BOTTOM */
        ,
        fontsize: 11,
        color: '#222222'
      }
    }, config.styles);
    const type = config.type || "bar"
    /* BAR */
    ;
    const cellOpts = style.cell || {};
    const labelOpts = style.label || {};
    const params = {};

    if (type === "point"
    /* POINT */
    ) {
        if (!(0, _utils.isset)(style.gutter)) {
          style.gutter = {
            x: 20,
            y: 5
          };
        } else if ((0, _utils.isString)(style.gutter)) {
          const p = style.gutter.split(',');
          style.gutter = {
            x: p[0],
            y: p[1]
          };
        }
      }

    params.ls = labelOpts.fontsize;

    if (!(0, _utils.isEmpty)(labelOpts.custom)) {
      params.labels = labelOpts.custom.replace(/,\s+/g, ',').replace(/\s/g, '%20');
    }

    if (!(0, _utils.isEmpty)(labelOpts.color)) {
      const color = labelOpts.color.replace(/#/, '');

      if (color.length === 6) {
        params.lc = color;
      }
    }

    if (type === "point"
    /* POINT */
    && !(0, _utils.isEmpty)(style.filter_groups)) {
      params.filter = style.filter_groups;
    }

    if ((0, _utils.isset)(config.range)) {
      if ((0, _utils.isString)(config.range)) {
        params.range = `,${config.range}`;
      } else if ((0, _utils.isArray)(config.range)) {
        if (config.range.length === 1) {
          params.range = `,${config.range[0]}`;
        } else {
          params.range = config.range.join(',');
        }
      }
    }

    if ((0, _utils.isset)(config.keys)) {
      params.keys = config.keys;
    } else if ((0, _utils.isset)(config.filter)) {
      params.filter = config.filter;
    }

    const units = style.units;

    if (units) {
      if (config.metric) {
        params.units = units.metric;
      } else {
        params.units = units.imperial;
      }
    }

    const {
      width,
      height
    } = config.size || {
      width: null,
      height: null
    };
    const {
      width: cellWidth,
      height: cellHeight
    } = cellOpts.size || {
      width: null,
      height: null
    };
    const vars = {
      type,
      interval: !(0, _utils.isEmpty)(style.interval) ? `-i${style.interval}` : '',
      label: {
        interval: !(0, _utils.isEmpty)(labelOpts.interval) ? `-li${labelOpts.interval}` : ''
      },
      cell: {
        size: !(0, _utils.isEmpty)(cellWidth) && !(0, _utils.isEmpty)(cellHeight) ? `-c${cellWidth}x${cellHeight}` : '',
        pad: (0, _utils.isset)(style.gutter) ? `-p${style.gutter.x},${style.gutter.y}` : ''
      },
      layout: `-${style.orientation},${labelOpts.position}`,
      metric: config.metric ? '-metric' : '',
      size: !(0, _utils.isEmpty)(width) && !(0, _utils.isEmpty)(height) && !config.autosize ? `_${width}x${height}` : '',
      format: config.format,
      radius: !(0, _utils.isEmpty)(style.radius) ? `-r${style.radius}` : '',
      columns: !(0, _utils.isEmpty)(style.columns) && style.columns > 0 ? `-col${style.columns}` : ''
    };
    let url = `https://legends.aerisapi.com/${this.key}`;

    if (type === "point"
    /* POINT */
    ) {
        url += `${vars.radius}${vars.columns}${vars.cell.pad}`;
      } else {
      url += `${vars.interval}${vars.label.interval}${vars.cell.size}${vars.cell.pad}${vars.layout}${vars.metric}`;
    }

    url += `${vars.size}.${vars.format}`; // add query string to url if we have params

    url += (url.indexOf('?') > -1 ? '&' : '?') + Object.keys(params).map(k => `${encodeURIComponent(k)}=${params[k]}`).join('&');
    return url;
  }

}

var _default = StyledLegend;
exports.default = _default;
module.exports = exports.default;