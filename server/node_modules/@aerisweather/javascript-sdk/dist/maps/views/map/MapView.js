"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _EventDispatcher = _interopRequireDefault(require("../../../event/EventDispatcher"));

var _MapConfig = _interopRequireDefault(require("./MapConfig"));

var _MapRequest = _interopRequireDefault(require("../../../network/maps/MapRequest"));

var _MapViewAnimator = _interopRequireDefault(require("./MapViewAnimator"));

var _LegendView = _interopRequireDefault(require("../legends/LegendView"));

var _Timeline = _interopRequireDefault(require("../../anim/Timeline"));

var _Layers = _interopRequireDefault(require("../../Layers"));

var _ActivityIndicator = _interopRequireDefault(require("../../../ui/ActivityIndicator"));

var _utils = require("../../../utils");

var _strings = require("../../../utils/strings");

var _globals = require("../../../globals");

var _DOM = _interopRequireDefault(require("../../../display/DOM"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @ignore
 */
const containers = {
  combined: ['layers'],
  split: ['base', 'past', 'future', 'overlays', 'past-text', 'future-text']
};

class MapTimestamp {
  constructor(opts) {
    this._opts = (0, _utils.extend)({
      format: 'MM/dd/yyyy hh:mm a',
      continuous: true
    }, opts);
    this.element = (0, _DOM.default)('<div class="awxjs__map-overlay__timestamp"></div>');
  }

  continuous() {
    return this._opts.continuous === true;
  }

  update(time) {
    const d = new Date(time);
    this.element.html((0, _utils.formatDate)(d, this._opts.format));
  }

}
/**
 * A view object that displays and manages static map content using imagery from the Aeris Maps
 * Platform (AMP).
 *
 * A `MapView` instance does not support user interaction in regards to panning and zooming other
 * support for static control elements to reload map content. If you need to support greater user
 * interaction for map panning and zooming, use an instance of `Map` instead.
 */


class MapView extends _EventDispatcher.default {
  /**
   * Initializes a map view instance with the specified target and configuration object.
   *
   * @param {HTMLElement} target
   * @param {MapViewOptions} [opts=undefined]
   * @memberof MapView
   */
  constructor(target, opts = undefined) {
    super();
    this._ready = false;
    /*
     * Event Handlers
     */

    this.handleLayerChange = e => {
      if (this.timeline) {
        // enable or disable text animation instances based on current map layers
        const enabled = this.config.hasText();
        const pastText = this.timeline.get('pastText');
        const futureText = this.timeline.get('futureText');
        if (pastText) pastText.enabled(enabled);
        if (futureText) futureText.enabled(enabled);
      }

      this.trigger("change:data"
      /* CHANGE_DATA */
      , {
        layers: this.config.data()
      });
    };

    this.handleOffsetChange = e => {
      let {
        data: {
          offset
        }
      } = e;

      if ((0, _utils.isset)(offset)) {
        offset = `${offset}`;

        if (/^-/.test(offset) || offset === '0' || offset == 'current') {
          if (!(0, _utils.get)(this.opts, 'animation.alwaysShowFuture')) {
            ['future', 'futureText'].forEach(type => this._targets[type].hide());
          }
        } else {
          if (!(0, _utils.get)(this.opts, 'animation.alwaysShowPast')) {
            ['past', 'pastText'].forEach(type => this._targets[type].hide());
          }
        }

        if (this._timestamp) {
          const time = (0, _utils.offsetToTime)(this.config.offset());

          this._timestamp.update(time);
        }
      }
    };

    this._loadingGroups = [];
    this.update = (0, _utils.debounce)(groups => {
      if (!this._ready) return;
      const hasDataLayers = (this.config.data() || []).length > 0;

      this._animator.past.enabled(hasDataLayers);

      this._animator.pastText.enabled(hasDataLayers);

      this._animator.future.enabled(hasDataLayers);

      this._animator.futureText.enabled(hasDataLayers);

      let types = groups || this._loadingGroups; // now adjust types based on what actually needs updating

      types = this._adjustTypesForUpdate(types);

      if (types.length === 0) {
        return;
      }

      if (this.timeline) {
        this.timeline.reset();
      }

      if (this._timestamp && (!this.timeline || !this.timeline.isEnabled())) {
        const time = (0, _utils.offsetToTime)(this.config.offset());

        this._timestamp.update(time);
      }

      this.trigger("load:start"
      /* LOAD_START */
      );

      const onComplete = () => {
        Object.keys(images).forEach(key => {
          this.setImage(key, images[key]);
        }); // if (this.timeline) {
        // 	const animations = this.timeline.animations;
        // 	if (animations) {
        // 		Object.keys(animations).forEach(key => {
        // 			const anim = <ImageAnimation>animations[key];
        // 			if (anim.isEnabled()) {
        // 				// anim.element.show();
        // 			}
        // 		});
        // 	}
        // }

        this.trigger("load:done"
        /* LOAD_DONE */
        );
      };

      const checkCompletion = function () {
        if (needed.length === 0) {
          onComplete();
        }
      };

      const images = {};
      const needed = types.slice(0);
      types.forEach(type => {
        const isFuture = type == 'future';
        let group = type;

        if (type === 'past' || type === 'future') {
          group = 'data';
        } else if (type === 'pastText' || type === 'futureText') {
          group = 'text';
        }

        const hasLayers = (0, _utils.isset)(this.config.opts(`layers.${group}`));

        if (hasLayers) {
          if (this.timeline && (group === 'data' || group === 'text')) {
            const anim = this.timeline.get(type);

            if (anim) {
              // anim.element.hide();
              if (!anim.canShow()) {
                needed.splice(needed.indexOf(type), 1);
                checkCompletion();
              } else {
                anim.once('load:image load:error', e => {
                  needed.splice(needed.indexOf(type), 1);
                  checkCompletion();
                });
              }

              anim.goToTime(this.timeline.currentTime);
            }

            return;
          }

          const request = this._request.clone();

          request.setParams(this.config.toRequestOpts([group], isFuture));
          request.get().then(result => {
            // console.log('done loading', type, result.image);
            needed.splice(needed.indexOf(type), 1);

            if (result.image) {
              images[type] = result.image.src;
            }

            checkCompletion();
          }).catch(e => {
            console.error('ERROR', e);
          });
        } else {
          needed.forEach((key, index) => {
            if (key === 'past' || key === 'future' || key === 'pastText' || key === 'futureText') {
              needed.splice(index, 1);
            }
          });
          this.setImage(type, null);
        }
      });
    }, 500);

    if (!target) {
      throw new Error('[Aeris] Invalid DOM target specified for MapView');
    } // convert comma-separated strings to arrays


    ['base', 'data', 'overlays'].forEach(k => {
      const key = `map.layers.${k}`;
      const val = (0, _utils.get)(opts, key);

      if ((0, _utils.isString)(val)) {
        (0, _utils.set)(opts, key, val.replace(/\s/, '').split(','));
      }
    });
    this._opts = (0, _utils.extend)({
      account: null,
      map: {
        layers: {
          base: ['flat'],
          overlays: ['admin']
        },
        center: {
          lat: 40.0,
          lon: -93.0
        },
        size: {
          width: 600,
          height: 400
        },
        autoFuture: true,
        combine: false
      },
      animation: {
        enabled: true,
        from: -2 * 3600,
        to: 0,
        autoplay: false,
        alwaysShowPast: false,
        alwaysShowFuture: false
      },
      overlays: {
        title: undefined,
        timestamp: 'MM/dd/yyyy hh:mm a',
        branding: {
          html: undefined,
          img: undefined
        }
      },
      legend: {
        enabled: true
      },
      controls: {
        layers: undefined,
        regions: undefined
      }
    }, opts);
    this._target = (0, _DOM.default)(target);
    this._config = new _MapConfig.default(this._opts.map);

    this._config.on('change', () => this.trigger("change"
    /* CHANGE */
    ));

    if (this.account) {
      this._request = new _MapRequest.default({
        server: (0, _utils.get)(this._opts, 'servers.maps'),
        client: this.account.credentials()
      });
    }

    this._layers = new _Layers.default(this.account);

    this._layers.fetch().then(data => {
      this.config.layers = this._layers;
      this.render();
    });
  }
  /**
   * Primary DOM element associated with the view.
   *
   * @readonly
   * @type {*}
   * @memberof MapView
   */


  get $el() {
    return this._target;
  }
  /**
   * DOM element associated with the map.
   *
   * @readonly
   * @type {*}
   * @memberof MapView
   */


  get $map() {
    return this._map;
  }
  /**
   * DOM element associated with the map's container.
   *
   * @readonly
   * @type {*}
   * @memberof MapView
   */


  get $container() {
    return (0, _DOM.default)(`.${_globals.Globals.cssPrefix}map-container`, this.$el);
  }
  /**
   * Aeris account used for the map data requests.
   *
   * @readonly
   * @type {Account}
   * @memberof MapView
   */


  get account() {
    return this.opts.account;
  }
  /**
   * Configuration options for the view.
   *
   * @readonly
   * @type {{ [key: string]: any }}
   * @memberof MapView
   */


  get opts() {
    return this._opts;
  }
  /**
   * Map configuration instance managing the underlying map imagery.
   *
   * @readonly
   * @type {MapConfig}
   * @memberof MapView
   */


  get config() {
    return this._config;
  }
  /**
   * Animation timeline used to control the map view's current time and animation.
   *
   * @readonly
   * @type {Timeline}
   * @memberof MapView
   */


  get timeline() {
    if (this._animator) {
      return this._animator.timeline;
    }

    return null;
  }
  /**
   * Legend view associated with the map.
   *
   * @readonly
   * @type {LegendView}
   * @memberof MapView
   */


  get legend() {
    return this._legend;
  }
  /**
   * Returns the DOM element within the view's container for the specified selector.
   *
   * @param {string} selector
   * @returns {*}
   * @memberof MapView
   */


  el(selector) {
    return (0, _DOM.default)(selector, this.$el);
  }
  /**
   * Sets the map layers.
   *
   * The legend displayed for the specified map layers can be overridden by providing a value for
   * the `legend` parameter, which can either be an array of layer codes for multiple
   * auto-configured legends, or a single URL string for a single legend image.
   *
   * @param {MapConfigLayersOptions} layers
   * @param {string} [legend]
   * @memberof MapView
   */


  setLayers(layers, legend) {
    this.config.setLayers(layers);

    if (legend) {
      this.setLegend(legend);
    }
  }
  /**
   * Sets the legend type(s) or image URL to display. If a source URL is provided, then this
   * image will be displayed regardless of which layer types exist on the map.
   *
   * @param {(string | string[])} source
   * @memberof MapView
   */


  setLegend(source) {
    this._legendUrl = null;

    if (source) {
      if ((0, _utils.isString)(source)) {
        const str = source;

        if (str.match(/^(https?:)?\/\//)) {
          this._legendUrl = str;
          this.legend.setUrl(str);
        } else {
          this.legend.set(str.replace(/\s/g, '').split(','));
        }
      } else if ((0, _utils.isArray)(source)) {
        this.legend.set(source);
      }
    }
  }
  /**
   * Sets the units to display on the map view.
   *
   * @param {boolean} metric
   * @memberof MapView
   */


  setMetric(metric) {
    this.config.setMetric(metric);
  }

  render() {
    this.$el.empty();
    this.$el.html(`
			<div class="awxjs__mapview">
				<ul class="awxjs__map-nav"></ul>
				<div class="awxjs__map-container">
					<div class="awxjs__map">
						<ul class="awxjs__map-region-nav horizontal"></ul>
						<ul class="awxjs__map-anim-controls">
							<li data-anim-action="toggle"><button>Play</button></li>
						</ul>
					</div>
					<div class="awxjs__map-legend"></div>
				</div>
			</div>
		`);
    const opts = this.opts;
    const $map = (0, _DOM.default)(`.${_globals.Globals.cssPrefix}map-container > .${_globals.Globals.cssPrefix}map`, this.$el);
    this._map = $map;
    let w = $map.width() || 320;
    let h = $map.height() || 300;

    if (opts.map.size) {
      w = opts.map.size.width || w;
      h = opts.map.size.height || h;

      if (w === 'auto') {
        w = $map.width();
        opts.map.size.width = w; // enable auto-resizing of map width if configured

        if (opts.map.size.autoscale) {
          (0, _DOM.default)(window).on('resize', e => {
            const nw = $map.width(); // this._map.setWidth(w);

            opts.map.size.width = nw;
          });
        }
      }
    }

    const {
      width,
      height
    } = this.config.size();

    if (width && height) {
      $map.width(width).height(height);
      this.$container.width(width);
    }

    if (opts.map.region && !opts.map.bounds) {
      this.config.setRegion(opts.map.region);
    }

    const overlays = this.opts.overlays;
    const controls = this.opts.controls;
    const anim = this.opts.animation;
    const legend = this.opts.legend;
    this.setupContainers($map);

    if (overlays) {
      this.setupOverlays(overlays);
    }

    if (controls) {
      this.setupControls(controls);
    }

    if (anim) {
      this.setupAnimation(anim);
    }

    if (legend) {
      this.setupLegend(legend);
    }

    this.setupEvents();
    this.trigger("ready"
    /* READY */
    );
    this._ready = true;
    this.updateGroups();
  }

  setupEvents() {
    this.config.on('change:data change:offset', e => {
      this.updateGroups(['past', 'future']);
    });
    this.config.on('change:units', e => {
      this.updateGroups(['pastText', 'futureText']);
    });
    this.config.on('change:data', this.handleLayerChange);
    this.config.on('change:bounds change:size', e => {
      this.updateGroups();
    });
    this.config.on('change:size', e => {
      const {
        width,
        height
      } = e.data;

      if (width && height) {
        this.$map.width(width).height(height);
        this.$container.width(width);
      }
    });

    if (!this.timeline) {
      this.config.on('change:offset', this.handleOffsetChange);
      this.config.setOffset(this.config.offset());
    }

    if (this._timestamp && this.timeline) {
      const ts = this._timestamp;

      if (ts.continuous() === false) {
        this.timeline.on('advance:image', e => {
          ts.update(e.data.time);
        });
      } else {
        this.timeline.on('advance', e => {
          ts.update(e.data.time);
        });
      } // since our main animation is a timeline of combined animations, we need to listen for loading progress on either the past or
      // future animation instance within the timeline to update the timestamp; we can't do both since both will load concurrently if the
      // timeline spans past and future time periods


      if (this.timeline instanceof _Timeline.default) {
        Object.keys(this.timeline.animations).forEach(key => {
          const targetAnim = this.timeline.get(key);
          let target;

          if (targetAnim.isEnabled()) {
            if (key === 'past') {
              target = targetAnim;
            } else if (key === 'future') {
              target = targetAnim;
            }
          }

          if (target) {
            target.on('load:progress', e => {
              if (target.canShow()) {
                ts.update(e.data.time);
              }
            });
          }
        });
      }
    }
  }

  setupContainers($map) {
    const layersSel = `${_globals.Globals.cssPrefix}map__layers`;
    $map.append(`<div class="${layersSel}"></div>`);
    const $layers = this.el(`.${layersSel}`);
    this._indicator = new _ActivityIndicator.default();

    this._indicator.appendTo($layers[0]);

    this.on('load:start', () => {
      this._indicator.startAnimating();
    });
    this.on('load:done', () => {
      this._indicator.stopAnimating();
    }); // map.ext.append(this._indicator.element);

    const containerKeys = this.opts.map.combine ? containers.combined : containers.split; // create separate containers for base, past, future and overlay layers so we only have to animate content in the past and future layers

    const targets = {};
    containerKeys.forEach((key, i) => {
      const sel = `${_globals.Globals.cssPrefix}map-layer-${key}`;
      $layers.append(`<div class="${sel}"></div>`);
      const storeKey = (0, _strings.camelcase)(key);
      const $target = (0, _DOM.default)(`.${sel}`, $layers);
      $target.css({
        position: 'absolute',
        top: 0,
        left: 0,
        bottom: 0,
        right: 0,
        "z-index": i
      });
      targets[storeKey] = $target;
    });
    this._targets = targets;
  }

  setupControls(config) {
    if (config.layers) {
      const $target = this.el(`.${_globals.Globals.cssPrefix}map-nav`);
      config.layers.forEach(layer => {
        $target.append(`<li data-map-layer="${layer.value}"><button>${layer.title}</button></li>`);
      });
      const $buttons = (0, _DOM.default)('li', $target);
      $buttons.on('click', e => {
        e.preventDefault();
        const $el = e.target.tagName.toLowerCase() === 'button' ? (0, _DOM.default)(e.target).parent() : (0, _DOM.default)(e.target);
        const layers = $el.allData('map-layer');
        $buttons.removeClass('selected');
        $el.addClass('selected');

        if (layers) {
          this.config.setData(layers.split(','));
        }
      }); // select initial button based on config options

      this.on('ready', e => {
        const initialLayers = (0, _utils.get)(this.opts, 'map.layers.data') || null;

        if (initialLayers) {
          $buttons.each((el, i) => {
            const $btn = (0, _DOM.default)(el);

            if ($btn.allData('map-layer') === initialLayers.join(',')) {
              $btn.click();
            } else if (i === 0) {
              $btn.click();
            }
          });
        } else {
          $buttons.get(0).click();
        }
      });
    }

    if (config.regions) {
      const self = this;
      const $target = this.el(`.${_globals.Globals.cssPrefix}map-region-nav`);
      config.regions.forEach(region => {
        const data = Object.keys(region).reduce((prev, current) => {
          if (current !== 'title') {
            let val = region[current];

            if ((0, _utils.isObject)(val)) {
              if (current === 'center') {
                val = `${val.lat},${val.lon}`;
              } else if (current === 'bounds') {
                val = `${val.north},${val.west},${val.south},${val.east}`;
              }
            }

            prev.push(`data-map-${current}="${val}"`);
          }

          return prev;
        }, []);
        $target.append(`<li ${data.join(' ')}><button>${region.title}</button></li>`);
      });
      const $buttons = (0, _DOM.default)('li', $target);
      $buttons.on('click', e => {
        e.preventDefault();
        const $el = e.target.tagName.toLowerCase() === 'button' ? (0, _DOM.default)(e.target).parent() : (0, _DOM.default)(e.target);
        const zoom = $el.allData('map-zoom');
        const center = $el.allData('map-center') || (0, _utils.get)(this.opts, 'map.center');
        const region = $el.allData('map-region');
        const bounds = $el.allData('map-bounds');
        $buttons.removeClass('selected');
        $el.addClass('selected');

        if (region) {
          self.config.setRegion(region);
        } else if (bounds) {
          const b = bounds.split(',');

          if (b.length === 4) {
            self.config.setBounds({
              north: b[0],
              west: b[1],
              south: b[2],
              east: b[3]
            });
          }
        } else if (center && !(0, _utils.isEmpty)(center)) {
          if ((0, _utils.isset)(zoom) && zoom > 0) {
            self.config.setCenter(center, zoom);
          } else {
            self.config.setCenter(center, this.config.zoom());
          }
        } else if (zoom > 0) {
          self.config.setZoom(zoom);
        }
      }); // select initial button based on config options

      this.on('ready', e => {
        const initialZoom = (0, _utils.get)(this.opts, 'map.zoom') || null;

        if ((0, _utils.isset)(initialZoom)) {
          $buttons.each((el, i) => {
            const $btn = (0, _DOM.default)(el);

            if ($btn.allData('map-zoom') === `${initialZoom}`) {
              $btn.click();
            } else if (i === 0) {
              $btn.click();
            }
          });
        } else {
          $buttons.get(0).click();
        }
      });
    }
  }

  setupOverlays(config) {
    const layersSel = `${_globals.Globals.cssPrefix}map__overlays`;
    this.$map.append(`<div class="${layersSel}"></div>`);
    const $target = this.el(`.${layersSel}`); // map timestamp

    if (config.timestamp) {
      let opts = config.timestamp;

      if ((0, _utils.isString)(opts)) {
        opts = {
          format: opts
        };
      }

      const timestamp = new MapTimestamp(opts);
      timestamp.element.css({
        "z-index": 10
      });
      $target.append(timestamp.element);
      this._timestamp = timestamp;
    } // map title


    if (config.title) {
      const sel = `${_globals.Globals.cssPrefix}map-overlay__title`;
      $target.append(`<div class="${sel}">${config.title}</div>`);
      (0, _DOM.default)(`.${sel}`, $target).css({
        "z-index": 11
      });
    } // map branding


    if (config.branding) {
      const {
        img,
        html
      } = config.branding;
      const sel = `${_globals.Globals.cssPrefix}map-overlay__branding`;
      $target.append(`<div class="${sel}"></div>`);
      const $branding = (0, _DOM.default)(`.${sel}`, $target);
      $branding.css({
        "z-index": 12
      });

      if ((0, _utils.isset)(img)) {
        $branding.html(`<img src="${img}" />`);
      } else if ((0, _utils.isset)(html)) {
        $branding.html(html);
      }
    }
  }

  setupAnimation(config) {
    const $controls = this.el('.awxjs__map-anim-controls > li'); // const $btnAnimate = $('li', $controls);
    // if animation is disabled, we only use the `animation.to` value so update the `from` value to match

    if (!config.enabled) {
      this.config.setOffset((0, _utils.get)(this.opts, 'map.offset') || 0);
      $controls.remove();
      return;
    }

    const animator = new _MapViewAnimator.default({
      past: this._targets.past,
      future: this._targets.future,
      pastText: this._targets.pastText,
      futureText: this._targets.futureText
    }, config);
    animator.provider = this;
    this._animator = animator;
    const timeline = animator.timeline; // show activity indicator while animation data is loading

    timeline.on('load:start', () => {
      this._indicator.startAnimating();
    });
    timeline.on('load:done load:error', () => {
      this._indicator.stopAnimating();
    }); // disable future layers for map if animation doesn't extend into the future

    this.config.opts('autoFuture', timeline.containsFuture());
    timeline.on('end:change', e => {
      this.config.opts('autoFuture', timeline.containsFuture());
    });
    timeline.on('start:change end:change', e => {
      // show or hide animate button based on whether animation can actually animate
      if (timeline.canAnimate()) {
        $controls.show();
      } else {
        $controls.hide();
      }
    });

    if (!timeline.canAnimate()) {
      $controls.hide();
    }

    this.on('ready', () => {
      // need to reset animation and clear its image cache if the map's data layers change
      this.config.on('change:data change:size change:zoom change:offset change:center change:bounds', e => {// timeline.reset();
      });
      this.config.on('change:units', e => {
        timeline.stop();
        const pastTextAnim = timeline.get('pastText');

        if (pastTextAnim) {
          pastTextAnim.reset();
        }

        const futureTextAnim = timeline.get('futureText');

        if (futureTextAnim) {
          futureTextAnim.reset();
        }
      });
      timeline.goToInit();

      if (timeline.isAutoPlay()) {
        this.once("load:done"
        /* LOAD_DONE */
        , () => {
          setTimeout(() => {
            timeline.play();
          }, 500);
        });
      }
    }); // // toggle animation when clicking on layers container
    // $layers.on('click', (e: any) => {
    // 	this.timeline.toggle();
    // });

    $controls.each(el => {
      const $el = (0, _DOM.default)(el);
      const action = $el.allData('anim-action');

      if (action === 'toggle') {
        const $btn = (0, _DOM.default)('button', $el);
        timeline.on('play load:start', () => {
          $btn.html('Stop');
        });
        timeline.on('stop', () => {
          $btn.html('Play');
        });
      }
    }).on('click', e => {
      e.preventDefault();
      const $el = e.target.tagName.toLowerCase() === 'button' ? (0, _DOM.default)(e.target).parent() : (0, _DOM.default)(e.target);
      const action = $el.allData('anim-action');

      if (action === 'toggle') {
        timeline.toggle();
      } else if (action === 'play') {
        timeline.play();
      } else if (action === 'pause') {
        timeline.pause();
      } else if (action === 'stop') {
        timeline.stop();
      }
    });
  }

  setupLegend(config) {
    const $legend = this.el('.awxjs__map-legend');

    if (!config.enabled) {
      $legend.remove();
      return;
    }

    const legend = new _LegendView.default($legend, (0, _utils.extend)({
      size: {
        width: this.$map.width()
      }
    }, config));
    this._legend = legend;
    const update = (0, _utils.debounce)(() => {
      // don't update legend based on map layer types if we have defined a value for _legendSource
      if (this._legendUrl) return;
      const layers = this.config.data();
      const opts = {
        account: this.account
      }; // if active layers contains `alerts`, we need to pass the maps current bounds, size and zoom to be used
      // to request a filtered version of the advisories legend just for the map region

      if (layers && layers.indexOf('alerts') !== -1) {
        opts.within = {
          bounds: this.config.bounds(),
          center: this.config.center(),
          zoom: this.config.zoom(),
          size: this.config.size()
        };
      }

      legend.set(layers, opts);
    }, 50);
    this.config.on('change:data change:bounds', e => {
      update();
    });
    this.config.on('change:size', e => {
      legend.setWidth(e.data.width);
    });
    this.config.on('change:metric', e => {
      legend.setMetric(e.data.metric);
    });
    update();
  }
  /*
   * Image Methods
   */


  setImage(type, url) {
    const target = (0, _DOM.default)(`.${_globals.Globals.cssPrefix}map-layer-${type}`, this.$el);

    if (target) {
      target.empty();

      if (url) {
        target.append(`<img src="${url}" width="${this.config.size().width}" height="${this.config.size().height}">`);
      }
    }
  }

  updateGroups(groups) {
    groups = groups || ['base', 'past', 'future', 'overlays'];
    groups.forEach(group => {
      if (this._loadingGroups.indexOf(group) === -1) {
        this._loadingGroups.push(group);
      }
    });
    this.update();
  }

  _adjustTypesForUpdate(types) {
    const filtered = types.splice(0);
    const now = new Date().getTime();

    if (this.timeline && this.timeline.isEnabled()) {
      // remove `past` if animation's start time doesn't start in the past
      const pastIndex = filtered.indexOf('past');

      if (pastIndex > -1 && this.timeline.startDate().getTime() > now) {
        filtered.splice(pastIndex, 1);
      } // remove `future` if animation's end time doesn't extend beyond now


      const futureIndex = filtered.indexOf('future');

      if (futureIndex > -1 && this.timeline.endDate().getTime() <= now && this._animator.timeline.get('future').canShow() === false) {
        filtered.splice(futureIndex, 1);
      }
    }

    if (this.config.hasText()) {
      if (filtered.indexOf('past') > -1) {
        filtered.push('pastText');
      }

      if (filtered.indexOf('future') > -1) {
        filtered.push('futureText');
      }
    }

    return filtered;
  }
  /*
   * ImageAnimationProvider
   */


  animationUrlForDate(animation, date) {
    const request = this._request.clone();

    const group = /text$/i.test(animation.key) ? 'text' : 'data';
    const options = this.config.toRequestOpts([group], animation.isFuture());

    if (group === 'data' && (0, _utils.isset)(options.layers.data) || group === 'text' && (0, _utils.isset)(options.layers.text)) {
      request.setParams(options);
      request.date(date);
      return request.url();
    }

    return null;
  }

  animationSizeForImage(animation) {
    return this.config.size();
  }

}

var _default = MapView;
exports.default = _default;
module.exports = exports.default;