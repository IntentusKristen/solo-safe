"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _EventDispatcher = _interopRequireDefault(require("../../../event/EventDispatcher"));

var _Regions = require("../../Regions");

var _utils = require("../../../utils");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const timestampFromDate = date => {
  const gmtDate = new Date(date.getTime() + date.getTimezoneOffset() * 60 * 1000);
  return (0, _utils.formatDate)(gmtDate, 'yyyyMMddHHmm00');
};
/**
 * A map configuration object stores and manages various map-related options associated with a
 * `MapView` instance.
 *
 * @export
 * @class MapConfig
 * @extends {EventDispatcher}
 */


class MapConfig extends _EventDispatcher.default {
  /**
   * Initializes and returns a map configuration instance for the specified map options.
   *
   * @param {MapConfigOptions} [opts=undefined]
   * @memberof MapConfig
   */
  constructor(opts = undefined) {
    super();
    /**
     * @ignore
     * Called when any configuration property changes.
     *
     * @private
     * @memberof MapConfig
     */

    this.onChange = (0, _utils.debounce)(() => {
      // // only trigger change event if we have a valid location, which prevents warning messages to the console if non-data changes
      // // occur before a location is specified for the map
      // if (this.hasLocation()) {
      // 	this.trigger('change');
      // }
      this.trigger('change');
    }, 500);
    this._opts = (0, _utils.extend)({}, {
      layers: {
        base: undefined,
        data: undefined,
        overlays: undefined,
        text: undefined
      },
      center: undefined,
      zoom: 3,
      bounds: undefined,
      size: {
        width: 600,
        height: 400
      },
      offset: '0',
      date: undefined,
      autoFuture: true,
      combined: false,
      metric: false
    }, opts);
  }
  /**
   * Aeris Maps (AMP) layers metadata.
   *
   * @type {Layers}
   * @memberof MapConfig
   */


  get layers() {
    return this._layers;
  }

  set layers(layers) {
    this._layers = layers;
  }
  /**
   * Returns or sets an option by key.
   *
   * @param {string} key
   * @param {*} [value]
   * @returns {*}
   * @memberof MapConfig
   */


  opts(key, value) {
    if ((0, _utils.isset)(value)) {
      (0, _utils.set)(this._opts, key, value);
      return null;
    }

    return (0, _utils.get)(this._opts, key);
  }
  /*
   * Layers
   */

  /**
   * Returns the data layer codes.
   *
   * @returns {*}
   * @memberof MapConfig
   */


  data() {
    return this.opts('layers.data');
  }
  /**
   * Sets the data layer codes.
   *
   * @param {string[]} data
   * @returns {MapConfig}
   * @memberof MapConfig
   */


  setData(data) {
    if (!this._opts.combined) {
      const text = [];
      const layers = [];
      data.forEach(layer => {
        if (/-text-?/.test(layer) && this.layers.inGroup(layer, 'text')) {
          text.push(layer);
        } else {
          layers.push(layer);
        }
      });
      this.opts('layers.data', layers);
      this.opts('layers.text', text);
    } else {
      this.opts('layers.data', data);
    }

    this.trigger('change:data', {
      data
    });
    this.onChange();
    return this;
  }
  /**
   * Returns the base layer codes.
   *
   * @returns {*}
   * @memberof MapConfig
   */


  base() {
    return this.opts('layers.base');
  }
  /**
   * Sets the base layer codes.
   *
   * @param {string[]} base
   * @returns {MapConfig}
   * @memberof MapConfig
   */


  setBase(base) {
    this.opts('layers.base', base);
    this.trigger('change:base', {
      base
    });
    this.onChange();
    return this;
  }
  /**
   * Returns the overlay layer codes.
   *
   * @returns {*}
   * @memberof MapConfig
   */


  overlays() {
    return this.opts('layers.overlays');
  }
  /**
   * Sets the overlay layer codes.
   *
   * @param {string[]} overlays
   * @returns {MapConfig}
   * @memberof MapConfig
   */


  setOverlays(overlays) {
    this.opts('layers.overlays', overlays);
    this.trigger('change:overlays', {
      overlays
    });
    this.onChange();
    return this;
  }
  /**
   * Returns whether the layer configuration contains overlay layer codes.
   *
   * @returns {boolean}
   * @memberof MapConfig
   */


  hasOverlays() {
    const overlays = this.overlays();
    return overlays && !(0, _utils.isEmpty)(overlays);
  }
  /**
   * Returns the text layer codes.
   *
   * @returns {*}
   * @memberof MapConfig
   */


  text() {
    return this.opts('layers.text');
  }
  /**
   * Sets the text layer codes.
   *
   * @param {string[]} text
   * @returns {MapConfig}
   * @memberof MapConfig
   */


  setText(text) {
    this.opts('layers.text', text);
    this.trigger('change:text', {
      text
    });
    this.onChange();
    return this;
  }
  /**
   * Returns whether the layer configuration contains text layer codes.
   *
   * @returns {boolean}
   * @memberof MapConfig
   */


  hasText() {
    const text = this.text();
    return text && !(0, _utils.isEmpty)(text);
  }
  /**
   * Sets all layer codes grouped by category.
   *
   * @param {MapConfigLayersOptions} layers
   * @returns {MapConfig}
   * @memberof MapConfig
   */


  setLayers(layers) {
    layers = layers || {};
    if (layers.base) this.setBase(layers.base);
    if (layers.data) this.setData(layers.data);
    if (layers.overlays) this.setOverlays(layers.overlays);
    if (layers.text) this.setText(layers.text);
    return this;
  }
  /**
   * Returns the time offset.
   *
   * @returns {string}
   * @memberof MapConfig
   */


  offset() {
    return this.opts('offset');
  }
  /**
   * Sets the time offset.
   *
   * @param {string} offset
   * @returns {MapConfig}
   * @memberof MapConfig
   */


  setOffset(offset) {
    this.opts('offset', `${offset}`);
    this.trigger('change:offset', {
      offset
    });
    this.onChange();
    return this;
  }

  setDate(date) {
    if (date instanceof Date) {
      this.setOffset(timestampFromDate(date));
    } else {
      this.setOffset(`${date}`);
    }
  }
  /*
   * Center and Zoom
   */

  /**
   * Returns the center place string or coordinate object.
   *
   * @returns {(string | Coordinate)}
   * @memberof MapConfig
   */


  center() {
    const center = this.opts('center');

    if (center) {
      if (/^[\d\.-]+,[\d\.-]+$/.test(center)) {
        const coord = center.split(',');

        if (coord && coord.length === 2) {
          return {
            lat: parseFloat(coord[0]),
            lon: parseFloat(coord[1])
          };
        }
      }
    }

    return center;
  }
  /**
   * Sets the center place string or coordinate object.
   *
   * @param {(Coordinate | string)} center
   * @param {number} [zoom=null]
   * @returns {MapConfig}
   * @memberof MapConfig
   */


  setCenter(center, zoom = null) {
    if ((0, _utils.isPlainObject)(center)) {
      const coord = center;
      center = `${coord.lat},${coord.lon}`;
    }

    this.opts('center', center);
    delete this._opts.bounds;

    if (zoom >= 0) {
      this.opts('zoom', zoom);
    }

    this.trigger('change:center');
    this.trigger('change:bounds');
    this.onChange();
    return this;
  }
  /**
   * Returns the zoom level.
   *
   * @returns {number}
   * @memberof MapConfig
   */


  zoom() {
    return this.opts('zoom');
  }
  /**
   * Sets the zoom level.
   *
   * @param {number} zoom
   * @returns {MapConfig}
   * @memberof MapConfig
   */


  setZoom(zoom) {
    this.opts('zoom', zoom);
    this.trigger('change:zoom');
    this.trigger('change:bounds');
    this.onChange();
    return this;
  }
  /**
   * Returns the coordinate bounds.
   *
   * @returns {GeoBounds}
   * @memberof MapConfig
   */


  bounds() {
    return this.opts('bounds');
  }
  /**
   * Sets the coordinate bounds.
   *
   * @param {GeoBounds} bounds
   * @returns {MapConfig}
   * @memberof MapConfig
   */


  setBounds(bounds) {
    this.opts('bounds', bounds);
    delete this._opts.center;
    this.trigger('change:bounds');
    this.onChange();
    return this;
  }
  /**
   * Sets the center or coordinate bounds based on the specified region code.
   *
   * @param {string} key
   * @returns {MapConfig}
   * @memberof MapConfig
   * @see Regions
   */


  setRegion(key) {
    const region = _Regions.Regions.get(key);

    if (region) {
      if (region.center) {
        this.setCenter(`${region.center.lat},${region.center.lon}`, this.zoom());
      } else if (region.bounds) {
        this.setBounds(region.bounds);
      }
    }

    return this;
  }
  /*
   * Size
   */

  /**
   * Returns the image size.
   *
   * @returns {Size}
   * @memberof MapConfig
   */


  size() {
    const size = this.opts('size');

    if (size && size.width && size.height) {
      return {
        width: size.width,
        height: size.height
      };
    }

    return null;
  }
  /**
   * Sets the image size.
   *
   * @param {number} width
   * @param {number | 'auto'} height
   * @returns {MapConfig}
   * @memberof MapConfig
   */


  setSize(width, height) {
    if (height === 'auto') {
      // calculate height if we have a scale factor for the height to retain same image aspect ratio
      const factor = this.opts('size.factor');

      if (factor) {
        height = Math.round(width * factor);
      }
    }

    this._opts.size = {
      width,
      height
    };
    this.trigger('change:size', this.size());
    this.trigger('change:bounds');
    this.onChange();
    return this;
  }
  /**
   * Returns whether to use Metric units for text layers.
   *
   * @returns {boolean}
   * @memberof MapConfig
   */


  metric() {
    return this.opts('metric');
  }
  /**
   * Sets whether to use Metric units for text layers.
   *
   * @param {boolean} metric
   * @returns {MapConfig}
   * @memberof MapConfig
   */


  setMetric(metric) {
    this.opts('metric', metric);
    this.trigger('change:metric', {
      metric
    });
    this.onChange();
    return this;
  }
  /**
   * Returns an object of `MapRequest` options to use for the image request from the current
   * configuration.
   *
   * @param {string[]} [groups]
   * @param {boolean} [future=false]
   * @returns {{ [key: string]: any }}
   * @memberof MapConfig
   */


  toRequestOpts(groups, future = false) {
    groups = groups || ['base', 'data', 'overlays', 'text']; // let data = groups.indexOf('data') !== -1 ? this.data() : null;

    let layerCodes = [];
    groups.forEach(group => {
      const clayers = this.opts(`layers.${group}`);
      if (!(0, _utils.isEmpty)(clayers)) layerCodes = layerCodes.concat(clayers);
    });

    if (layerCodes) {
      let filtered = [...layerCodes]; // determine if we need imperial or metric text layers based on current units

      if (groups.indexOf('text') > -1) {
        filtered = filtered.map(value => {
          if (/-text-?/.test(value) && this.layers.hasMetric(value)) {
            const text = this.opts('metric') ? 'text-metric' : 'text';
            const matches = value.match(/^([\w-]+-text)(-metric)?(-(dk|lg)){0,2}/);
            const code = matches[1].replace(/-text.*$/, '');
            const modifiers = matches[3] || '';
            return `${code}-${text}${modifiers}`;
          }

          return value.replace(/-metric/, '');
        });
      } // reduce layers.data and layers.text to either past or future layers depending on
      // value of `opts.future`


      if (groups.indexOf('data') !== -1 || groups.indexOf('text') !== -1) {
        const futureLayers = this.layers.future();
        const futureLayerCodes = this.layers.futureCodes(); // if `opts.autoFuture` is enabled, iterate through data types and automatically
        // include the future layer type that corresponds with it

        if (this.opts('autoFuture')) {
          layerCodes.forEach(id => {
            const futureLayer = this.layers.find('id', `f${id}`, true);

            if (futureLayer && filtered.indexOf(futureLayer.id) === -1) {
              filtered.splice(layerCodes.indexOf(id) + 1, 0, futureLayer.id);
            }
          });
        }

        const isFuture = code => {
          let match = futureLayerCodes.indexOf(code) !== -1;

          if (!match) {
            futureLayerCodes.forEach(id => {
              const re = new RegExp(`^${id}-`);

              if (!match && re.test(code)) {
                match = true;
              }
            });
          }

          return match;
        };

        filtered = filtered.filter(id => {
          // allow overlays and masks to be included with either past or future layers
          if (this.layers.inGroup(id, 'overlay') || this.layers.inGroup(id, 'masks')) {
            return true;
          }

          return future ? isFuture(id) : !isFuture(id);
        });
      }

      if (filtered.length === 0) {
        layerCodes = null;
      } else {
        layerCodes = filtered;
      }
    }

    let center = this.center();

    if ((0, _utils.isPlainObject)(center)) {
      const coord = center;
      center = `${coord.lat},${coord.lon}`;
    }

    return {
      layers: {
        base: groups.indexOf('base') !== -1 ? this.base() : null,
        data: groups.indexOf('data') !== -1 ? layerCodes : null,
        overlays: groups.indexOf('overlays') !== -1 ? this.overlays() : null,
        text: groups.indexOf('text') !== -1 ? layerCodes : null
      },
      p: center,
      zoom: this.zoom(),
      bounds: this.bounds(),
      size: this.size(),
      offset: this.offset(),
      metric: this.metric(),
      format: 'png'
    };
  }

}

var _default = MapConfig;
exports.default = _default;
module.exports = exports.default;