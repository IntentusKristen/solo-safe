"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.isValidLayer = exports.getInvalidLayers = exports.isTile = exports.isText = exports.isVector = exports.isShape = exports.isPoint = void 0;

var _EventDispatcher = _interopRequireDefault(require("../event/EventDispatcher"));

var _Http = _interopRequireDefault(require("../network/Http"));

var _utils = require("../utils");

var _LayerTimes = _interopRequireDefault(require("./LayerTimes"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @ignore
 */
let _data;

let _modifiers = [];
const pointLayers = ['air-quality', 'earthquakes', 'fires', 'records', 'river-observations', 'stormreports'];

const isPoint = layer => pointLayers.indexOf(layer) !== -1;

exports.isPoint = isPoint;
const shapeLayers = ['convective', 'drought-monitor', 'fire-outlook', 'tropical-cyclones-break-points'];

const isShape = layer => shapeLayers.indexOf(layer) !== -1;

exports.isShape = isShape;
const vectorLayers = pointLayers.concat(shapeLayers).concat(['stormcells', 'tropical-cyclones']);

const isVector = layer => vectorLayers.indexOf(layer) !== -1;

exports.isVector = isVector;
const textLayers = ['observations'];

const isText = layer => textLayers.indexOf(layer) !== -1;

exports.isText = isText;

const isTile = layer => !isVector(layer) && !isText(layer);

exports.isTile = isTile;

const getInvalidLayers = layer => {
  if (!(0, _utils.isset)(layer) || !(0, _utils.isString)(layer)) return [];
  layer = layer.replace(/\:.+$/, '');

  const ids = (_data || []).map(config => config.id);

  const layers = (layer || '').split(',');
  const codes = []; // iterate through each layer code and check if it exists in the allowed layer ids
  // if not, then strip off each valid modifier to use as the code check

  layers.forEach(code => {
    if (ids.indexOf(code) === -1) {
      _modifiers.forEach(m => {
        code = code.replace(new RegExp(`-${m}`), '');
      });
    }

    codes.push(code);
  });
  const matches = [];
  codes.forEach(code => {
    code = code.replace(/\:.*$/, '');
    const found = ids.indexOf(code) !== -1 || isVector(code) || isText(code);

    if (!found) {
      matches.push(code);
    }
  });
  return matches;
};

exports.getInvalidLayers = getInvalidLayers;

const isValidLayer = layer => {
  const matches = getInvalidLayers(layer);
  return matches.length === 0;
};
/**
 * A `Layers` object is responsible for fetching and caching Aeris Maps (AMP) layers metadata as
 * well as providing utility methods for returning and comparing layer information.
 *
 * @export
 * @class Layers
 * @extends {EventDispatcher}
 */


exports.isValidLayer = isValidLayer;

class Layers extends _EventDispatcher.default {
  /**
   * Initializes and returns a new Layers instance.
   *
   * Layer metadata will be requested immediate if it has not already been cached by the library.
   *
   * @memberof Layers
   */
  constructor(account) {
    super();
    this._groups = {};
    this._loading = false;
    this._validTimes = new _LayerTimes.default(account);

    if ((0, _utils.isset)(_data)) {
      this._process(_data);
    } else {
      this.fetch();
    }
  }
  /**
   * Returns the `LayerTimes` instance that can be used to fetch and return the valid times for
   * AerisWeather Maps layers.
   *
   * @readonly
   * @type {LayerTimes}
   * @memberof Layers
   */


  get validTimes() {
    return this._validTimes;
  }
  /**
   * Return the layer metadata.
   *
   * If the data has not already been loaded and cached, this method will perform a new
   * request before resolving the Promise with the data.
   *
   * @returns
   * @memberof Layers
   */


  fetch() {
    return new Promise((resolve, reject) => {
      // always return a copy of our _data object in case callers try to change the data contained within
      if (_data) {
        resolve((0, _utils.cloneDeep)(_data));
      } else if (this._loading) {
        this.on('load:done', e => {
          resolve((0, _utils.cloneDeep)(_data));
        });
      } else {
        this._fetchLayerMetadata().then(data => {
          resolve((0, _utils.cloneDeep)(_data));
        });
      }
    }).catch(e => {
      console.error(`[Aeris] Failed to load map layer metadata - ${e}`);
    });
  }
  /**
   * Returns whether layer metadata is already cached.
   *
   * @returns {boolean}
   * @memberof Layers
   */


  cached() {
    return _data !== undefined;
  }
  /**
   * Returns whether layer metadata is currently being requested.
   *
   * @returns {boolean}
   * @memberof Layers
   */


  loading() {
    return this._loading;
  }
  /**
   * Returns the layer groups.
   *
   * @returns {*}
   * @memberof Layers
   */


  groups() {
    return this._groups;
  }
  /**
   * Returns whether the layer for the identifier is part of the specified group.
   *
   * If `strict` is `true`, then the check will perform an equal comparison rather than a simple
   * pattern match.
   *
   * @param {string} id
   * @param {string} group
   * @param {boolean} [strict=false]
   * @returns {boolean}
   * @memberof Layers
   */


  inGroup(id, group, strict = false) {
    const groupLayers = this._groups[group];
    id = id.replace(/:.*$/, '');

    if (groupLayers) {
      if (strict) {
        return groupLayers.indexOf(id) !== -1;
      }

      let found = false;
      groupLayers.forEach(code => {
        const re = new RegExp(`^${code}-`); // support for modifiers in values layers array

        if (code === id || re.test(id)) {
          found = true;
        }
      });
      return found;
    }

    return false;
  }
  /**
   * Returns whether the specified layer exists within AMP.
   *
   * @param {string} layer
   * @returns {boolean}
   * @memberof Layers
   */


  exists(layer) {
    return isValidLayer(layer);
  }
  /**
   * Returns the layer metadata that matches the query based on the specified property and value.
   *
   * If `strict` is `true`, then the check will perform an equal comparison rather than a simple
   * pattern match.
   *
   * @param {string} prop
   * @param {*} value
   * @param {boolean} [strict=false]
   * @returns {LayerConfig}
   * @memberof Layers
   */


  find(prop, value, strict = false) {
    const results = this.findAll(prop, [value], strict);

    if (results.length > 0) {
      return results[0];
    }

    return undefined;
  }
  /**
   * Returns an array of layer metadata for all layers that match the query based on the
   * specified property and values.
   *
   * If `strict` is `true`, then the check will perform an equal comparison rather than a simple
   * pattern match.
   *
   * @param {string} prop
   * @param {string[]} values
   * @param {boolean} [strict=false]
   * @returns {LayerConfig[]}
   * @memberof Layers
   */


  findAll(prop, values, strict = false) {
    const data = _data;
    const layers = [];
    values = values || [];

    if (data) {
      values.forEach(value => {
        data.forEach((layer, i) => {
          const layerVal = layer[prop];
          let match = layerVal === value;

          if (!match) {
            const re = new RegExp(`^${layerVal}-`); // support for modifiers in values layers array

            let modifiers = (layer.modifiers || []).map(modifier => [].concat((modifier.options || []).map(opt => `${layer.id}-${opt.id}`)));
            modifiers = modifiers.length > 0 ? modifiers[0] : modifiers;

            if (prop === 'id') {
              if (!strict) {
                match = re.test(value);
              } else {
                match = modifiers.indexOf(value) !== -1;
              }
            }
          }

          if (match) {
            if (prop === 'id') {
              layer = (0, _utils.extend)((0, _utils.cloneDeep)(layer), {
                id: value
              });
            }

            layers.push(layer);
          }
        });
      });
    }

    return (0, _utils.cloneDeep)(layers);
  }

  findInvalidIds(ids) {
    const str = (0, _utils.isArray)(ids) ? ids.join(',') : ids;
    return getInvalidLayers(str);
  }
  /**
   * Returns an array of future layer metadata.
   *
   * @returns {LayerConfig[]}
   * @memberof Layers
   */


  future() {
    if (!this._future) {
      const futureLayers = this.findAll('category', ['forecasts', 'models', 'outlooks']); // future radar and satellite are in rad/sat category, so add them manually

      futureLayers.push(this.find('id', 'fradar'));
      futureLayers.push(this.find('id', 'fsatellite'));
      this._future = futureLayers;
    }

    return this._future;
  }
  /**
   * Returns an array of future layer identifiers.
   *
   * @returns {string[]}
   * @memberof Layers
   */


  futureCodes() {
    return this.future().map(layer => layer ? layer.id : undefined);
  }
  /**
   * Returns whether the specified layer identifier is a future layer.
   *
   * @param {string} id
   * @returns {boolean}
   * @memberof Layers
   */


  isFuture(id) {
    let match = false; // iterate through multiple layers if combined string is provided

    if (id.indexOf(',') >= 0) {
      return this._checkCombined(id, code => this.isFuture(code));
    }

    const codes = this.futureCodes();
    let stripped = id.replace(/:.*$/, '');
    match = codes.indexOf(stripped) !== -1;

    if (!match) {
      stripped = stripped.replace(/\-\w+$/, '');
      match = codes.indexOf(stripped) !== -1;
    }

    return match;
  }
  /**
   * Returns whether the specified layer identifier is a base layer.
   *
   * @param {string} id
   * @returns {boolean}
   * @memberof Layers
   */


  isBase(id) {
    const stripped = id.replace(/:.*$/, '');
    return this.inGroup(stripped, 'base');
  }
  /**
   * Returns whether the specified layer identifier is an overlay layer.
   *
   * @param {string} id
   * @returns {boolean}
   * @memberof Layers
   */


  isOverlay(id) {
    const stripped = id.replace(/:.*$/, '');
    return this.inGroup(stripped, 'overlay') || this.inGroup(stripped, 'masks');
  }
  /**
   * Returns whether the specified layer identifier has metric data, specifically for text
   * layers.
   *
   * @param {string} id
   * @returns {boolean}
   * @memberof Layers
   */


  hasMetric(id) {
    if (this.inGroup(id, 'text')) {
      return /^f?humidity-/.test(id) === false;
    }

    return false;
  }

  _checkCombined(id, validator) {
    let match = false;
    (id || '').split(',').forEach(code => {
      const result = validator(code);

      if (result) {
        match = true;
      }
    });
    return match;
  }

  _process(json) {
    if (!json) return;
    const groups = {};
    _modifiers = [];
    json.forEach(el => {
      let cat = el.category; // catch to handle new category names in layers.json source that aren't what we expect

      if (cat.match(/^base/)) {
        cat = 'base';
      } else if (cat.match(/overlay/)) {
        cat = 'overlay';
      }

      if (groups[cat] === undefined) {
        groups[cat] = [];
      }

      groups[cat].push(el.id); // also add this layer to 'text' group if it's a text layer

      if (/-text$/.test(el.id)) {
        if (groups.text === undefined) {
          groups.text = [];
        }

        groups.text.push(el.id);
      }

      if (el.modifiers && (0, _utils.isArray)(el.modifiers)) {
        el.modifiers.forEach(modifier => {
          if (modifier.options) {
            modifier.options.forEach(option => {
              if (_modifiers.indexOf(option.id) === -1) {
                _modifiers.push(option.id);
              }
            });
          }
        });
      }
    });

    _modifiers.push('aeris');

    this._groups = groups;
  }

  _fetchLayerMetadata() {
    this._loading = true;
    this.trigger('load:start');
    return new Promise((resolve, reject) => {
      _Http.default.request('https://cdn.aerisjs.com/layers.json').then(res => {
        if (res.data) {
          _data = res.data;

          this._process(res.data);

          this._loading = false;
          this.trigger('load:done');
          resolve(_data);
        }
      }).catch(error => {
        reject(error);
      });
    }).catch(e => {
      console.error(`Layers: Failed to load layers metadata - ${e}`);
    });
  }

}

var _default = Layers;
exports.default = _default;