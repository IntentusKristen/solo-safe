"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.normalize = void 0;

var _InvalidCoordinateError = _interopRequireDefault(require("../errors/InvalidCoordinateError"));

var _utils = require("../utils");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const normalize = coord => {
  let factor = Math.ceil(Math.abs(coord.lat) / 180);
  if (coord.lat > 90) coord.lat -= 180 * factor;else if (coord.lat < -90) coord.lat += 180 * factor;
  factor = Math.ceil(Math.abs(coord.lon) / 360);
  if (coord.lon > 180) coord.lon -= 360 * factor;else if (coord.lon < -180) coord.lon += 360 * factor;
  return coord;
};
/**
 * A `CoordinateBounds` object represents a rectangular region defined by northwest and southeast
 * coordinates.
 */


exports.normalize = normalize;

class CoordinateBounds {
  /**
   * Initializes a bounds instance defined by the specified northwest and southeast coordinates.
   * @param nw
   * @param se
   */
  constructor(nw, se) {
    /** The northern latitude */
    this.north = 0;
    /** The southern latitude */

    this.south = 0;
    /** The western longitude */

    this.west = 0;
    /** The eastern longitude */

    this.east = 0;
    nw = normalize(nw);
    se = normalize(se);

    if (undefined === nw || !(0, _utils.isObject)(nw)) {
      throw new _InvalidCoordinateError.default('CoordinateBounds - northwest coordinate value is required');
    }

    if (undefined === se || !(0, _utils.isObject)(se)) {
      throw new _InvalidCoordinateError.default('CoordinateBounds - southeast coordinate value is required');
    }

    if (nw.lat < se.lat) {
      throw new _InvalidCoordinateError.default('CoordinateBounds - northern latitude must be greater than southern latitude');
    } // if (nw.lon > se.lon) {
    // 	throw new InvalidCoordinateError('CoordinateBounds - eastern longitude must be greater than western longitude');
    // }


    this.north = nw.lat;
    this.south = se.lat;
    this.west = nw.lon;
    this.east = se.lon;
  }

  static fromBounds(bounds) {
    return new CoordinateBounds({
      lat: bounds.north,
      lon: bounds.west
    }, {
      lat: bounds.south,
      lon: bounds.east
    });
  }

  static fromPoints(points) {
    const bounds = {
      north: null,
      south: null,
      west: null,
      east: null
    };
    points.forEach((coord, index) => {
      if (index === 0) {
        bounds.north = coord.lat;
        bounds.south = coord.lat;
        bounds.west = coord.lon;
        bounds.east = coord.lon;
      } else if ((0, _utils.isset)(coord.lat) && (0, _utils.isset)(coord.lon)) {
        bounds.north = Math.max(bounds.north, coord.lat);
        bounds.south = Math.min(bounds.south, coord.lat);
        bounds.west = Math.min(bounds.west, coord.lon);
        bounds.east = Math.max(bounds.east, coord.lon);
      }
    });
    return CoordinateBounds.fromBounds(bounds);
  }
  /**
   * Returns the northwestern coordinate for the bounds.
   */


  northwest() {
    return {
      lat: this.north,
      lon: this.west
    };
  }
  /**
   * Returns the southwestern coordinate for the bounds.
   */


  southwest() {
    return {
      lat: this.south,
      lon: this.west
    };
  }
  /**
   * Returns the northeastern coordinate for the bounds.
   */


  northeast() {
    return {
      lat: this.north,
      lon: this.east
    };
  }
  /**
   * Returns the southeastern coordinate for the bounds.
   */


  southeast() {
    return {
      lat: this.south,
      lon: this.east
    };
  }
  /**
   * Returns the center coordinate for the bounds.
   */


  center() {
    return {
      lat: this.north - (this.north - this.south) / 2,
      lon: this.west - (this.west - this.east) / 2
    };
  }
  /**
   * Expands the bounds to include the specified coordinate. If the bounds already contains the
   * coodinate, then the bounds will not change.
   *
   * @param coord
   */


  extend(coord) {
    if (!this.north && !this.south && !this.west && !this.east) {
      this.north = coord.lat;
      this.south = coord.lat;
      this.west = coord.lon;
      this.east = coord.lon;
      return;
    }

    this.north = Math.max(this.north, coord.lat);
    this.south = Math.min(this.south, coord.lat);
    this.west = Math.min(this.west, coord.lon);
    this.east = Math.max(this.east, coord.lon);
  }
  /**
   * Returns whether the bounds intersects the specified bounds but does not contain it.
   * @param bounds
   */


  intersects(bounds) {
    if (this.contains(bounds)) {
      return false;
    }

    const {
      north,
      south,
      east,
      west
    } = bounds;
    return (north <= this.north && north >= this.south || south >= this.south && south <= this.north) && ( // eslint-disable-line max-len
    west >= this.west && west <= this.east || east <= this.east && east >= this.west);
  }
  /**
   * Returns whether the bounds contains the specified coordinate or bounds.
   * @param value
   */


  contains(value) {
    if (value instanceof CoordinateBounds) {
      const {
        north,
        south,
        east,
        west
      } = value;
      return north < this.north && south > this.south && west > this.west && east < this.east;
    }

    const {
      lat,
      lon
    } = value;
    return lat < this.north && lat > this.south && lon > this.west && lon < this.east;
  }
  /**
   * Returns a string representation of the coordinate bounds.
   */


  toString() {
    return `${this.north},${this.west},${this.south},${this.east}`;
  }

}

var _default = CoordinateBounds;
exports.default = _default;