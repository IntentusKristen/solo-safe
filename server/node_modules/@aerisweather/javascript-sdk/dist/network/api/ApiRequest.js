"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _Http = _interopRequireDefault(require("../Http"));

var _ApiResult = _interopRequireDefault(require("./ApiResult"));

var _Query = _interopRequireDefault(require("./params/Query"));

var _utils = require("../../utils");

var strings = _interopRequireWildcard(require("../../utils/strings"));

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var __awaiter = void 0 && (void 0).__awaiter || function (thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function (resolve) {
      resolve(value);
    });
  }

  return new (P || (P = Promise))(function (resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }

    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }

    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }

    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};

const apiResultFromResponse = res => {
  const json = res && res.data ? res.data : {};
  let error = json.error;

  if (error && (error.code === 'warn_no_data' || error.code === 'warn_invalid_param' || error.code === 'invalid_location')) {
    error = null;
  }

  return new _ApiResult.default(res, json.response || json, error, null);
};
/**
 * An object that is responsible for configuring and performing a single request to the Aeris
 * Weather API.
 *
 * @export
 * @class ApiRequest
 */


class ApiRequest {
  /**
   * Initializes a new request instance configured with the specified client access keys.
   *
   * @param {ApiConfig} [config]
   * @memberof ApiRequest
   */
  constructor(config, opts) {
    /**
     * Base configuration for the request.
     *
     * @type {ApiConfig}
     * @memberof ApiRequest
     */
    this.config = {
      server: 'https://api.aerisapi.com',
      client: {
        id: undefined,
        secret: undefined
      }
    };
    /**
     * The parameters associated with the request.
     *
     * @private
     * @type {ApiRequestOptions}
     * @memberof ApiRequest
     */

    this._params = {
      endpoint: undefined
    };
    this._requests = [];
    this._paramKeys = ['p', 'limit', 'radius', 'filter', 'fields', 'query', 'sort', 'skip', 'from', 'to', 'plimit', 'psort', 'pskip', 'callback', 'metric', 'requests', 'lang', 'format', 'mindist', 'pfilter', 'lod', 'mindist'];
    this._requestKeys = [];
    this.config = (0, _utils.merge)(this.config, config);
    this._http = new _Http.default(this.config.server);
    this._range = {};

    if (opts) {
      this.setParams(opts);
    } // // add convenience methods for setting params
    // this._paramKeys.forEach((param: string) => {
    // 	const self = this as any;
    // 	if (!self[param]) {
    // 		self[param] = function() {
    // 			var args = Array.prototype.slice.call(arguments);
    // 			this.setParam.apply(this, args);
    // 			return this;
    // 		}.bind(this, param);
    // 	}
    // }, this);

  }

  get requests() {
    return this._requests;
  }
  /**
   * Sets or returns the specified parameter.
   *
   * @param {string} key
   * @param {*} [value]
   * @returns {(ApiRequest | any)}
   * @memberof ApiRequest
   */


  param(key, value) {
    if ((0, _utils.isset)(value)) {
      if (this._paramKeys.indexOf(key) !== -1) {
        (0, _utils.set)(this._params, key, value);
      }

      return this;
    }

    return (0, _utils.get)(this._params, key);
  }
  /**
   * Returns the current request parameters.
   *
   * @returns {ApiRequestOptions}
   * @memberof ApiRequest
   */


  getParams() {
    return (0, _utils.cloneDeep)(this._params);
  }
  /**
   * Sets multiple request parameters.
   *
   * @param {ApiRequestOptions} params
   * @returns {ApiRequest}
   * @memberof ApiRequest
   */


  setParams(params) {
    if (!(0, _utils.isset)(params)) {
      return this;
    }

    const filtered = Object.keys(params).filter(p => this._paramKeys.indexOf(p) !== -1).reduce((result, key) => {
      result[key] = params[key];
      return result;
    }, {});
    this._params = (0, _utils.merge)(this._params, filtered);
    return this;
  }

  resetParams() {
    this._params = {
      endpoint: this._endpoint
    };
    return this;
  }
  /**
   * Sets the endpoint for the request (required).
   *
   * @param {string} endpoint
   * @returns {ApiRequest}
   * @memberof ApiRequest
   */


  endpoint(endpoint) {
    this._endpoint = endpoint;
    this.param('endpoint', endpoint);
    return this;
  }
  /**
   * Returns the endpoint for the request.
   *
   * @returns {string}
   * @memberof ApiRequest
   */


  getEndpoint() {
    return this._endpoint;
  }
  /**
   * Sets the action for the request.
   *
   * @param {string} action
   * @returns {ApiRequest}
   * @memberof ApiRequest
   */


  action(action) {
    this._action = action;
    return this;
  }
  /**
   * Returns the action for the request.
   *
   * @returns {string}
   * @memberof ApiRequest
   */


  getAction() {
    return this._action;
  }
  /**
   * Sets the place for the request.
   *
   * @param {string} value
   * @returns {ApiRequest}
   * @memberof ApiRequest
   */


  place(value) {
    this.param('p', value);
    return this;
  }
  /**
   * Sets the request's place to the coordinate bounds string.
   *
   * @param {GeoBounds} bounds
   * @returns {ApiRequest}
   * @memberof ApiRequest
   */


  bounds(bounds) {
    if ((0, _utils.isString)(bounds)) {
      const str = bounds;

      if (/,/.test(str)) {
        const b = str.split(',').map(v => parseFloat(v));

        if (b.length === 4) {
          bounds = {
            north: b[0],
            west: b[1],
            south: b[2],
            east: b[3]
          };
        }
      }
    }

    return this.place(strings.toBounds(bounds));
  }
  /**
   * Sets the limit parameter.
   *
   * @param {number} value
   * @returns {ApiRequest}
   * @memberof ApiRequest
   */


  limit(value) {
    this.param('limit', value);
    return this;
  }
  /**
   * Sets the lod (level-of-detail) parameter.
   *
   * @param {number} value
   * @returns {ApiRequest}
   * @memberof ApiRequest
   */


  lod(value) {
    this.param('lod', value);
    return this;
  }
  /**
   * Sets the mindist parameter.
   *
   * @param {(string | number)} value
   * @returns {ApiRequest}
   * @memberof ApiRequest
   */


  mindist(value) {
    if ((0, _utils.isNumber)(value)) {
      value = `${value}mi`;
    }

    this.param('mindist', value);
    return this;
  }
  /**
   * Sets the radius parameter.
   *
   * @param {string} value
   * @returns {ApiRequest}
   * @memberof ApiRequest
   */


  radius(value) {
    this.param('radius', value);
    return this;
  }
  /**
   * Sets the filter parameter.
   *
   * @param {string} value
   * @returns {ApiRequest}
   * @memberof ApiRequest
   */


  filter(value) {
    this.param('filter', value);
    return this;
  }
  /**
   * Sets the fields parameter.
   *
   * @param {string} value
   * @returns {ApiRequest}
   * @memberof ApiRequest
   */


  fields(value) {
    this.param('fields', value);
    return this;
  }
  /**
   * Sets the query parameter.
   *
   * @param {(string | Query)} value
   * @returns {ApiRequest}
   * @memberof ApiRequest
   */


  query(value) {
    if (value instanceof _Query.default) {
      value = value.toString();
    }

    this.param('query', value);
    return this;
  }
  /**
   * Sets the sort parameter.
   *
   * @param {string} value
   * @returns {ApiRequest}
   * @memberof ApiRequest
   */


  sort(value) {
    this.param('sort', value);
    return this;
  }
  /**
   * Sets the skip parameter.
   *
   * @param {number} value
   * @returns {ApiRequest}
   * @memberof ApiRequest
   */


  skip(value) {
    this.param('skip', value);
    return this;
  }
  /**
   * Sets the from parameter.
   *
   * @param {(string | Date)} value
   * @returns {ApiRequest}
   * @memberof ApiRequest
   */


  from(value) {
    if ((0, _utils.isDate)(value)) {
      const date = value; // don't set `from` value if it's a date that's within 1 minute of the current time

      if (Math.abs(date.getTime() - new Date().getTime()) < 60 * 1000) {
        this.param('from', 'now');
        return this;
      }

      value = (0, _utils.toTimeStr)(date);
      this._range.from = date;
    }

    this.param('from', value);
    return this;
  }
  /**
   * Sets the to parameter.
   *
   * @param {(string | Date)} value
   * @returns {ApiRequest}
   * @memberof ApiRequest
   */


  to(value) {
    if ((0, _utils.isDate)(value)) {
      const date = value; // don't set `to` value if it's a date that's within 1 minute of the current time

      if (Math.abs(date.getTime() - new Date().getTime()) < 60 * 1000) {
        this.param('to', 'now');
        return this;
      }

      value = (0, _utils.toTimeStr)(date, this._range.from);
      this._range.to = date;
    }

    this.param('to', value);
    return this;
  }
  /**
   * Sets the plimit paramter.
   *
   * @param {number} value
   * @returns {ApiRequest}
   * @memberof ApiRequest
   */


  plimit(value) {
    this.param('plimit', value);
    return this;
  }
  /**
   * Sets the psort parameter.
   *
   * @param {string} value
   * @returns {ApiRequest}
   * @memberof ApiRequest
   */


  psort(value) {
    this.param('psort', value);
    return this;
  }
  /**
   * Sets the pskip parameter.
   *
   * @param {number} value
   * @returns {ApiRequest}
   * @memberof ApiRequest
   */


  pskip(value) {
    this.param('pskip', value);
    return this;
  }
  /**
   * Sets the format parameters.
   *
   * @param value
   * @returns {ApiRequest}
   * @memberof ApiRequest
   */


  format(value) {
    this.param('format', value);
    return this;
  }

  route(value) {
    this._route = value;
    return this;
  }
  /**
   * Adds a request to the batch request.
   *
   * Adding child requests to this request automatically converts the containing request to a batch request.
   *
   * @param {ApiRequest} request
   * @returns {ApiRequest}
   * @memberof ApiRequest
   */


  addRequest(request) {
    const url = request.url(); // make sure we're not adding the same request multiple times based on url

    let allow = this._requests.indexOf(request) === -1;

    if (allow) {
      this._requestKeys.forEach(key => {
        if (url === key) {
          allow = false;
        }
      });
    }

    if (allow) {
      this._requestKeys.push(url);

      this._requests.push(request);
    }

    return this;
  }
  /**
   * Removes a request from the batch request.
   *
   * @param {ApiRequest} request
   * @returns {ApiRequest}
   * @memberof ApiRequest
   */


  removeRequest(request) {
    const index = this._requests.indexOf(request);

    if (index >= 0) {
      this._requests.splice(index, 1);
    }

    return this;
  }
  /**
   * Removes all requests from the batch request, converting the request instance to a non-batch request.
   *
   * @memberof ApiRequest
   */


  removeAllRequests() {
    this._requests = [];
  }
  /**
   * Perform the request.
   *
   * @param {(result: ApiResult) => void} [callback]
   * @returns {Promise<ApiResult>}
   * @memberof ApiRequest
   */


  get(callback) {
    return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
      try {
        this._http.cancel();

        const fetcher = this._action === "route"
        /* ROUTE */
        ? url => this._http.post(url, this._route) : url => this._http.get(url);
        const res = yield fetcher(this.url());

        if (res) {
          const result = apiResultFromResponse(res);

          if (callback) {
            callback(result);
          }

          resolve(result);
        }
      } catch (e) {
        console.error('ApiRequest Error', e);
        resolve(new _ApiResult.default(null, null, e, null));
      }
    }));
  }
  /**
   * Cancels any active request.
   *
   * @memberof ApiRequest
   */


  cancel() {
    this._http.cancel();
  }
  /**
   * Returns the url string for the request based on the configured parameters and options.
   *
   * @param {boolean} [isBatch=false]
   * @returns {string}
   * @memberof ApiRequest
   */


  url(isBatch = false) {
    let url = isBatch ? '' : this.config.server;
    const params = (0, _utils.merge)({}, (0, _utils.pickBy)(this._params, o => !(0, _utils.isEmpty)(o)), isBatch ? {} : {
      client_id: this.config.client.id,
      client_secret: this.config.client.secret
    });

    if (this._requests.length > 0) {
      url += '/batch';
      const urls = [];

      this._requests.forEach(request => {
        urls.push(request.url(true));
      });

      params.requests = urls.join(',');
    } else {
      if (this._endpoint) {
        url += `/${this._endpoint}`;
      } else {
        throw new Error('Invalid ApiRequest - No endpoint specified');
      }

      if (this._action && this._action !== ":id"
      /* ID */
      && this._action !== ":all"
      /* ALL */
      ) {
        url += `/${this._action}`;
      } else if (params.p) {
        url += `/${encodeURIComponent(params.p)}`;
        delete params.p;
      }
    }

    const query = Object.keys(params).filter(param => param !== 'endpoint').map(k => `${encodeURIComponent(k)}=${encodeURIComponent(params[k])}`).join('&');

    if (query.length > 0) {
      url += `?${query}`;
    }

    return url;
  }
  /**
   * Returns a copy of the request.
   *
   * @returns {ApiRequest}
   * @memberof ApiRequest
   */


  clone() {
    const request = new ApiRequest(this.config);
    request.setParams(this._params);
    return request;
  }

}

var _default = ApiRequest;
exports.default = _default;
module.exports = exports.default;