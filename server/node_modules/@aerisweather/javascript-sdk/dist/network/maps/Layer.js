"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _utils = require("../../utils");

/**
 * A `Layer` object used to configure a single Aeris Maps layer.
 */
class Layer {
  /**
   * Initializes a layer instance with the specified AMP layer code.
   *
   * @param {string} code
   * @memberof Layer
   */
  constructor(code) {
    this._opts = {
      alpha: 100,
      darkStyle: false,
      text: false,
      largeText: false,
      metric: false,
      blendMode: undefined,
      blur: 0,
      filters: [],
      mask: undefined,
      includeText: false
    };
    this._opts.darkStyle = /-dk/.test(code);
    this._opts.text = /-text/.test(code);
    this._opts.largeText = /-lg/.test(code);
    this.code = code.replace(/-(dk|text|lg)/, '').replace(/:.+$/, '');
  }
  /**
   * Sets or returns an option value.
   *
   * @param {string} key
   * @param {*} [value]
   * @returns {(Layer|any)}
   * @memberof Layer
   */


  opt(key, value) {
    if (value) {
      (0, _utils.set)(this._opts, key, value);
      return this;
    }

    return (0, _utils.get)(this._opts, key);
  }
  /**
   * The layer configuration object.
   *
   * @param {LayerOptions} [value]
   * @returns {(Layer|LayerOptions)}
   * @memberof Layer
   */


  options(value) {
    if (value) {
      this._opts = value;
    }

    return this._opts;
  }
  /**
   * The alpha (opacity) of the layer.
   *
   * @param {number} [value]
   * @returns {Layer}
   * @memberof Layer
   */


  alpha(value) {
    this.opt('alpha', value);
    return this;
  }
  /**
   * A Boolean indicating whether the layer should use the dark style.
   *
   * @param {boolean} [value]
   * @returns {Layer}
   * @memberof Layer
   */


  darkStyle(value) {
    this.opt('darkStyle', value);
    return this;
  }
  /**
   * A Boolean indicating whether the layer is a text layer.
   *
   * @param {boolean} [value]
   * @returns {Layer}
   * @memberof Layer
   */


  text(value) {
    this.opt('text', value);
    return this;
  }
  /**
   * A Boolean indicating whether the layer should also include its associated text layer.
   *
   * @param {boolean} [value]
   * @returns {Layer}
   * @memberof Layer
   */


  includeText(value) {
    this.opt('includeText', value);
    return this;
  }
  /**
   * A Boolean indicating whether the text layer should use large text.
   *
   * @param {boolean} [value]
   * @returns {Layer}
   * @memberof Layer
   */


  largeText(value) {
    this.opt('largeText', value);
    return this;
  }
  /**
   * A Boolean indicating whether the layer should display text values in Metric units.
   *
   * @param {boolean} [value]
   * @returns {Layer}
   * @memberof Layer
   */


  metric(value) {
    this.opt('metric', value);
    return this;
  }
  /**
   * The blend mode to apply to the layer.
   *
   * @param {string} [value]
   * @returns {Layer}
   * @memberof Layer
   */


  blendMode(value) {
    this.opt('blendMode', value);
    return this;
  }
  /**
   * The amount to blur the layer, which is a value from `0` meaning no blur (default) to `10`.
   * The higher the value, the greater the blur effect.
   *
   * @param {number} [value]
   * @returns {Layer}
   * @memberof Layer
   */


  blur(value) {
    this.opt('blur', value);
    return this;
  }
  /**
   * The mask layer to apply to the layer.
   *
   * @param {string} [value]
   * @returns {Layer}
   * @memberof Layer
   */


  mask(value) {
    this.opt('mask', value);
    return this;
  }
  /**
   * Adds a filter to the layer.
   *
   * @param {string} filter
   * @returns {Layer}
   * @memberof Layer
   */


  addFilter(filter) {
    this._opts.filters.push(filter);

    return this;
  }
  /**
   * Removes a filter from the layer.
   *
   * @param {string} filter
   * @returns {Layer}
   * @memberof Layer
   */


  removeFilter(filter) {
    const index = this._opts.filters.indexOf(filter);

    if (index !== -1) {
      this._opts.filters.splice(index, 1);
    }

    return this;
  }
  /**
   * Removes all filters from the layer.
   *
   * @returns {Layer}
   * @memberof Layer
   */


  removeAllFilters() {
    this._opts.filters = [];
    return this;
  }
  /**
   * Returns the layer string based on the layer configuration.
   *
   * @returns {string}
   * @memberof Layer
   */


  toString() {
    const opts = this._opts;
    let val = this.code;
    let text;

    if (opts.includeText || opts.text) {
      text = `${val}-text`;

      if (opts.metric) {
        text = `${text}-metric`;
      }

      if (opts.largeText) {
        text = `${text}-lg`;
      }

      if (opts.text) {
        val = text;
      }
    }

    if (opts.darkStyle) {
      val = `${val}-dk`;
    }

    if (opts.alpha < 100) {
      val = `${val}:${opts.alpha}`;
    }

    if (opts.blur > 0) {
      val = `${val}:blur(${opts.blur})`;
    }

    if (opts.blendMode) {
      val = `${val}:blend(${opts.blendMode})`;
    }

    if (opts.filters.length > 0) {
      val = `${val}:${opts.filters.join(':')})`;
    }

    if (opts.includeText && text) {
      val = `${val},${text}`;
    }

    return val;
  }

}

var _default = Layer;
exports.default = _default;
module.exports = exports.default;