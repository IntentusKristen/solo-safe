"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _Http = _interopRequireDefault(require("../Http"));

var _MapResult = _interopRequireDefault(require("./MapResult"));

var _Layer = _interopRequireDefault(require("./Layer"));

var _utils = require("../../utils");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var __awaiter = void 0 && (void 0).__awaiter || function (thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function (resolve) {
      resolve(value);
    });
  }

  return new (P || (P = Promise))(function (resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }

    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }

    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }

    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};

const toArray = str => (str || '').replace(/\s/, '').split(',');

const toCodeArray = value => {
  if ((0, _utils.isEmpty)(value)) {
    return [];
  }

  if (!(0, _utils.isArray)(value)) {
    return toArray(value);
  }

  const result = value.map(v => {
    if (v instanceof _Layer.default) {
      return v.toString();
    }

    return v;
  });
  return result;
};

const normalize = params => {
  Object.keys(params).forEach(key => {
    const val = params[key];

    if (key === 'layers') {
      if ((0, _utils.isPlainObject)(val)) {
        Object.keys(val).forEach(k => {
          val[k] = toCodeArray(val[k]);
        });
      } else {
        params[key] = toCodeArray(val);
      }
    } else if (key === 'p') {
      if ((0, _utils.isObject)(params[key])) {
        const {
          lat,
          lon
        } = params[key];

        if (lat && lon) {
          params[key] = `${lat},${lon}`;
        }
      }
    }
  });
  return params;
};
/**
 * An object that is responsible for configuring and performing a single request to the Aeris Weather API.
 *
 * @export
 * @class MapRequest
 */


class MapRequest {
  /**
   * Initializes a new request instance configured with the specified client access keys.
   *
   * @param config
   */
  constructor(config, opts) {
    /**
     * Base configuration for the request.
     *
     * @type {ApiConfig}
     * @memberof MapRequest
     */
    this.config = {
      server: 'https://maps.aerisapi.com',
      client: {
        id: undefined,
        secret: undefined
      }
    };
    /**
     * Parameters associated with the request.
     *
     * @private
     * @type {IMapOptions}
     * @memberof MapRequest
     */

    this._params = {
      type: "image"
      /* IMAGE */
      ,
      layers: {
        base: undefined,
        data: undefined,
        overlays: undefined,
        text: undefined
      },
      p: undefined,
      zoom: 3,
      bounds: undefined,
      size: {
        width: undefined,
        height: undefined
      },
      offset: '0',
      metric: false,
      format: 'png'
    };
    this._serverRange = [1, 2, 3, 4];
    this._paramKeys = ['type', 'layers', 'layers.base', 'layers.data', 'layers.overlays', 'layers.text', 'p', 'center', 'zoom', 'bounds', 'size', 'size.width', 'size.height', 'offset', 'metric', 'format'];
    this.config = (0, _utils.merge)(this.config, config);
    this._http = new _Http.default(this.config.server, {
      'Content-Type': null
    });

    if (opts) {
      this.setParams(opts);
    }
  }
  /**
   * Sets or returns the specified parameter.
   *
   * @param key
   * @param value
   */


  param(key, value) {
    if (value) {
      if (this._paramKeys.indexOf(key) !== -1) {
        (0, _utils.set)(this._params, key, value);

        if (/^layers/.test(key)) {
          this._params = normalize(this._params);
        }
      }

      return this;
    }

    return (0, _utils.get)(this._params, key);
  }
  /**
   * Sets multiple request parameters.
   *
   * @param params
   * @returns {MapRequest}
   * @memberof MapRequest
   */


  setParams(params) {
    this._params = normalize((0, _utils.merge)(this._params, params));
    return this;
  }
  /**
   * Sets the type of map image to request, either `image` (default) or `tile`.
   *
   * @param {MapRequestType} type
   * @returns {MapRequest}
   * @memberof MapRequest
   */


  type(type) {
    this.param('type', type);
    return this;
  }
  /**
   * Sets the base layers, which will be rendered at the bottom of the layer stack.
   *
   * @param value
   * @returns {MapRequest}
   * @memberof MapRequest
   */


  base(value) {
    this.param('layers.base', toCodeArray(value));
    return this;
  }
  /**
   * Sets the weather data layers, which will be rendered above the base layers but below overlays and text.
   *
   * @param value
   * @returns {MapRequest}
   * @memberof MapRequest
   */


  data(value) {
    this.param('layers.data', toCodeArray(value));
    return this;
  }
  /**
   * Sets the overlay layers, which will be rendered above weather data layers but below text layers.
   *
   * @param value
   * @returns {MapRequest}
   * @memberof MapRequest
   */


  overlays(value) {
    this.param('layers.overlays', toCodeArray(value));
    return this;
  }
  /**
   * Sets the text layers, which will be rendered at the top of the layer stack.
   *
   * @param value
   * @returns {MapRequest}
   * @memberof MapRequest
   */


  text(value) {
    this.param('layers.text', toCodeArray(value));
    return this;
  }
  /**
   * Sets all layers, which will be rendered in the order in which they are provided by `value`.
   *
   * @param value
   * @returns {MapRequest}
   * @memberof MapRequest
   */


  layers(value) {
    this.param('layers', toCodeArray(value));
    return this;
  }
  /**
   * Sets the location the map will be centered on.
   *
   * @param value
   * @returns {MapRequest}
   * @memberof MapRequest
   */


  place(value) {
    this.param('p', value);
    return this;
  }
  /**
   * Sets the center for the map request. The center can be a place name or a geographical
   * coordinate value.
   *
   * @param {(string | Coordinate)} [value]
   * @returns {MapRequest}
   * @memberof MapRequest
   */


  center(value) {
    if ((0, _utils.isObject)(value)) {
      const {
        lat,
        lon
      } = value;

      if (lat && lon) {
        value = `${lat},${lon}`;
      }
    }

    this.param('p', value);
    return this;
  }
  /**
   * Sets the zoom level.
   *
   * @param value
   * @returns {MapRequest}
   * @memberof MapRequest
   */


  zoom(value) {
    this.param('zoom', value);
    return this;
  }
  /**
   * Sets the bounding box coordinates for the rendered map region.
   *
   * @param value
   * @returns {MapRequest}
   * @memberof MapRequest
   */


  bounds(value) {
    this.param('bounds', value);
    return this;
  }
  /**
   * Sets the map width and height.
   *
   * @param w
   * @param h
   * @returns {MapRequest}
   * @memberof MapRequest
   */


  size(w, h) {
    this.param('size', {
      width: w,
      height: h
    });
    return this;
  }
  /**
   * Sets the time offset value.
   *
   * @param value
   * @returns {MapRequest}
   * @memberof MapRequest
   */


  offset(value) {
    this.param('offset', `${value}`);
    return this;
  }
  /**
   * Sets the time offset value using the specified date.
   *
   * @param {Date} value
   * @returns {MapRequest}
   * @memberof MapRequest
   */


  date(value) {
    // eliminate seconds and milliseconds from date
    value = new Date(value.getFullYear(), value.getMonth(), value.getDate(), value.getHours(), value.getMinutes()); // time string must be in GMT

    const date = new Date(value.getTime() + value.getTimezoneOffset() * 60 * 1000);
    return this.offset((0, _utils.formatDate)(date, 'yyyyMMddHHmm00'));
  }
  /**
   * Sets whether text data should be rendered as Metric units.
   *
   * @param value
   * @returns {MapRequest}
   * @memberof MapRequest
   */


  metric(value) {
    if (value) {
      this.param('metric', value);
      return this;
    }

    return this.param('metric');
  }
  /**
   * Sets the server subdomain range for the request, e.g. `[1, 2, 3, 4]`.
   *
   * @param {number[]} [value]
   * @returns {(MapRequest | number[])}
   * @memberof MapRequest
   */


  range(value) {
    if (value) {
      this._serverRange = [...value];
      return this;
    }

    return this._serverRange;
  }
  /**
   * Perform the request.
   */


  get(callback) {
    return __awaiter(this, void 0, void 0, function* () {
      try {
        const url = this.url();

        if (!url) {
          const result = new _MapResult.default(null, null, new Error('Invalid map url'), this._params);

          if (callback) {
            callback(result);
          }

          return result;
        }

        const res = yield this._http.get(url);
        let image;
        let error;

        if (res.status >= 400) {
          const json = yield res.data;
          error = json.error;

          if (error && (error.code === 'warn_no_data' || error.code === 'warn_invalid_param' || error.code === 'invalid_location')) {
            error = null;
          }
        } else {
          image = new Image();
          image.src = url.indexOf(this.config.server) >= 0 ? url : `${this.config.server}/${url}`;
        }

        const result = new _MapResult.default(res, image, error, this._params);

        if (callback) {
          callback(result);
        }

        return result;
      } catch (e) {
        console.error('MapRequest Error', e);
      }

      return null;
    });
  }
  /**
   * Returns the url string for the request based on the configured parameters and options.
   *
   * @param {string[]} [groups=[]]
   * @returns {string}
   * @memberof MapRequest
   */


  url(groups = []) {
    let url = this.config.server;
    const params = (0, _utils.merge)({}, (0, _utils.pickBy)(this._params, o => !(0, _utils.isEmpty)(o)), {
      layers: []
    });

    if ((0, _utils.isString)(params.p)) {
      params.p = params.p.replace(/\+/, '%20');
    }

    const layers = this._params.layers;

    if ((0, _utils.isPlainObject)(layers)) {
      const layerGroups = layers;
      groups = !(0, _utils.isEmpty)(groups) ? groups : Object.keys(layerGroups); // console.log(groups, layers);

      if (!(0, _utils.isEmpty)(groups)) {
        groups.forEach(group => {
          let glayers = layerGroups[group];

          if (!(0, _utils.isEmpty)(glayers)) {
            if (!(0, _utils.isArray)(glayers)) {
              glayers = toArray(glayers);
            }

            params.layers = params.layers.concat(glayers);
          }
        });
      }
    } else if ((0, _utils.isArray)(layers)) {
      params.layers = layers;
    }

    if ((0, _utils.isEmpty)(params.layers)) {
      if (groups.length > 1) {
        console.warn(`No map layers specified - layers: ${params.layers}; groups: ${groups.join(',')}`);
      }

      return undefined;
    }

    if (params.type === "tile"
    /* TILE */
    ) {
        // handle server subdomain range if defined
        if (!(0, _utils.isEmpty)(this._serverRange)) {
          url = url.replace(/maps\./, 'maps{s}.');
        }

        url += `/${this.config.client.id}_${this.config.client.secret}/${params.layers}/{z}/{x}/{y}/${params.offset}.${params.format}`;
      } else {
      // exit if no valid location or bounds defined
      if (((0, _utils.isEmpty)(params.p) || params.p === ':auto') && (0, _utils.isEmpty)(params.bounds)) {
        console.warn(`No valid location or bounds provided for the map - p: ${params.p}; bounds: ${params.bounds}`);
        return undefined;
      }

      const b = params.bounds;
      params.loc = !(0, _utils.isEmpty)(b) ? `${b.south},${b.west},${b.north},${b.east}` : `${params.p},${params.zoom}`;
      url += `/${this.config.client.id}_${this.config.client.secret}/${params.layers}/${params.size.width}x${params.size.height}/${params.loc}/${params.offset}.${params.format}`;
    }

    return url;
  }
  /**
   * Returns a copy of the request.
   *
   * @returns {MapRequest}
   * @memberof MapRequest
   */


  clone() {
    const request = new MapRequest(this.config);
    request.setParams(this._params);
    return request;
  }

}

var _default = MapRequest;
exports.default = _default;
module.exports = exports.default;