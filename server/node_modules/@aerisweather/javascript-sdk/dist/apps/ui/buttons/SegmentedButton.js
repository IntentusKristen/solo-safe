"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _Button = _interopRequireDefault(require("./Button"));

var _ButtonSegment = _interopRequireDefault(require("./ButtonSegment"));

var _ButtonSegmentGroup = _interopRequireDefault(require("./ButtonSegmentGroup"));

var _utils = require("../../../utils");

var _DOM = _interopRequireDefault(require("../../../display/DOM"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * A `SegmentedButton` is a button subclass that also contains a segmented control within the
 * button, which can be used to change the current value of the button or to use as a secondary
 * value associated with the button's value, such as filters.
 *
 * @export
 * @class SegmentedButton
 * @extends {Button<SegmentedButtonOptions, SegmentedButtonState>}
 */
class SegmentedButton extends _Button.default {
  /**
   * Initializes and returns a segmented button instance configured with the specified options.
   *
   * @param {SegmentedButtonOptions} [opts]
   * @memberof SegmentedButton
   */
  constructor(opts) {
    super((0, _utils.extend)({
      filter: false,
      multiselect: false,
      groupMultiselect: true,
      reloadOnChange: true,
      ui: {
        all: '.awxjs__ui-btn-segmented__option-all',
        segments: '.awxjs__ui-btn-segments',
        groups: '.awxjs__ui-btn-segmented__groups'
      }
    }, opts, {
      className: opts.className ? `ui-btn-segmented ${opts.className}` : 'ui-btn-segmented'
    }));
    this._segments = [];
    this._groups = [];
    this._groupsById = {};
    this._value = null;
    this._expanded = false;
    this._handleValueChange = (0, _utils.debounce)((info = {}, triggerEvents = true) => {
      const previousValue = !(0, _utils.isEmpty)(this._value) ? (0, _utils.cloneDeep)(this._value) : [];
      let previousSegmentsInfo;
      const value = this.value; // set previous segments to include in event payload

      if ((0, _utils.isPlainObject)(previousValue)) {
        previousSegmentsInfo = this.segments().filter(segment => {
          let include = false;
          Object.keys(previousValue).forEach(key => {
            if (segment.value === previousValue[key] && segment.groupId === key) {
              include = true;
            }
          });
          return include;
        }).map(segment => segment.info);
      } else if ((0, _utils.isArray)(previousValue)) {
        previousSegmentsInfo = this.segments().filter(segment => previousValue.indexOf(segment.value) !== -1).map(segment => segment.info);
      } // console.log('_handleValueChange', this.segments(), value, previousValue, previousSegmentsInfo);


      this._value = (0, _utils.cloneDeep)(value);

      if (triggerEvents) {
        this.trigger('value:change', {
          value,
          currentSegments: this.segmentInfo(true),
          previous: previousValue,
          previousSegments: previousSegmentsInfo,
          reload: this.opts.reloadOnChange
        });
      }

      if (this.opts.onChange) {
        this.opts.onChange(this);
      } // this._value = cloneDeep(value);

    }, 200);
    this._triggerTimeout = null;
  }
  /**
   * Value associated with the currently selected segment(s).
   *
   * @readonly
   * @type {*}
   * @memberof SegmentedButton
   */


  get value() {
    const selected = this.selectedSegments(); // const segments = selected.map((segment) => ({
    // 	...segment.info,
    // 	options: extend({}, this.options, segment.options)
    // }));

    if (this._groups.length > 0) {
      if (!this.opts.groupMultiselect) {
        return this._groups.map(group => group.value).filter(v => !(0, _utils.isEmpty)(v));
      }

      return this._groups.reduce((result, group) => {
        result[group.id] = group.value;
        return result;
      }, {}); // if (this.opts.filter === true) {
      // 	return {
      // 		filters: vals,
      // 		segments,
      // 		reload: this.opts.reloadOnChange
      // 	};
      // }
      // return vals;
    } // if (this.opts.filter === true) {
    // 	return {
    // 		id: this.id,
    // 		value: this.id,
    // 		filters: selected.map((segment) => segment.value).join(';'),
    // 		segments,
    // 		parent: this.id,
    // 		options: this.options
    // 	};
    // }
    // return { segments };


    return selected.map(segment => segment.value);
  }

  set value(value) {
    const arr = !(0, _utils.isArray)(value) ? [value] : value;
    const selected = this.selectedSegments();

    if (value instanceof Array) {
      // select segments from new value
      arr.forEach(v => {
        this.selectSegment(v);
      }); // deselect any segments not included in new value

      selected.forEach(segment => {
        if (arr.indexOf(segment.value) === -1 && arr.indexOf(segment.key) === -1) {
          this.deselectSegment(segment.key);
        }
      });
    } else if (this._groups.length > 0) {
      this._groups.forEach(group => {// group.value = value[group.id];
      });
    }
  }
  /**
   * Returns the button metadata, including identifier, key, current value, and selected segments.
   *
   * @readonly
   * @type {ButtonInfo}
   * @memberof SegmentedButton
   */


  get info() {
    return Object.assign(Object.assign({}, super.info), {
      valueSegments: this.segmentInfo(true),
      filter: this.opts.filter,
      reload: this.opts.filter && this.opts.reloadOnChange
    });
  }
  /**
   * Returns whether the button is currently expanded.
   *
   * @readonly
   * @type {boolean}
   * @memberof SegmentedButton
   */


  get isExpanded() {
    return this._expanded;
  }
  /**
   * Returns whether the segments are configured as filter options.
   *
   * @readonly
   * @type {boolean}
   * @memberof SegmentedButton
   */


  get isFilter() {
    return this.opts.filter;
  }

  size() {
    const size = super.size(); // calculate height if element is currently selected

    if (this.selected) {
      const $target = this.ui.groups || this.ui.segments;
      const maxh = $target.css('max-height');
      $target.css('max-height', 'auto');
      let h = parseFloat(maxh.replace(/[^0-9\.]/, ''));
      h += this.el('.awxjs__ui-btn-label').outerHeight(true);
      $target.css('max-height', maxh);
      const pad = this.$el.padding();
      h += pad.top + pad.bottom;
      const margins = this.$el.margins();
      h += margins.top + margins.bottom;
      size.height = h;
    }

    return size;
  }
  /**
   * Returns an array of child button segment for the button.
   *
   * @returns {ButtonSegment[]}
   * @memberof SegmentedButton
   */


  segments() {
    if (this._groups.length > 0) {
      return this._groups.reduce((result, group) => {
        result = result.concat(group.segments);
        return result;
      }, []);
    }

    return this._segments;
  }
  /**
   * Returns an array of values from the button segments.
   *
   * @returns {string[]}
   * @memberof SegmentedButton
   */


  segmentValues() {
    return this.segments().map(segment => segment.value);
  }
  /**
   * Returns an array of identifiers from the button segments.
   *
   * @returns {string[]}
   * @memberof SegmentedButton
   */


  segmentIds(includeParent = true) {
    return this.segments().map(segment => {
      if (includeParent) {
        return segment.key.replace(/^.+___/, '');
      }

      return segment.id.replace(/^.+___/, '');
    });
  }

  segmentInfo(selectedOnly = false) {
    const segments = selectedOnly ? this.selectedSegments() : this.segments();
    return segments.map(segment => segment.info);
  }
  /**
   * Returns the button segment groups associated with the button.
   *
   * @returns {ButtonSegmentGroup[]}
   * @memberof SegmentedButton
   */


  segmentGroups() {
    return this._groups;
  }
  /**
   * Returns `true` if the button contains a segment option associated with the specified
   * value. This can either be a button segment value or identifier.
   *
   * @param {string} value
   * @returns
   * @memberof SegmentedButton
   */


  containsValue(value) {
    const check = value.replace(/^.+::/, '');
    return this.segmentValues().indexOf(check) > -1 || this.segmentIds().indexOf(check) > -1;
  }

  containsId(id) {
    return this.segmentIds(true).indexOf(id) > -1;
  }
  /**
   * Selects the button segment associated with the specified option. If `select` is `true`, then
   * then parent button will also be selected.
   *
   * @param {string | Record<string, any>} option
   * @param {boolean} [select=true]
   * @memberof SegmentedButton
   */


  selectSegment(option, select = true) {
    this.setSegmentSelected(option, true, select); // if (found && select) {
    // 	// update cached value
    // 	this.select();
    // 	// this._value = { ...this.value };
    // }
  }
  /**
   * Deselects the button segment associated with the specified option.
   *
   * @param {(string | Record<string, any>)} option
   * @memberof SegmentedButton
   */


  deselectSegment(option) {
    this.setSegmentSelected(option, false);
  }

  setSegmentSelected(option, selected, autoSelectParent = false) {
    let found = false;
    const segments = this.segments();

    if (segments && segments.length > 0) {
      segments.forEach(segment => {
        if ((0, _utils.isString)(option)) {
          if (segment.id === option || segment.key === option) {
            if (selected) {
              segment.select();
            } else {
              segment.deselect();
            }

            found = true;
          } else if (this.id === option) {
            found = true;
          }
        } else if ((0, _utils.isPlainObject)(option)) {
          Object.keys(option).forEach(groupId => {
            const group = this._groupsById[groupId];

            if (group) {
              group.segments.forEach(groupSegment => {
                if (groupSegment.id === option || groupSegment.key === option) {
                  if (selected) {
                    segment.select();
                  } else {
                    segment.deselect();
                  }

                  found = true;
                }
              });
            }
          });
        }
      });
    }

    if (found && selected && autoSelectParent) {
      if ((0, _utils.isEmpty)(this._value)) {
        this._value = this.value;
      }

      this.select();
    }

    return found;
  }
  /**
   * Returns the selected button segment(s).
   *
   * @returns {ButtonSegment[]}
   * @memberof SegmentedButton
   */


  selectedSegments() {
    return this.segments().filter(segment => segment.selected);
  }

  _onSelect(trigger = true) {
    if (!this.isExpanded) {
      this._showSegments(true);
    }

    super._onSelect(trigger);
  }

  _onDeselect(trigger = true) {
    if (this.isExpanded) {
      this._showSegments(false);
    }

    super._onDeselect(trigger);
  }

  _render(data) {
    let output = '';
    const segments = (0, _utils.get)(this.opts, 'segments');

    if (segments) {
      if ((0, _utils.isArray)(segments)) {
        this._renderSegments(segments);

        output += `<div class="awxjs__ui-btn-segments"><ul></ul></div>`;
      } else if (segments.groups) {
        this._renderGroups(segments.groups);

        output += `<div class="awxjs__ui-btn-segmented__groups"></div>`;
      }
    }

    return `
			<div class="awxjs__ui-btn-segmented">
				<div class="awxjs__ui-btn-target">
					<div class="awxjs__ui-btn-label">${this.opts.title}</div>
				</div>
				${output}
			</div>
		`;
  }

  _renderSegments(segments) {
    this._segments = (segments || []).map(config => {
      const localConfig = (0, _utils.cloneDeep)(config);
      localConfig.id = localConfig.id || localConfig.value.replace(/\:.+$/, '').replace(/,/, '--').replace(/;/, '__');
      localConfig.options = (0, _utils.extend)({}, this.options, localConfig.options);
      return new _ButtonSegment.default(Object.assign(Object.assign({
        multiselect: this.opts.multiselect
      }, localConfig), {
        loader: false,
        toggleable: this.opts.multiselect === true,
        parent: this.id
      }));
    });
  }

  _renderGroups(groups) {
    if (!(0, _utils.isset)(this._groupsById)) {
      this._groupsById = {};
    }

    this._groups = (groups || []).map((config, index) => {
      const localConfig = (0, _utils.cloneDeep)(config);
      localConfig.id = localConfig.id || `${this.id}-${index}`;
      localConfig.options = (0, _utils.extend)({}, this.options, localConfig.options);
      const group = new _ButtonSegmentGroup.default(Object.assign({
        filter: this.opts.filter,
        multiselect: this.opts.multiselect,
        requiresSelection: this.opts.groupMultiselect === true,
        reloadOnChange: this.opts.reloadOnChange,
        parentId: this.id
      }, localConfig));
      this._groupsById[localConfig.id] = group;
      return group;
    });
  }

  _onAddedToDOM() {
    super._onAddedToDOM();

    if (this._groups && this.ui.groups) {
      this._groups.forEach(group => {
        group.addTo(this.ui.groups);
        group.on('change', e => {
          const {
            id,
            value,
            reload
          } = e.data || {};

          if (this.opts.groupMultiselect === false && (0, _utils.isset)(value)) {
            this._groups.forEach(target => {
              if (target.id !== id) {
                target.clear(false);
              }
            });
          }

          this._handleValueChange({
            reload
          });
        });
      });
    } else if (this._segments && this.ui.segments) {
      const $target = (0, _DOM.default)('ul', this.ui.segments);

      this._segments.forEach(segment => {
        segment.addTo($target);
        segment.on("select"
        /* SELECT */
        , e => {
          this._handleSelectSegment(segment, this.selected);
        }).on("deselect"
        /* DESELECT */
        , e => {
          this._handleDeselectSegment(segment, this.selected);
        });
      });
    } // set initial value based on currently selected segments


    this._value = this.value;
  }

  _setupEvents() {
    super._setupEvents(); // this.on('select', () => {
    // 	this._showSegments(true);
    // }).on('deselect', () => {
    // 	this._showSegments(false);
    // });


    if (this.ui.groups) {
      this.ui.groups.on('click', e => {
        e.stopPropagation();
      });
    }
  }

  _handleSelectSegment(segment, triggerEvents = true) {
    const allowMultiselect = this.opts.multiselect && segment.value !== 'all' && segment.multiselect !== false; // this.selectedSegmentsProp('multiselect').forEach((allow) => {
    // 	if (!allow) allowMultiselect = false;
    // })

    if (allowMultiselect === false) {
      this.selectedSegments().forEach(item => {
        if (item.value !== segment.value) {
          item.deselect();
        }
      });
    } else {
      // deselect all segments that don't support multiselect
      this.selectedSegments().forEach(item => {
        if (item.multiselect === false) {
          item.deselect();
        }
      });
    }

    if (this.opts.onSelectSegment) {
      this.opts.onSelectSegment(segment);
    }

    this._handleValueChange({
      reload: this.opts.filter && this.opts.reloadOnChange
    }, triggerEvents);
  }

  _handleDeselectSegment(segment, triggerEvents = true) {
    if (this.state.selected) {
      const selectedCount = this.selectedSegments().length; // console.log('handleDeselectSegment', segment.id, segment.key, segment.value, triggerEvents, selectedCount);

      if (selectedCount === 0) {
        // if no selection and we have non-multiselect options (or 'all'), then select
        // that one instead by default
        if (this.opts.multiselect) {
          let selectedSegment;
          this.segments().forEach(item => {
            if (!selectedSegment && (item.value === 'all' || item.multiselect === false)) {
              item.select();
              selectedSegment = item;
            }
          });
        } else {// this.deselect();
        }
      }

      if (this.opts.onDeselectSegment) {
        this.opts.onDeselectSegment(segment);
      }
    }

    this._handleValueChange({
      reload: this.opts.filter && this.opts.reloadOnChange
    }, triggerEvents);
  }

  _showSegments(show) {
    var _a;

    if (show) {
      if (this._value && this._value.length > 0) {
        this._handleValueChange();
      } else if (this._groups && this._groups.length > 0) {
        let lastSelectedSegment = null;

        this._groups.forEach(group => {
          if (group.segments.length > 0 && (!(0, _utils.isset)(lastSelectedSegment) || this.opts.groupMultiselect === true)) {
            group.segments[0].select();
            lastSelectedSegment = group.segments[0];
          }
        });
      } else {
        const segments = this.segments();
        (_a = segments[0]) === null || _a === void 0 ? void 0 : _a.select();
      }
    }

    let height = 0;
    let collapseTarget = this.ui.segments;

    if (this.ui.groups && this.ui.groups.length > 0) {
      collapseTarget = this.ui.groups;
      height = this.ui.groups.children().reduce((val, el) => {
        val += (0, _DOM.default)(el).outerHeight(true);
        return val;
      }, 0);
    } else {
      height = (0, _DOM.default)('ul', this.ui.segments).height();
    }

    collapseTarget.css({
      'max-height': `${show ? height : 0}px`
    });

    if (this._triggerTimeout) {
      clearTimeout(this._triggerTimeout);
    }

    this._expanded = show;
    this._triggerTimeout = setTimeout(() => {
      const eventName = show ? 'expanded' : 'collapsed';
      this.trigger(eventName);
    }, show ? 0 : 600);
  }

}

var _default = SegmentedButton;
exports.default = _default;
module.exports = exports.default;