"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _EventDispatcher = _interopRequireDefault(require("../../event/EventDispatcher"));

var _utils = require("../../utils");

var _strings = require("../../utils/strings");

var _layout = require("../../utils/layout");

var _DOM = _interopRequireDefault(require("../../display/DOM"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * A `View` object is the base class used for view and component classes.
 *
 * @export
 * @class View
 * @extends {EventDispatcher}
 * @template T
 */
class View extends _EventDispatcher.default {
  /**
   * Initializes and returns a view instance using the specified configuration options.
   *
   * @param {T} [opts]
   * @param {*} [data]
   * @memberof View
   */
  constructor(opts, data) {
    super();
    this._renderCount = 0;
    opts = (0, _utils.extend)({
      className: (0, _strings.prefixCSSClassName)('app__view'),
      renderer: null,
      requiresData: false
    }, opts);
    this._opts = opts; // this._target = $('<div></div>');

    this._ui = {};
    this._needsRender = true;
    this._data = (0, _utils.cloneDeep)(data); // this._DOMObserver = new MutationObserver((mutations: any, observer: any) => {
    // 	// console.log(mutations);
    // 	mutations.forEach((mutation: MutationRecord) => {
    // 		console.log(mutation.type, mutation.target, mutation.addedNodes);
    // 	});
    // });
    // this._DOMObserver.observe(this._target[0], { childList: true, subtree: true });
    // this.render(data);
  }
  /**
   * DOM element associated with the view.
   *
   * @readonly
   * @type {*}
   * @memberof View
   */


  get $el() {
    return this._target;
  }
  /**
   * Identifier associated with the view.
   *
   * @readonly
   * @type {string}
   * @memberof View
   */


  get id() {
    return this.opts.id;
  }
  /**
   * Configuration options.
   *
   * @readonly
   * @type {T}
   * @memberof View
   */


  get opts() {
    return this._opts;
  }
  /**
   * Interface DOM targets, which are only available after the view has been rendered to the DOM.
   *
   * @readonly
   * @type {{ [key: string]: any }}
   * @memberof View
   */


  get ui() {
    return this._ui;
  }
  /**
   * Data used when rendering the view, if any.
   *
   * @readonly
   * @type {*}
   * @memberof View
   */


  get data() {
    return this._data;
  }

  get isRendered() {
    return this._renderCount > 0 && typeof this._target.parent() !== 'undefined';
  }

  get isMounted() {
    return (0, _utils.isset)(this.parent());
  }

  el(selector) {
    return (0, _DOM.default)(selector, this.$el);
  }

  initialize(data) {
    data = Object.assign(Object.assign({}, this._data), data);

    let content = this._render(data);

    if (content) {
      content = content.replace(/^[^<]+/, '').replace(/[\n\r\t.]+$/, '');
      this._target = (0, _DOM.default)(content);

      this._afterRender();
    }
  }
  /**
   * Adds the view's element to the DOM by appending it to the specified target.
   *
   * @param {(HTMLElement | string)} target DOM target in which the view will be appended
   * @param {boolean} [replace=false] Whether the view should replace the target's existing
   * content
   * @param {number} [index=-1] Index within the target's children at which the view is
   * inserted, if applicable. If the value is `-1` or greater than the total number of
   * children, the view is appened to the end of the target.
   * @memberof View
   */


  addTo(target, replace = false, index = -1) {
    if (!target) {
      throw new Error('[Aeris] Invalid DOM target specified for View.addTo()');
    }

    const $target = (0, _DOM.default)(target);

    if (replace) {
      $target.empty();
    } // if (this._needsRender) {
    // 	this.render(this._data);
    // }
    // if (this.opts.requiresData && isEmpty(this.data)) {
    // 	return false;
    // }


    const content = this._render(this._data);

    if (index >= 0) {
      const children = $target.children();

      if (index >= children.length) {
        $target.append(content);
        this._target = $target.children().last();
      } else {
        (0, _DOM.default)(children[index]).before(content);
        this._target = (0, _DOM.default)($target.children()[index]);
      }
    } else {
      $target.append(content);
      this._target = $target.children().last();
    }

    this._afterRender();

    if (this.opts.requiresData && (0, _utils.isEmpty)(this.data)) {
      this.hide();
    }

    if (!this._target) {
      return false;
    }

    this._lastSize = this.size();

    if (this._opts.ui) {
      this.setUI(this._opts.ui);
    }

    if (this.opts.className) {
      this.$el.addClass((0, _strings.prefixCSSClassName)(this.opts.className));
    }

    this._onAddedToDOM();

    this._layout();

    this._setupEvents();

    this._afterEvents();

    this.trigger('render');
    (0, _DOM.default)(window).on('resize', () => {
      this._onResize();
    });
    return true;
  }

  setIndex(index) {
    const $parent = this.$el.parent();
    const currentIndex = this.index();

    if ($parent && currentIndex !== index) {
      this.$el.remove();
      const children = $parent.children();
      const targetIndex = Math.min(index, children.length) - 1;
      (0, _DOM.default)(children[targetIndex]).after(this.$el);
      this._target = (0, _DOM.default)($parent.children()[index]);
    }
  }

  index() {
    const $parent = this.$el.parent();

    if ($parent) {
      const children = $parent.children();
      return children.indexOf(this.$el[0]);
    }

    return -1;
  }
  /**
   * Removes the view from the DOM.
   *
   * @memberof View
   */


  remove(removeEvents = false) {
    if (this.$el) {
      this.$el.remove();
    }

    if (removeEvents) {
      this.offAll();
    }
  }
  /**
   * Shows the view.
   *
   * @memberof View
   */


  show() {
    if (this.$el) {
      this.$el.show();
      this.trigger('show');
    }
  }
  /**
   * Hides the view.
   *
   * @memberof View
   */


  hide() {
    if (this.$el) {
      this.$el.hide();
      this.trigger('hide');
    }
  }
  /**
   * Parent DOM target, if any. Parent will be `null` if the view has not been added to the DOM.
   *
   * @returns {*}
   * @memberof View
   */


  parent() {
    if (this.$el) {
      const result = this.$el.parent();

      if (result && result.length > 0 && result[0] !== null) {
        return result;
      }
    }

    return null;
  }
  /**
   * Returns the view's current size.
   *
   * @returns {Size}
   * @memberof View
   */


  size() {
    if (!this.$el) {
      return {
        width: 0,
        height: 0
      };
    }

    return {
      width: this.$el.outerWidth(true),
      height: this.$el.outerHeight(true)
    };
  }

  setSize(width, height) {
    if (width === 0 && height === 0) return;
    const size = this.size();

    if (width > 0) {
      size.width = width;
    }

    if (height > 0) {
      size.height = height;
    }

    this.$el.css({
      width: `${size.width}px`,
      height: `${size.height}px`
    });

    this._onResize();
  }

  layout() {
    this._layout();
  }

  bounds(absolute = false, relative = null) {
    if (this.$el) {
      return this.$el.bounds(absolute, relative);
    }

    return {
      top: 0,
      bottom: 0,
      left: 0,
      right: 0,
      width: 0,
      height: 0
    };
  }

  update(data, replace = true) {
    if (data) {
      data = this._onData(data);

      if ((0, _utils.isArray)(data)) {
        this._data = (0, _utils.cloneDeep)(data);
      } else {
        this._data = Object.assign(Object.assign({}, this._data), (0, _utils.cloneDeep)(data));
      }
    }

    if (this.$el && replace) {
      const content = this._render(this._data);

      this._target = this.$el.replace(content);

      this._afterRender();

      this.trigger('render');

      if (this.opts.requiresData && (0, _utils.isEmpty)(data)) {
        this.hide();
      } else {
        this.show();
      }
    }
  }
  /**
   * Assigns the UI targets according to the view's configured interface selectors.
   *
   * Note that this method should only be called after the view has been rendered and added to
   * the DOM.
   *
   * @param {{ [key: string]: string }} mapping
   * @returns
   * @memberof View
   */


  setUI(mapping) {
    if (!this.$el) return;
    Object.keys(mapping).forEach(key => {
      try {
        const result = (0, _DOM.default)(mapping[key], this.$el);

        if (result && result.length > 0) {
          this._ui[key] = result;
        } else {
          this._ui[key] = null;
        }
      } catch (e) {
        console.warn(e);
      }
    });
  }
  /**
   * Updates the view's position to the specified x and y values with optional offsets. The view
   * must be configured with absolute positioning.
   *
   * @param {Point} position
   * @param {{ x: number, y: number }} [offset={ x: 0, y: 0 }]
   * @memberof View
   */


  moveTo(position, offset = {
    x: 0,
    y: 0
  }) {
    let x = position.x;
    let y = position.y;
    x += offset.x;
    y += offset.y;
    this.$el.css({
      left: `${x}px`,
      top: `${y}px`
    });
  }
  /**
   * Positions the view by pinning it relative to its parent container. The view must be
   * configured with absolute positioning.
   *
   * @param {AnchorType} position Anchor position of the view within its container
   * @param {{ x: number, y: number }} [offset] Offsets relative to the pinned position
   * @memberof View
   */


  pinTo(position, offset) {
    const $parent = this.parent();
    position = position.replace(/-/, '');
    offset = (0, _utils.extend)({
      x: 0,
      y: 0
    }, offset);
    this.$el.addClass(`awxjs__app__view__pinned-${position}`);

    if ($parent) {
      const parent = $parent.bounds();
      const pos = (0, _layout.getPinnedPosition)(position, this.size(), {
        width: parent.width,
        height: parent.height
      }, offset);
      const horizontal = /right/.test(position) ? 'right' : 'left';
      const vertical = /bottom/.test(position) ? 'bottom' : 'top';
      const style = window.getComputedStyle(this.$el[0]);

      if (style && style.transform !== 'none') {
        const matrixType = style.transform.replace(/\(.+$/, '');
        const transformMatrix = style.transform.replace(/[^0-9,-]/g, '').split(',').map(v => parseFloat(v)); // adjust postion based on transform matrix translations

        if (matrixType === 'matrix') {
          const [a, b, c, d, tx, ty] = transformMatrix;
          pos.x -= tx / 2;
          pos.y -= ty / 2;
        }
      } // if horizontal or vertical positions are right/bottom, then just use the offset
      // values for the position but the inverse


      if (horizontal === 'right') pos.x = offset.x * -1;
      if (vertical === 'bottom') pos.y = offset.y * -1;
      const props = {};
      props[horizontal] = `${pos.x}px`;
      props[vertical] = `${pos.y}px`;
      this.$el.css(props);
    }
  } // /**
  //  * Renders the view.
  //  *
  //  * If `data` is provided, the view will be rendered with the specified data. Otherwise, the
  //  * existing data will be used, if any.
  //  *
  //  * @param {*} [data]
  //  * @memberof View
  //  */
  // public render(data?: any) {
  // 	if (!this.$el || this.$el.length === 0) return;
  // 	if (data) this._data = cloneDeep(data);
  // 	data = data || {};
  // 	// if view requires data but data is empty, then don't render or show this view
  // 	if (this.opts.requiresData && isEmpty(data)) {
  // 		this.$el.hide();
  // 		this.$el.empty();
  // 		return;
  // 	}
  // 	if (this.$el.css('display') === 'none') {
  // 		this.$el.show();
  // 	}
  // 	this._beforeRender();
  // 	const renderer = this.opts.renderer;
  // 	let output: string;
  // 	if (renderer) {
  // 		if (isFunction(renderer)) {
  // 			output = (<Function>renderer)(data);
  // 		} else if (isString(renderer)) {
  // 			output = <string>renderer;
  // 		}
  // 	} else {
  // 		output = this._render(data);
  // 	}
  // 	if (isset(output)) {
  // 		this.$el.html(output);
  // 		this._renderCount += 1;
  // 	}
  // 	this._needsRender = false;
  // 	if (this._opts.ui) {
  // 		this.setUI(this._opts.ui);
  // 	}
  // 	this._afterRender();
  // }


  _render(data) {
    return '<div></div>';
  }

  _layout() {}

  _onData(data) {
    return data;
  }

  _beforeRender() {}

  _afterRender() {
    this._renderCount += 1;
  }

  _setupEvents() {}

  _afterEvents() {}

  _onAddedToDOM() {}

  _onResize() {
    if (this._shouldLayout()) {
      this._layout();
    }

    this._lastSize = this.size();
  }

  _shouldLayout() {
    const size = this.size();

    if (size.width !== this._lastSize.width || size.height !== this._lastSize.height) {
      return true;
    }

    return false;
  }

}

var _default = View;
exports.default = _default;
module.exports = exports.default;