"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _EventDispatcher = _interopRequireDefault(require("../../event/EventDispatcher"));

var _KeyObserver = _interopRequireDefault(require("./observers/KeyObserver"));

var _utils = require("../../utils");

var icons = _interopRequireWildcard(require("./icons"));

var _DOM = _interopRequireDefault(require("../../display/DOM"));

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @ignore
 * Check whether value is a window object.
 *
 * Uses duck typing to determine window. Without IE8 all we need is:
 *
 *   var type = Object.prototype.toString.call(val);
 *   return type === '[object global]' || type === '[object Window]' || type === '[object DOMWindow]';
 *
 * @param  {Mixed} val
 * @return {Boolean}
 */
const isWindow = val => {
  const doc = val ? val.document : null;
  const docWin = doc ? doc.defaultView || doc.parentWindow : null;
  return !!(val && typeof val === 'object' && typeof val.window === 'object' && val.window === val && val.setTimeout && val.alert && (0, _utils.isset)(doc) && typeof doc === 'object' && (0, _utils.isset)(docWin) && typeof docWin === 'object' && docWin === val);
};
/**
 * @ignore
 */


const transitionDuration = element => {
  const computed = window.getComputedStyle(element);
  const duration = String(computed.getPropertyValue('transition-duration') || computed.getPropertyValue('-webkit-transition-duration'));
  const match = duration.match(/([0-9.]+)([ms]{1,2})/);
  let val = 0;

  if (match) {
    val = Number(match[1]);
    if (match[2] === 's') val *= 1000;
  }

  return val || 0;
};
/**
 * @ignore
 * Returns element's position object with `left`, `top`, `bottom`, `right`,
 * `width`, and `height` properties indicating the position and dimensions
 * of element on a page, or relative to other element.
 *
 * @param {Element} element
 * @param {Element} [relativeTo] Defaults to `document.documentElement`.
 *
 * @return {Object|null}
 */


const position = (element, relativeTo) => {
  const isWin = isWindow(element);
  const doc = isWin ? element.document : element.ownerDocument || element;
  const docEl = doc.documentElement;
  const win = isWindow(relativeTo) ? relativeTo : doc.defaultView || window; // normalize arguments

  if (element === doc) element = docEl;
  relativeTo = !relativeTo || relativeTo === doc ? docEl : relativeTo;
  const winTop = (win.pageYOffset || docEl.scrollTop) - docEl.clientTop;
  const winLeft = (win.pageXOffset || docEl.scrollLeft) - docEl.clientLeft;
  const box = {
    top: 0,
    left: 0,
    right: 0,
    bottom: 0,
    width: 0,
    height: 0
  };

  if (isWin) {
    box.width = win.innerWidth || docEl.clientWidth;
    box.height = win.innerHeight || docEl.clientHeight;
    box.right = box.width;
    box.bottom = box.height;
  } else if (element === docEl) {
    // we need to do  this manually because docEl.getBoundingClientRect
    // is inconsistent in <IE11
    box.top = -winTop;
    box.left = -winLeft;
    box.width = Math.max(docEl.clientWidth, docEl.scrollWidth);
    box.height = Math.max(docEl.clientHeight, docEl.scrollHeight);
    box.right = box.width - winLeft;
    box.bottom = box.height - winTop;
  } else if (docEl.contains(element) && element.getBoundingClientRect) {
    // new object needed because DOMRect properties are read-only
    const bounds = element.getBoundingClientRect();
    Object.keys(box).forEach(key => {
      box[key] = bounds[key];
    }); // width & height don't exist in <IE9

    box.width = box.right - box.left;
    box.height = box.bottom - box.top;
  } else {
    return null;
  } // current box is already relative to window


  if (relativeTo === win) return box; // add window offsets, making the box relative to documentElement

  box.top += winTop;
  box.left += winLeft;
  box.right += winLeft;
  box.bottom += winTop; // current box is already relative to documentElement

  if (relativeTo === docEl) return box; // subtract position of other element

  const relBox = position(relativeTo);
  box.left -= relBox.left;
  box.right -= relBox.left;
  box.top -= relBox.top;
  box.bottom -= relBox.top;
  return box;
};

let activeTooltip;
/**
 * A `Tooltip` is a component for displaying additional information or content in a popover when
 * the target element is hovered over or clicked on.
 *
 * @export
 * @class Tooltip
 * @extends {EventDispatcher}
 */

class Tooltip extends _EventDispatcher.default {
  /**
   * Initializes and returns a tooltip instance configured with the specified content and options.
   *
   * @param {(string | HTMLElement)} [content]
   * @param {TooltipOptions} [opts]
   * @memberof Tooltip
   */
  constructor(content, opts) {
    super();
    this._size = {
      width: 0,
      height: 0
    };
    this._observers = {
      mutation: undefined,
      key: new _KeyObserver.default()
    };

    this._reposition = () => {
      const raf = window.requestAnimationFrame || window.webkitRequestAnimationFrame || (fn => {
        return setTimeout(fn, 17);
      });

      const requestReposition = () => {
        raf(() => {
          this.position();
        });
      };

      requestReposition();
    };

    this._opts = (0, _utils.extend)({
      place: 'top',
      effect: 'slide',
      spacing: 5,
      showClose: false
    }, opts);
    this._hidden = true;
    this._element = (0, _DOM.default)('<div class="awxjs__ui-tooltip"></div>');
    const closeBtn = this._opts.showClose ? `
			<button class="awxjs__ui-btn-icon-sm awxjs__ui-tooltip-close">
				${icons.close()}
			</button>
		` : '';
    this.$el.html(`
			${closeBtn}
			<div class="awxjs__ui-tooltip-content"></div>
		`);

    if (this._opts.className) {
      this.$el.addClass(this._opts.className);
    }

    if (this._opts.effect) {
      this.$el.addClass(this._opts.effect);
    }

    if (content) {
      this.setContent(content);
    }

    this._observers.key.on('escape', () => {
      this.hide();
    }); // observe when DOM elements are removed from the DOM tree and check if the tooltip's
    // target still exists, otherwise remove the tooltip from the DOM


    this._observers.mutation = new MutationObserver((records, observer) => {
      if (records && this._target.length > 0) {
        const target = this._target[0];
        records.forEach(record => {
          if (record.removedNodes && record.removedNodes.length > 0) {
            if (document.body.contains(target) === false) {
              this.destroy();
            }
          }
        });
      }
    });
  }
  /**
   * DOM element.
   *
   * @readonly
   * @type {*}
   * @memberof Tooltip
   */


  get $el() {
    return this._element;
  }

  get $content() {
    return (0, _DOM.default)('.awxjs__ui-tooltip-content', this.$el);
  }

  get $close() {
    return (0, _DOM.default)('.awxjs__ui-tooltip-close', this.$el);
  }
  /**
   * Target DOM element.
   *
   * @readonly
   * @type {*}
   * @memberof Tooltip
   */


  get $target() {
    return this._target;
  }
  /**
   * Size of the tooltip.
   *
   * @readonly
   * @type {Size}
   * @memberof Tooltip
   */


  get size() {
    return this._size;
  }
  /**
   * A Boolean indicating whether the tooltip is currently visible.
   *
   * @readonly
   * @type {boolean}
   * @memberof Tooltip
   */


  get visible() {
    return this._hidden === false;
  }
  /**
   * Shows the tooltip from the previously configured target.
   *
   * To present the tooltip from a different target, call `attachTo()` before showing the
   * tooltip.
   *
   * @param {boolean} [hideOthers=true] A Boolean indicating whether all existing tooltips
   * should be hidden when showing this instance.
   * @returns {Tooltip}
   * @memberof Tooltip
   */


  show(hideOthers = true) {
    clearTimeout(this._hideTimeout);

    if (activeTooltip && hideOthers) {
      activeTooltip.hide();
      activeTooltip = this;
    }

    if (this._target) {
      this.position(this._target);
    }

    if (this._hidden) {
      this._hidden = false;
      (0, _DOM.default)('body').append(this.$el);
    }

    this._observers.key.start();

    this.$close.on('click', this.hide.bind(this));
    (0, _DOM.default)(window).on('scroll resize', this._reposition); // trigger layout and start the transition

    setTimeout(() => {
      this.$el.addClass('in');
    }, 100);
    return this;
  }
  /**
   * Hides the tooltip.
   *
   * @returns {Tooltip}
   * @memberof Tooltip
   */


  hide() {
    if (this._hidden) {
      return this;
    }

    this._observers.key.stop();

    this.$close.off('click', this.hide.bind(this));
    this.$el.removeClass('in');
    (0, _DOM.default)(window).off('scroll resize', this._reposition);
    clearTimeout(this._hideTimeout);
    const duration = transitionDuration(this.$el[0]);
    this._hideTimeout = setTimeout(() => {
      this.$el.remove();
    }, duration);
    this._hidden = true;
    return this;
  }
  /**
   * Toggles the visibility of the tooltip.
   *
   * @returns {Tooltip}
   * @memberof Tooltip
   */


  toggle() {
    if (this.visible) {
      return this.hide();
    }

    return this.show();
  }
  /**
   * Sets the content, which can either be a text string or HTML string.
   *
   * @param {(string | HTMLElement)} content
   * @returns {Tooltip}
   * @memberof Tooltip
   */


  setContent(content) {
    if ((0, _utils.isString)(content)) {
      this.$content.html(content);
    } else {
      this.$content.empty().append(content);
    }

    this._updateSize();

    return this;
  }
  /**
   * Sets the current target.
   *
   * @param {*} element
   * @returns {Tooltip}
   * @memberof Tooltip
   */


  attachTo(element) {
    this._target = element;

    if (element) {
      this._observers.mutation.disconnect();

      this._observers.mutation.observe(document, {
        childList: true,
        subtree: true
      });
    }

    if (!this._hidden) {
      this.position();
    }

    return this;
  }
  /**
   * Hides the tooltip and removes its associated with the current target.
   *
   * @returns {Tooltip}
   * @memberof Tooltip
   */


  detach() {
    this.hide();
    this._target = null;

    this._observers.mutation.disconnect();

    return this;
  }
  /**
   * Detaches the tooltip from its associated target and removes it from the DOM.
   *
   * @memberof Tooltip
   */


  destroy() {
    this.detach();
    this.$el.remove();
  }
  /**
   * Updates the tooltip's position.
   *
   * This method accepts either an x and y pixel coordinate from which to position the tooltip.
   * Alternatively, a single DOM element argument can be provided which will be used when
   * calculating the new position.
   *
   * @param {(number | Element)} [x]
   * @param {number} [y]
   * @returns {Tooltip}
   * @memberof Tooltip
   */


  position(x, y) {
    x = x || this._target;

    if (!(0, _utils.isset)(x) && this._p) {
      x = this._p[0];
      y = this._p[1];
    } else {
      this._p = [];
      if (x) this._p.push(x);
      if (y) this._p.push(y);
    }

    x = x[0] || x;
    const target = (0, _utils.isNumber)(x) ? {
      left: x || 0,
      right: x || 0,
      top: y || 0,
      bottom: y || 0,
      width: 0,
      height: 0
    } : position(x);

    if (!target) {
      return this;
    }

    const spacing = this._opts.spacing || 0;

    const newPlace = this._pickPlace(target);

    if (newPlace !== this._lastPlace) {
      if (this._lastPlace) {
        this.$el.removeClass(this._lastPlace);
      }

      this.$el.addClass(newPlace);
      this._lastPlace = newPlace;
    } // position the tip


    const anchor = this._lastPlace;
    const {
      width: w,
      height: h
    } = this.size;
    let top = 0;
    let left = 0;

    if (/^top/.test(anchor)) {
      top = target.top - h - spacing;
    } else if (/^bottom/.test(anchor)) {
      top = target.bottom + spacing;
    } else if (/^left/.test(anchor)) {
      left = target.left - w - spacing;
    } else if (/^right/.test(anchor)) {
      left = target.right + spacing;
    }

    if (/-left$/.test(anchor)) {
      left = target.right - w;
    } else if (/-right$/.test(anchor)) {
      left = target.left;
    } else if (/-top$/.test(anchor)) {
      top = target.bottom - h;
    } else if (/-bottom$/.test(anchor)) {
      top = target.top;
    }

    if (anchor === 'left' || anchor === 'right') {
      top = target.top + target.height / 2 - h / 2;
    } else if (anchor === 'top' || anchor === 'bottom') {
      left = target.left + target.width / 2 - w / 2;
    }

    this.$el.css({
      top: `${Math.round(top)}px`,
      left: `${Math.round(left)}px`
    });
    return this;
  }

  _updateSize() {
    if (this._hidden) {
      this.$el.css('visibility', 'hidden');
      (0, _DOM.default)('body').append(this.$el);
    }

    this._size = {
      width: this.$el.outerWidth(true),
      height: this.$el.outerHeight(true)
    };

    if (this._hidden) {
      this.$el.remove();
      this.$el.css('visibility', '');
    } else {
      this.position();
    }
  }

  _pickPlace(target) {
    const pos = position(window);

    const place = this._opts.place.split('-');

    const spacing = this._opts.spacing || 0;
    const verticals = ['top', 'bottom'];

    if (verticals.indexOf(place[0]) !== -1) {
      if (target.top - this.size.height - spacing <= pos.top) {
        place[0] = 'bottom';
      } else if (target.bottom + this.size.height + spacing >= pos.bottom) {
        place[0] = 'top';
      }

      switch (place[1]) {
        case 'left':
          if (target.right - this.size.width <= pos.left) {
            place[1] = 'right';
          }

          break;

        case 'right':
          if (target.left + this.size.width >= pos.right) {
            place[1] = 'left';
          }

          break;

        default:
          if (target.left + target.width / 2 + this.size.width / 2 >= pos.right) {
            place[1] = 'left';
          } else if (target.right - target.width / 2 - this.size.width / 2 <= pos.left) {
            place[1] = 'right';
          }

      }
    } else {
      if (target.left - this.size.width - spacing <= pos.left) {
        place[0] = 'right';
      } else if (target.right + this.size.width + spacing >= pos.right) {
        place[0] = 'left';
      }

      switch (place[1]) {
        case 'top':
          if (target.bottom - this.size.height <= pos.top) {
            place[1] = 'bottom';
          }

          break;

        case 'bottom':
          if (target.top + this.size.height >= pos.bottom) {
            place[1] = 'top';
          }

          break;

        default:
          if (target.top + target.height / 2 + this.size.height / 2 >= pos.bottom) {
            place[1] = 'top';
          } else if (target.bottom - target.height / 2 - this.size.height / 2 <= pos.top) {
            place[1] = 'bottom';
          }

      }
    }

    return place.join('-');
  }

}

var _default = Tooltip;
exports.default = _default;
module.exports = exports.default;