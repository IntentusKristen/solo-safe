"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _Component = _interopRequireDefault(require("./Component"));

var _utils = require("../../utils");

var _DOM = _interopRequireDefault(require("../../display/DOM"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

;
;
/**
 * A `Slider` is a component....
 */

class Slider extends _Component.default {
  /**
   * Initializes and returns a slider instance configured with the specified options.
   *
   * @param {SliderOptions} [opts]
   * @memberof Slider
   */
  constructor(opts) {
    opts = (0, _utils.extend)({
      range: {
        min: 0,
        max: 1
      },
      ticks: true,
      ui: {
        range: '.awxjs__ui-slider-span-inner',
        past: '.awxjs__ui-slider-span-past',
        future: '.awxjs__ui-slider-span-future',
        ticks: '.awxjs__ui-slider-ticks',
        indicator: '.awxjs__ui-slider-indicator'
      }
    }, opts, {
      className: (0, _utils.get)(opts, 'className') ? `ui-slider ${opts.className}` : 'ui-slider'
    });
    super(opts);
    this.setState({
      dragging: false
    });
    this._mouse = {
      x: 0,
      y: 0
    };
  }
  /**
   * A Boolean indicating whether the slider is currently being dragged.
   *
   * @readonly
   * @type {boolean}
   * @memberof Slider
   */


  get dragging() {
    const {
      dragging
    } = this.state;
    return dragging;
  }
  /**
   * Returns the size of the slider position indicator/handle.
   *
   * @returns {Size}
   * @memberof Slider
   */


  indicatorSize() {
    return {
      height: this.ui.indicator.outerHeight(true),
      width: this.ui.indicator.outerWidth(true)
    };
  }
  /**
   * Returns either the value for the current slider position or the value at the specified
   * position value, if provided.
   *
   * @param {number} [position]
   * @returns {number}
   * @memberof Slider
   */


  value(position) {
    if (!(0, _utils.isset)(this._x)) return null;

    if (!(0, _utils.isset)(position) || Number.isNaN(position)) {
      position = this.position();
    }

    return position * ((this.opts.range.max - this.opts.range.min) / (this._x.max - this._x.min));
  }
  /**
   * Updates the slider position based on the specified value.
   *
   * @param {number} value
   * @param {boolean} [fireEvents=true]
   * @memberof Slider
   */


  setValue(value, fireEvents = true) {
    this.setPosition(value / this._increment(), fireEvents);
  }

  position() {
    let x = this.ui.indicator.css('left');

    if ((0, _utils.isEmpty)(x) || !(0, _utils.isset)(x)) {
      x = '0px';
    }

    return Number.parseInt(x.replace(/[^0-9\.-]/g, ''), 10);
  }

  setPosition(pos, fireEvents = true) {
    if (Number.isNaN(pos) === false) {
      pos = Math.max(Math.min(pos, this._x.max), 0);
      this.ui.indicator.css('left', `${pos}px`);

      if (fireEvents) {
        this.trigger('change', {
          value: this.value(),
          position: this.position(),
          progress: this.progress()
        });
      }
    }
  }

  progress() {
    const delta = this._x.max - this._x.min;
    return (this.position() - this._x.min) / delta;
  }

  setProgress(progress, fireEvents = true) {
    const delta = this._x.max - this._x.min;
    const pos = Math.round(this._x.min + delta * progress);

    if (pos !== this.position()) {
      this.setPosition(pos, fireEvents);
    }
  }

  setDateRange(start, end) {
    const now = new Date().getTime();
    const range = end.getTime() - start.getTime();
    let past = 1;
    let future = 0;

    if (end.getTime() > now) {
      if (start.getTime() > now) {
        past = 0;
        future = 1;
      } else {
        past = (now - start.getTime()) / range;
        future = (end.getTime() - now) / range;
      }
    }

    if (past > 0) {
      past = Math.min(100, Math.round(past * 100 * 100) / 100);
      this.ui.past.css({
        width: `${past}%`
      }).show();
    } else {
      this.ui.past.hide();
    }

    if (future > 0) {
      future = Math.min(100, Math.round(future * 100 * 100) / 100);
      this.ui.future.css({
        width: `${future}%`
      }).show();
    } else {
      this.ui.future.hide();
    }
  }

  setTicks(ticks) {
    if (this.opts.ticks === true && this.ui.ticks) {
      const size = this.indicatorSize();
      const x = size.width / 2;
      const w = this.$el.width() - size.width;
      this.ui.ticks.css({
        left: `${x}px`,
        width: `${w}px`
      });
      this.ui.ticks.empty();
      Object.keys(ticks).sort().forEach(pos => {
        const per = parseFloat(pos) * 100;
        this.ui.ticks.append(`
					<div class="awxjs__ui-slider-tick" style="left:${per}%;">
						<div class="awxjs__ui-slider-tick-label">${ticks[pos]}</div>
					</div>
				`);
      });
    }
  }

  _render() {
    return `
			<div class="awxjs__ui-slider">
				<div class="awxjs__ui-slider-span">
					<div class="awxjs__ui-slider-span-inner">
						<div class="awxjs__ui-slider-span-item awxjs__ui-slider-span-past"></div>
						<div class="awxjs__ui-slider-span-item awxjs__ui-slider-span-future"></div>
					</div>
				</div>
				<div class="awxjs__ui-slider-ticks"></div>
				<div class="awxjs__ui-slider-indicator"></div>
			</div>
		`;
  }

  _layout() {
    const progress = (0, _utils.isset)(this._x) ? this.progress() : 0;
    this._x = {
      min: 0,
      max: this.$el.width() - this.ui.indicator.outerWidth(true)
    };
    this.setProgress(progress);

    if (this.ui.range) {
      const size = this.indicatorSize();
      const x = size.width / 2;
      const w = this._x.max - this._x.min;
      this.ui.range.css({
        left: `${x}px`,
        width: `${w}px`
      });
    }
  }

  _setupEvents() {
    const dragHandler = e => {
      this._handleDrag(e);
    };

    const mouseUpHandler = e => {
      (0, _DOM.default)(document).off('mousemove touchmove', dragHandler);
      (0, _DOM.default)(document).off('mouseup touchend', mouseUpHandler);
      this.setState({
        dragging: false
      });
      this.ui.indicator.removeClass('is-dragging');
      this.trigger('slide:stop', {
        mouse: this._mouse
      });
    };

    this.ui.indicator.on('mousedown touchstart', e => {
      e.preventDefault();
      this.setState({
        dragging: true
      });
      this._mouse.x = e.pageX;
      this._mouse.y = e.pageY;
      this.ui.indicator.addClass('is-dragging');
      this.trigger('slide:start', {
        mouse: this._mouse
      }); // add event listeners during drag event

      (0, _DOM.default)(document).on('mousemove touchmove', dragHandler);
      (0, _DOM.default)(document).on('mouseup touchend', mouseUpHandler);
    });
    this.ui.ticks.on('click', e => {
      let x = e.layerX; // if a child node was clicked, calculate x relative to its container

      if (e.target !== this.ui.ticks[0]) {
        const b = this.ui.ticks.bounds();
        x = e.x - b.left;
      }

      const pos = x / this.ui.ticks.width();
      this.setProgress(pos);
    }); // this.parent().on('mouseoff', mouseUpHandler);
  }

  _increment() {
    return (this._x.max - this._x.min) / (this.opts.range.max - this.opts.range.min);
  }

  _handleDrag(e) {
    const {
      dragging
    } = this.state;

    if (dragging) {
      const delta = e.pageX - this._mouse.x;
      let pos = this.position();

      if (delta === 0) {
        return;
      }

      pos += delta;
      this.setPosition(pos, true);
      this._mouse.x = e.pageX;
      this._mouse.y = e.pageY;
    }
  }

}

var _default = Slider;
exports.default = _default;
module.exports = exports.default;