"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _Component = _interopRequireDefault(require("./Component"));

var _SliderHandle = _interopRequireDefault(require("./SliderHandle"));

var _Tooltip = _interopRequireDefault(require("./Tooltip"));

var _utils = require("../../utils");

var _DOM = _interopRequireDefault(require("../../display/DOM"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @ignore
 */
const isValueOutOfRange = (value, min, max) => value < min || value > max;
/**
 * @ignore
 */


const getClosestPoint = (value, marks, step, min, max) => {
  const points = Object.keys(marks).map(parseFloat);

  if (step !== null) {
    const maxSteps = Math.floor((max - min) / step);
    const steps = Math.min((value - min) / step, maxSteps);
    const closest = Math.round(steps) * step + min;
    points.push(closest);
  }

  const diffs = points.map(point => Math.abs(value - point));
  return points[diffs.indexOf(Math.min(...diffs))];
};
/**
 * @ignore
 */


const getPrecision = step => {
  const str = step.toString();
  let precision = 0;

  if (str.indexOf('.') >= 0) {
    precision = str.length - str.indexOf('.') - 1;
  }

  return precision;
};
/**
 * @ignore
 */


const ensureValueInRange = (value, min, max) => {
  if (value <= min) {
    return min;
  }

  if (value >= max) {
    return max;
  }

  return value;
};
/**
 * @ignore
 */


const ensureValuePrecision = (value, marks, step, min, max) => {
  const v = getClosestPoint(value, marks, step, min, max);
  const closest = Number.isFinite(v) ? v : 0;
  return !(0, _utils.isset)(step) ? closest : parseFloat(closest.toFixed(getPrecision(step)));
};
/**
 * @ignore
 */


const isEventFromHandle = (e, handles) => {
  try {
    if ((0, _utils.isArray)(handles)) {
      return handles.some(element => e.target === element);
    }

    return Object.keys(handles).some(key => e.target === handles[key]);
  } catch (error) {
    return false;
  }
};
/**
 * @ignore
 */


const getHandlePosition = element => {
  const bounds = (0, _DOM.default)(element).bounds();
  return window.pageXOffset + bounds.left + bounds.width * 0.5;
};

const positionInfoForEvent = e => {
  if (e.touches) {
    const te = e;

    if (te.touches.length > 0) {
      return te.touches[0];
    }
  }

  return e;
};

;
/**
 * A `RangeSlider` is a slider component that allows you to define a value range and step interval
 * along the slider to allow a user to change values associated with the control.
 *
 * @export
 * @class RangeSlider
 * @extends {Component<RangeSliderOptions, RangeSliderState>}
 */

class RangeSlider extends _Component.default {
  /**
   * Initializes and returns a range slider instance configured with the specified options.
   *
   * @param {RangeSliderOptions} [opts]
   * @memberof RangeSlider
   */
  constructor(opts) {
    super((0, _utils.extend)({
      range: {
        min: 0,
        max: 100
      },
      count: 1,
      step: 10,
      marks: {},
      marksEvery: undefined,
      dots: true,
      disabled: false,
      tooltip: true,
      ui: {
        inner: '.awxjs__ui-slider-range-inner',
        track: '.awxjs__ui-slider-range-track',
        rail: '.awxjs__ui-slider-range-rail',
        steps: '.awxjs__ui-slider-range-steps',
        marks: '.awxjs__ui-slider-range-marks',
        handles: '.awxjs__ui-slider-range-handle'
      }
    }, opts, {
      className: (0, _utils.get)(opts, 'className') ? `ui-slider-range ${opts.className}` : 'ui-slider-range'
    }));
    this._handles = [];

    this._onBoundsChange = state => {
      const {
        bounds
      } = state;
      const offsets = bounds.map(value => this._offsetForValue(value));

      if ((0, _utils.isset)(this._handles) && this._handles.length <= offsets.length) {
        offsets.forEach((offset, index) => {
          const handleRef = this._handles[index];

          if (handleRef) {
            handleRef.updatePosition(offsets[index]);
          }
        });
      }

      this._onChange(state);
    };

    this._onChange = state => {
      if ((0, _utils.isEmpty)(this._handles)) return;
      const {
        bounds,
        handle
      } = state;
      const offsets = bounds.map(value => this._offsetForValue(value));
      const handleRef = this._handles[handle];

      if (handleRef) {
        handleRef.updatePosition(offsets[handle]);

        this._updateTooltip(bounds[handle], handle);
      }

      if (offsets.length === 1) {
        this.ui.track.css({
          left: '0%',
          width: `${offsets[0]}%`
        });
      } else {
        const range = offsets[offsets.length - 1] - offsets[0];
        this.ui.track.css({
          left: `${offsets[0]}%`,
          width: `${range}%`
        });
      }

      this.setState({
        bounds
      });

      const lower = this._getLowerBound();

      const upper = this._getUpperBound();

      this.ui.steps.children().forEach(el => {
        const $el = (0, _DOM.default)(el);
        const point = parseFloat($el.data('key'));
        const active = point === upper || point <= upper && point >= lower;

        if (active) {
          $el.addClass('awxjs__ui-slider-range-dot-active');
        } else {
          $el.removeClass('awxjs__ui-slider-range-dot-active');
        }
      });
      this.ui.marks.children().forEach(el => {
        const $el = (0, _DOM.default)(el);
        const point = parseFloat($el.data('key'));
        const active = point === upper || point <= upper && point >= lower;

        if (active) {
          $el.addClass('awxjs__ui-slider-range-mark-text-active');
        } else {
          $el.removeClass('awxjs__ui-slider-range-mark-text-active');
        }
      });
      this.trigger('change', {
        value: Object.assign({}, state.bounds)
      });
    };

    this._onStart = position => {
      const bounds = this.value;

      const value = this._valueAtPosition(position);

      const closest = this._getClosestBound(value);

      const prevMovedHandle = this._getBoundNeedMoving(value, closest);

      this.trigger('change:start', {
        value: this.value
      });
      this.setState({
        handle: prevMovedHandle,
        recent: prevMovedHandle
      });
      const prevValue = bounds[prevMovedHandle];
      if (value === prevValue) return;
      const nextBounds = [...this.state.bounds];
      nextBounds[prevMovedHandle] = value;
      this._lastMovedHandle = prevMovedHandle;

      this._onChange({
        bounds: nextBounds,
        handle: prevMovedHandle
      });
    };

    this._onEnd = (force = false) => {
      const {
        handle
      } = this.state;

      this._removeDocumentEvents();

      if ((0, _utils.isset)(handle) || force) {}

      this.setState({
        handle: null
      });
      this.trigger('change:end', {
        value: this.value
      });
    };

    this._onMove = (e, position) => {
      const {
        bounds,
        handle
      } = this.state;

      const value = this._valueAtPosition(position);

      const previous = bounds[handle];
      if (value === previous) return;

      this._moveTo(value);
    };

    this._onKeyboard = e => {};

    this._onMouseDown = e => {
      const target = e.target;

      const handleTargets = this._handles.map(handle => handle.$el[0]);

      if (handleTargets.indexOf(target) === -1) return;
      e.preventDefault();
      let position = positionInfoForEvent(e).pageX;

      if (isEventFromHandle(e, this._handles.map(handle => handle.$el)) === false) {
        this._dragOffset = 0;
      } else {
        const handlePosition = getHandlePosition(target);
        this._dragOffset = position - handlePosition;
        position = handlePosition;
      }

      this._removeDocumentEvents();

      this._onStart(position);

      this._addDocumentEvents();

      const {
        bounds,
        handle
      } = this.state;

      this._updateTooltip(bounds[handle], handle);

      this._tooltip.show(false);
    };

    this._onMouseUp = e => {
      this._tooltip.hide();

      this._onEnd();
    };

    this._onMouseMove = e => {
      if (!this.ui.rail) {
        this._onEnd();

        return;
      }

      const pos = positionInfoForEvent(e).pageX;

      this._onMove(e, pos - this._dragOffset);
    }; // if `value` is defined, check that it's divisible by the `step value, otherwise we won't
    // be able to show the correct range


    if ((0, _utils.isArray)(this.opts.value)) {
      const [from, to] = this.opts.value;
      const step = this.opts.step;

      if (from % step !== 0) {
        const msg = `[Aeris] The 'value' property passed to the range configuration
					([${from}, ${to}]) does not contain from/to values equally divisible by the
					step value (${step}, which may affect the rendered step range in the
					control.`;
        console.warn(msg.replace(/\s+/g, ' '));
      }
    }

    const initialValue = this.opts.value || Array(...Array(this.opts.count + 1)).map(() => this.opts.range.min);
    const bounds = initialValue.map((v, i) => this._trimAlignValue(v, i));
    this.setState({
      bounds
    });
    this._tooltip = new _Tooltip.default();
    this.update();
  }
  /**
   * Current value, which is an array of values corresponding to the bounds. The first value is
   * the minimum value in the range, whereas the second value in the array is the maximum value.
   *
   * @readonly
   * @type {number[]}
   * @memberof RangeSlider
   */


  get value() {
    const {
      bounds
    } = this.state;
    return bounds;
  }

  set value(bounds) {
    const value = bounds.map((v, i) => this._trimAlignValue(v, i));
    this.setState({
      bounds: value
    });

    this._onBoundsChange(this.state);
  } // public render(data?: any) {
  // 	const { bounds } = this.state;
  // 	if (!bounds) {
  // 		return;
  // 	}
  // 	super.render(data);
  // }


  _render() {
    const {
      bounds
    } = this.state;
    if (!bounds) return null;
    const {
      range: {
        min,
        max
      },
      marks,
      marksEvery,
      step
    } = this.opts;
    const range = max - min;
    const dots = this.opts.dots && step > 1;
    const points = Object.keys(marks).map(parseFloat).filter(value => value >= min && value <= max).sort((a, b) => a - b);

    if (dots) {
      for (let i = min; i <= max; i += step) {
        if (points.indexOf(i) === -1) {
          points.push(i);
        }
      }
    }

    const _marks = marks || {};

    if ((0, _utils.isset)(marksEvery)) {
      let every = 1;
      let modulo = false;

      if ((0, _utils.isString)(marksEvery)) {
        const str = `${marksEvery}`;
        modulo = /^%\s*\d+$/.test(str);
        every = parseInt(str.replace(/\D/, ''), 10);
      } else {
        every = parseInt(`${marksEvery}`, 10);
      }

      let n = min;
      let i = 0;

      while (n <= max) {
        const include = modulo ? n % every === 0 : i % every === 0;

        if (include) {
          const val = `${n}`;

          if (!(0, _utils.isset)(_marks[n])) {
            const formatter = this.opts.marksFormatter;
            _marks[val] = (0, _utils.isset)(formatter) && (0, _utils.isFunction)(formatter) ? formatter(n) : val;
          }
        }

        n += step;
        i += 1;
      } // update `marks` value on the main config


      (0, _utils.set)(this.opts, 'marks', _marks);
    }

    const labels = Object.keys(_marks).map(parseFloat).filter(value => value >= min && value <= max).sort((a, b) => a - b).map(point => {
      const label = _marks[point];

      if ((0, _utils.isEmpty)(label)) {
        return null;
      }

      const offset = `${Math.abs(point - min) / range * 100}%`;
      return `<div
					class="awxjs__ui-slider-range-mark-text"
					style="left:${offset};transform:translateX(-50%);msTransform:translateX(-50%);"
					data-key="${point}"
				>${label}</div>`;
    });
    const steps = points.map(point => {
      const offset = `${Math.abs(point - min) / range * 100}%`;
      return `<div
				class="awxjs__ui-slider-range-dot"
				style="left:${offset};"
				data-key="${point}"
			></div>`;
    }); // generate handle objects and append to container

    this._handles = bounds.map((value, index) => new _SliderHandle.default({
      values: {
        min,
        max,
        current: value
      }
    }));
    return `
			<div class="awxjs__ui-slider-range">
				${this.opts.title ? `<div class="awxjs__ui-slider-range-title">${this.opts.title}</div>` : ''}
				<div class="awxjs__ui-slider-range-inner">
					<div class="awxjs__ui-slider-range-rail"></div>
					<div class="awxjs__ui-slider-range-track"></div>
					<div class="awxjs__ui-slider-range-steps">${steps.join('')}</div>
					<div class="awxjs__ui-slider-range-marks">${labels.join('')}</div>
				</div>
			</div>
		`;
  }

  _afterRender() {
    const {
      bounds
    } = this.state;
    const offsets = bounds.map(value => this._offsetForValue(value));

    if (this.opts.ui) {
      this.setUI(this.opts.ui);

      if (this.ui.marks.children().length > 0) {
        this.$el.addClass('awxjs__ui-slider-range-with-marks');
      }

      this._setupEvents();

      if (this.opts.width > 0) {
        this.ui.inner.width(this.opts.width);
      }

      this._handles.forEach((handle, index) => {
        handle.addTo(this.ui.inner);
        handle.updatePosition(offsets[index]);
      });
    }

    this._onChange(this.state);
  }

  _setupEvents() {
    super._setupEvents();

    this.$el.on('mousedown touchstart', this._onMouseDown);
  }

  _getClosestBound(value) {
    const {
      bounds
    } = this.state;
    let closest = 0;

    for (let i = 1; i < bounds.length - 1; i += 1) {
      if (value > bounds[i]) {
        closest = i;
      }
    }

    if (Math.abs(bounds[closest + 1] - value) < Math.abs(bounds[closest] - value)) {
      closest += 1;
    }

    return closest;
  }

  _getBoundNeedMoving(value, closestBound) {
    const {
      bounds,
      recent
    } = this.state;
    let boundNeedMoving = closestBound;
    const atSamePoint = bounds[closestBound + 1] === bounds[closestBound];

    if (atSamePoint && bounds[recent] === bounds[closestBound]) {
      boundNeedMoving = recent;
    }

    if (atSamePoint && value !== bounds[closestBound + 1]) {
      boundNeedMoving = value < bounds[closestBound + 1] ? closestBound : closestBound + 1;
    }

    return boundNeedMoving;
  }

  _getLowerBound() {
    const {
      bounds
    } = this.state;
    const {
      range: {
        min,
        max
      }
    } = this.opts;

    if (bounds.length === 1) {
      return min;
    }

    return bounds[0];
  }

  _getUpperBound() {
    const {
      bounds
    } = this.state;
    return bounds[bounds.length - 1];
  }

  _getPoints() {
    const {
      marks,
      range: {
        min,
        max
      },
      step
    } = this.opts;
    const cache = this._points;

    if (!cache || cache.marks !== marks || cache.step !== step) {
      const points = Object.assign({}, marks);

      if ((0, _utils.isset)(step)) {
        for (let p = min; p <= max; p += step) {
          points[p] = p;
        }
      }

      const result = Object.keys(points).map(parseFloat);
      result.sort((a, b) => a - b);
      this._points = {
        marks,
        step,
        points: result
      };
    }

    return this._points.points;
  }

  _moveTo(value, isFromKeyboardEvent = false) {
    const {
      handle,
      recent,
      bounds
    } = this.state;
    const target = !(0, _utils.isset)(handle) ? recent : handle;
    const nextBounds = [...bounds];
    nextBounds[target] = value;
    const nextHandle = target;

    this._onChange({
      handle: nextHandle,
      bounds: nextBounds
    }); // if (isFromKeyboardEvent) {
    // }

  }

  _trimAlignValue(value, handle) {
    const {
      range: {
        min,
        max
      }
    } = this.opts;
    const inRange = ensureValueInRange(value, min, max);

    const notConflict = this._ensureValueNotConflict(inRange, handle);

    return ensureValuePrecision(notConflict, this.opts.marks, this.opts.step, this.opts.range.min, this.opts.range.max);
  }

  _ensureValueNotConflict(value, handle) {
    const {
      bounds,
      handle: stateHandle
    } = this.state;
    const allowCross = false;
    handle = !(0, _utils.isset)(handle) ? stateHandle : handle;

    if (!allowCross && (0, _utils.isset)(handle) && (0, _utils.isset)(bounds)) {
      if (handle > 0 && value <= bounds[handle - 1]) {
        return bounds[handle - 1];
      }

      if (handle < bounds.length - 1 && value >= bounds[handle + 1]) {
        return bounds[handle + 1];
      }
    }

    return value;
  }

  _valueAtPosition(pos) {
    const sliderBounds = this.ui.rail.bounds();
    const offset = pos - (sliderBounds.left + window.pageXOffset);

    const nextValue = this._trimAlignValue(this._valueAtOffset(offset));

    return nextValue;
  }

  _valueAtOffset(offset) {
    const {
      range: {
        min,
        max
      }
    } = this.opts;
    const length = this.ui.rail ? this.ui.rail.bounds().width : 0;
    const ratio = Math.abs(Math.max(offset, 0) / length);
    return ratio * (max - min) + min;
  }

  _offsetForValue(value) {
    const {
      range: {
        min,
        max
      }
    } = this.opts;
    const ratio = (value - min) / (max - min);
    return ratio * 100;
  }

  _updateTooltip(value, handle) {
    if ((0, _utils.isEmpty)(this._handles)) return;
    const handleRef = this._handles[handle];
    let str = value.toString();

    if ((0, _utils.isFunction)(this.opts.tooltip)) {
      str = this.opts.tooltip(value);
    }

    this._tooltip.setContent(str).position(handleRef.$el);
  }

  _addDocumentEvents() {
    (0, _DOM.default)(document).on('mousemove touchmove', this._onMouseMove).on('mouseup touchend', this._onMouseUp);
  }

  _removeDocumentEvents() {
    (0, _DOM.default)(document).off('mousemove touchmove', this._onMouseMove).off('mouseup touchend', this._onMouseUp);
  }

}

var _default = RangeSlider;
exports.default = _default;
module.exports = exports.default;