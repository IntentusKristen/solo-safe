"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _Component = _interopRequireDefault(require("./Component"));

var _utils = require("../../utils");

var _DOM = _interopRequireDefault(require("../../display/DOM"));

var _strings = require("../../utils/strings");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * A `Panel` is a view component that functions as a common view container for any type of
 * content within an application.
 *
 * @export
 * @class Panel
 * @extends {Component<T, S>}
 * @template T
 * @template S
 */
class Panel extends _Component.default {
  /**
   * Initializes and returns a panel instance configured with the specified options.
   *
   * @param {T} [opts]
   * @memberof Panel
   */
  constructor(opts) {
    opts = (0, _utils.extend)({
      enabled: true,
      toggleable: false,
      ui: {
        container: '.awxjs__app__ui-panel-container',
        toolbar: '.awxjs__app__ui-panel-toolbar',
        content: '.awxjs__app__ui-panel-content',
        toggle: '.awxjs__app__ui-panel-toggle',
        close: '.awxjs__app__ui-panel-close'
      }
    }, opts);
    opts.className = (0, _utils.isset)(opts.className) ? `app__ui-panel ${opts.className}` : 'app__ui-panel';
    super(opts);
    this._bounds = {};
    this.setState({
      visible: this.opts.toggleable !== true,
      maxContentSize: {
        width: 10000,
        height: 10000
      }
    });
  }

  get content() {
    return this.ui.content;
  }

  get toolbar() {
    return this.ui.toolbar;
  }
  /**
   * A Boolean indicating whether the panel is currently visible.
   *
   * @readonly
   * @type {boolean}
   * @memberof Panel
   */


  get visible() {
    const {
      visible
    } = this.state;
    return visible;
  }
  /**
   * Expands the panel if the panel is toggleable and collapsed.
   *
   * @returns
   * @memberof Panel
   */


  open() {
    if (this.opts.toggleable === false) return;
    this.setState({
      visible: true
    });

    this._updateSize();

    this.$el.addClass('awxjs__app__ui-panel-toggleable-open');
  }
  /**
   * Collapses the panel if the panel is toggleable and expanded.
   *
   * @returns
   * @memberof Panel
   */


  close() {
    if (this.opts.toggleable === false) return;
    this.setState({
      visible: false
    });

    this._updateSize();

    this.$el.removeClass('awxjs__app__ui-panel-toggleable-open');
  }
  /**
   * Toggles the open/closed state.
   *
   * @memberof Panel
   */


  toggle() {
    if (this.visible) {
      this.close();
    } else {
      this.open();
    }
  }
  /**
   * Returns the DOM element container for the view content.
   *
   * @returns {*}
   * @memberof Panel
   */


  getContentContainer() {
    return this.ui.content;
  }

  size() {
    if (!this.$el) {
      return {
        width: 0,
        height: 0
      };
    }

    let sizeTarget = this.$el; // if panel is toggleable, always return the size of the toggle button since that's used
    // to calculate pinned/anchored positions in its parent container

    if (this.opts.toggleable && this.ui.toggle) {
      sizeTarget = this.ui.toggle;
    } else if (this.ui.content) {
      sizeTarget = this.ui.content;
    }

    return {
      width: sizeTarget.outerWidth(true),
      height: sizeTarget.outerHeight(true)
    };
  }
  /**
   * Returns the size required for the panel's content.
   *
   * @returns {Size}
   * @memberof Panel
   */


  contentSize() {
    const size = {
      width: 0,
      height: 0
    };
    const $content = this.getContentContainer();
    const origHeight = $content[0].style.height;
    const origWidth = $content[0].style.width; // append a hidden copy of this element to the DOM just to calcaulate the proper size

    let classNames = (0, _strings.prefixCSSClassName)(this.opts.className);
    classNames = `awxjs__app__component ${classNames}`;
    let $copy = (0, _DOM.default)(`
			<div id="awxjs__panel-calc" class="${classNames}" style="display:inline-block;visibility:none;left:-10000px;width:${origWidth}">
				<div class="awxjs__app__ui-panel-content">
					${$content.html()}
				</div>
			</div>
		`);
    (0, _DOM.default)('body').append($copy);
    $copy = (0, _DOM.default)('#awxjs__panel-calc'); // copy width and height values from style in case they are set inline
    // $copy[0].style.height = $content[0].style.height;
    // $copy[0].style.width = $content[0].style.width;

    size.width = $copy.outerWidth(true);
    size.height = $copy.outerHeight(true);
    const innerSize = {
      width: 0,
      height: 0
    };
    $copy.children().forEach(child => {
      const style = window.getComputedStyle(child); // don't include absolute positioned children in the size calculation since they
      // aren't in the normal layout flow

      if (style.position !== 'absolute') {
        const $child = (0, _DOM.default)(child);
        innerSize.width = Math.max(size.width, $child.outerWidth(true));
        innerSize.height += $child.outerHeight(true);
      }
    });
    size.height = Math.max(size.height, innerSize.height);
    size.height = Math.min(size.height, this.state.maxContentSize.height);
    $copy.remove();
    return size;
  }

  setContentSize(size, adjustForToolbar = true) {
    if (adjustForToolbar) {
      size.height -= this.toolbar.outerHeight();
    }

    this.ui.content.css({
      'max-height': `${size.height}px`,
      width: `${size.width}px`,
      overflow: 'auto'
    });
  }

  setMaxContentSize(size) {
    this.setState({
      maxContentSize: size
    }); // update content size values to account for new max size

    const contentSize = this.contentSize();
    this.setContentSize(contentSize, false);

    this._updateSize();
  }

  _updateSize() {
    if (!this.opts.toggleable) return;
    if (!this.ui.close) return;
    const size = {
      width: 0,
      height: 0
    };

    if (this.visible && this._bounds.content) {
      let {
        height,
        width
      } = this.contentSize();
      const pad = this.ui.content.padding(); // width += (pad.left + pad.right);
      // height += (pad.bottom + this.ui.toolbar.outerHeight(true));

      height += this.ui.toolbar.outerHeight(true);
      size.width = width;
      size.height = height;
    } else if (!this.visible && this._bounds.toggle) {
      const {
        height,
        width
      } = this._bounds.toggle;
      size.width = width;
      size.height = height;
    } // console.log(this.id, size);
    // const bounds = this.$el.bounds();
    // size.height = Math.min(size.height, this.parent().height() - bounds.top * 2);


    this.ui.container.css({
      'max-height': `${size.height}px`,
      'max-width': `${size.width}px`
    });
    this.$el.css({
      'min-height': `${size.height}px`,
      'min-width': `${size.width}px`
    });
  }

  _render() {
    return `
			<div class="awxjs__app__ui-panel">
				<div class="awxjs__app__ui-panel-container">
					<div class="awxjs__app__ui-panel-toolbar">
						${this.opts.title ? `<div class="awxjs__app__ui-panel-title">${this.opts.title}</div>` : ''}
						<button class="awxjs__app__ui-panel-close">
							<svg version="1.1" viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg">
								<path d="m22.699 77.301c0.80078 0.80078 1.8008 1.1992 2.8008 1.1992s2-0.39844 2.8008-1.1992l21.699-21.602 21.699 21.699c0.80078 0.80078 1.8008 1.1992 2.8008 1.1992s2-0.39844 2.8008-1.1992c1.6016-1.6016 1.6016-4.1016 0-5.6992l-21.602-21.699 21.699-21.699c1.6016-1.6016 1.6016-4.1016 0-5.6992-1.6016-1.6016-4.1016-1.6016-5.6992 0l-21.699 21.699-21.699-21.602c-1.6016-1.6016-4.1016-1.6016-5.6992 0-1.6016 1.6016-1.6016 4.1016 0 5.6992l21.699 21.602-21.602 21.699c-1.5977 1.5-1.5977 4.1016 0 5.6016z"/>
							</svg>
						</button>
					</div>
					<div class="awxjs__app__ui-panel-content"></div>
					<div class="awxjs__app__ui-panel-toggle">${this.opts.icon}</div>
				</div>
			</div>
		`;
  }

  _layout() {
    super._layout();

    if (this.ui.content) {
      const size = this.contentSize();

      if (size.width > 0 && size.height > 0) {
        const pad = this.ui.content.padding();
        this._bounds.content = (0, _utils.extend)(this.ui.content.bounds(), {
          height: size.height + pad.top + pad.bottom,
          width: size.width + pad.left + pad.right
        });
      }
    }

    if (this.ui.toggle) {
      // this.ui.content.css({
      // 	height: `auto`,
      // 	width: `auto`
      // });
      this._bounds.toggle = this.ui.toggle.bounds();
    } // if (this._bounds.content) {
    // 	const bounds = this.contentSize();
    // 	// set static width and height on container if not toggleable for
    // 	// proper sizing and positioning
    // 	if (this.opts.toggleable === false) {
    // 		this.$el.css({
    // 			height: `${bounds.height}px`,
    // 			width: `${bounds.width}px`
    // 		});
    // 	}
    // }


    this._updateSize();
  }

  _afterRender() {
    super._afterRender();

    if (this.opts.toggleable) {
      this.$el.addClass('awxjs__app__ui-panel-toggleable');
    }
  }

  _onAddedToDOM() {
    super._onAddedToDOM();

    if (this.opts.toggleable) {
      this.close();
    }
  }

  _setupEvents() {
    if (this.opts.toggleable) {
      this.ui.toggle.on('click', () => {
        this.open();
      });
      this.ui.close.on('click', () => {
        this.close();
      });
    }
  }

}

var _default = Panel;
exports.default = _default;
module.exports = exports.default;