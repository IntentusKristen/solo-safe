"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _Panel = _interopRequireDefault(require("../ui/Panel"));

var _Button = _interopRequireDefault(require("../ui/buttons/Button"));

var _SegmentedButton = _interopRequireDefault(require("../ui/buttons/SegmentedButton"));

var _ButtonGroup = _interopRequireDefault(require("../ui/buttons/ButtonGroup"));

var _utils = require("../../utils");

var _DOM = _interopRequireDefault(require("../../display/DOM"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const getOpacityValue = (style = {}) => {
  let result = 1;

  if ((0, _utils.isset)(style.opacity)) {
    result = style.opacity;
  } else {
    ['polyline', 'polygon'].forEach(type => {
      const itemStyle = style[type];
      const styleRef = (0, _utils.isFunction)(itemStyle) ? itemStyle({}) : itemStyle;

      if (styleRef) {
        if (styleRef.fill) {
          result = styleRef.fill.opacity;
        } else if (styleRef.stroke) {
          result = styleRef.stroke.opacity;
        }
      }
    });
  }

  return result;
};

const createButton = config => {
  const opts = config;
  const btnType = opts.type;
  let result; // update any button controls based on other options associated with the button

  const controls = opts.controls;

  if (controls) {
    const settings = controls.settings;

    if ((0, _utils.isArray)(settings)) {
      (0, _utils.set)(opts, 'controls.settings', settings.map(setting => {
        var _a;

        const {
          type
        } = setting;

        if (type === 'opacity') {
          const opacity = getOpacityValue((_a = opts.options) === null || _a === void 0 ? void 0 : _a.style);

          if ((0, _utils.isset)(opacity)) {
            setting.options = Object.assign(Object.assign({}, setting.options), {
              value: [opacity * 100]
            });
          }
        }

        return setting;
      }));
    }
  }

  if (opts.buttons) {
    result = new _ButtonGroup.default(opts);
  } else if (opts.segments || opts.groups) {
    result = new _SegmentedButton.default(opts);
  } else {
    result = new _Button.default(opts);
  }

  return result;
};
/**
 * A panel that renders and manages a series of button elements to be used for toggling data on
 * and off at runtime.
 *
 * @export
 * @class ButtonPanelView
 * @extends {Panel<ButtonPanelViewOptions, PanelState>}
 */


class ButtonPanelView extends _Panel.default {
  /**
   * Initializes and returns a button panel instance for the specified configuration options.
   *
   * @param {ButtonPanelViewOptions} [opts]
   * @memberof ButtonPanel
   */
  constructor(opts) {
    super((0, _utils.extend)({
      icon: `
				<svg version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 100 80.5">
					<g>
						<path d="M98.5,51.3l-13.7-7.3L58,58.2c-2.5,1.3-5.2,2-8,2c-2.8,0-5.5-0.7-8-2L15.2,44.1L1.5,51.3C0.6,51.8,0,52.8,0,53.8
							s0.6,2,1.5,2.5l43.5,23c3.2,1.7,6.9,1.7,10.1,0l43.5-23c0.9-0.5,1.5-1.4,1.5-2.5S99.4,51.8,98.5,51.3L98.5,51.3z"/>
						<path d="M1.5,29.2l43.5,23c1.6,0.8,3.3,1.2,5,1.2c1.7,0,3.5-0.4,5-1.3l43.5-23c0.9-0.5,1.5-1.4,1.5-2.5c0-1-0.6-2-1.5-2.5L55,1.3
							C53.5,0.4,51.7,0,50,0c-1.7,0-3.4,0.4-5,1.3l-43.5,23C0.6,24.7,0,25.7,0,26.7C0,27.8,0.6,28.7,1.5,29.2L1.5,29.2z"/>
					</g>
				</svg>
			`
    }, opts));
  }
  /**
   * Panel button elements.
   *
   * @readonly
   * @type {Toggleable[]}
   * @memberof ButtonPanelView
   */


  get buttons() {
    return [...(this._buttons || [])];
  }

  buttonForId(id) {
    let result;
    this.buttons.forEach((button, index) => {
      if (!(0, _utils.isset)(result)) {
        if (button instanceof _ButtonGroup.default) {
          result = button.buttonForId(id);
        } else if (button.id === id && !(0, _utils.isset)(result)) {
          result = button;
        }
      }
    });
    return result;
  }

  buttonForKey(key) {
    let result;
    this.buttons.forEach((button, index) => {
      if (!(0, _utils.isset)(result)) {
        if (button instanceof _ButtonGroup.default) {
          result = button.buttonForKey(key);
        } else if (button.key === key && !(0, _utils.isset)(result)) {
          result = button;
        }
      }
    });
    return result;
  }
  /**
   * Adds a new button to the end of the set using the provided button configuration.
   *
   * @param {(SegmentedButtonOptions | ButtonOptions | ButtonGroupOptions)} config Button configuration
   * @param {boolean} [events=true] A Boolean indicating whether to automatically add the default
   * button events
   * @returns {Button<any, any>}
   * @memberof ButtonPanelView
   */


  add(config, events = true) {
    const index = this.buttons.length;
    return this.insertAt(index, config, events);
  }
  /**
   * Inserts a new button at a specific index in the set using the provided button configuration.
   *
   * @param {number} index Index to insert the button into
   * @param {(SegmentedButtonOptions | ButtonOptions | ButtonGroupOptions)} config Button configuration
   * @param {boolean} [events=true] A Boolean indicating whether to automatically add the default
   * button events
   * @returns
   * @memberof ButtonPanelView
   */


  insertAt(index, config, events = true) {
    if (!this._buttons) this._buttons = [];
    const button = createButton(config);

    if (index >= this._buttons.length) {
      this._buttons.push(button);

      index = -1;
    } else {
      index = Math.max(0, index);

      this._buttons.splice(index, 0, button);
    }

    this._appendButton(button, events, index);

    this.trigger("button:add"
    /* ADD_BUTTON */
    , {
      button
    });
    return button;
  }

  insertBefore(id, config, events = true) {
    const index = this._indexForId(id);

    if (index === 0) {
      return this.insertAt(0, config, events);
    }

    if (index > 0) {
      return this.insertAt(index - 1, config, events);
    }

    return this.add(config, events);
  }

  insertAfter(id, config, events = true) {
    const index = this._indexForId(id);

    if (index >= 0) {
      return this.insertAt(index + 1, config, events);
    }

    return this.add(config, events);
  }
  /**
   * Removes the button at the specified index.
   *
   * @param {number} index
   * @returns
   * @memberof ButtonPanelView
   */


  removeAt(index) {
    if (!(0, _utils.isset)(this._buttons) || index > this._buttons.length - 1 || index < 0) return;
    const button = this.buttons[index];

    if (button) {
      this._buttons.splice(index, 1);

      button.$el.remove();
      this.trigger("button:remove"
      /* REMOVE_BUTTON */
      , {
        button
      });
    }
  }
  /**
   * Removes the button for the specified identifier.
   *
   * @param {string} id
   * @memberof ButtonPanelView
   */


  removeForId(id) {
    let foundIndex = -1;
    this.buttons.forEach((button, index) => {
      if (button.id === id && foundIndex === -1) {
        foundIndex = index;
      }
    });

    if (foundIndex >= 0) {
      this.removeAt(foundIndex);
    }
  }
  /**
   * Select the buttons associated with the specified value or array of values.
   *
   * @param {(string | string[])} value
   * @memberof ButtonPanelView
   */


  select(value, checkIdOnly = false) {
    this.handleSelectionState(value, true, checkIdOnly);
  }
  /**
   * Deselects the buttons associated with the specified value or array of values.
   *
   * @param {(string | string[])} value
   * @memberof ButtonPanelView
   */


  deselect(value, checkIdOnly = false) {
    this.handleSelectionState(value, false, checkIdOnly);
  }

  set(id, value) {
    const button = this.buttonForId(id) || this.buttonForKey(id);

    if (button && button instanceof _SegmentedButton.default) {
      button.value = value;
    }
  }

  handleSelectionState(value, selected, checkIdOnly = false) {
    const _select = (button, _value) => {
      if (button instanceof _SegmentedButton.default) {
        const containsId = button.containsId(_value);
        const containsValue = button.containsValue(_value);

        if (checkIdOnly) {
          if (containsId) {
            button.selectSegment(_value);
          }
        } else if (containsId || containsValue) {
          button.selectSegment(_value);
        } else if (button.matches(_value)) {
          button.select();
        }
      } else if (button instanceof _Button.default) {
        if (button.matches(_value)) {
          button.select();
        }
      }
    };

    const _deselect = (button, _value) => {
      if (button instanceof _SegmentedButton.default) {
        const containsId = button.containsId(_value);
        const containsValue = button.containsValue(_value); // console.log('_deselect', _value, containsId, containsValue);

        if (button.matches(_value)) {
          button.deselect();
        } else if (checkIdOnly) {
          if (containsId) {
            button.deselectSegment(_value);
          }
        } else if (containsId || containsValue) {
          button.deselectSegment(_value);
        }
      } else if (button instanceof _Button.default) {
        if (button.matches(_value)) {
          button.deselect();
        }
      }
    };

    if ((0, _utils.isArray)(value)) {
      value.filter(v => !(0, _utils.isEmpty)(v)).forEach(v => this.handleSelectionState(v, selected));
    } else if (this.buttons) {
      this.buttons.forEach(button => {
        const val = value;

        if (button instanceof _ButtonGroup.default) {
          const group = button;
          group.buttons.forEach(btn => {
            if (selected) {
              _select(btn, val);
            } else {
              _deselect(btn, val);
            }
          });
        } else if (button instanceof _Button.default || button instanceof _SegmentedButton.default) {
          if (selected) {
            _select(button, val);
          } else {
            _deselect(button, val);
          }
        }
      });
    }
  } // /**
  //  * Returns the size required for the panel's content.
  //  *
  //  * @returns {Size}
  //  * @memberof Panel
  //  */
  // public contentSize(): Size {
  // 	const size = super.contentSize();
  // 	let height = 0;
  // 	if (this.ui.toolbar) {
  // 		height += this.ui.toolbar.outerHeight(true);
  // 	}
  // 	this.buttons.forEach((button) => {
  // 		if (button instanceof View) {
  // 			height += button.size().height;
  // 		}
  // 	});
  // 	// add container inner padding to height
  // 	const pad = this.ui.buttons.padding();
  // 	size.height = height + pad.top + pad.bottom;
  // 	return size;
  // }


  _onAddedToDOM() {
    this.ui.content.append('<div class="awxjs__app__ui-panel-buttons"></div>');
    this.ui.buttons = (0, _DOM.default)('.awxjs__app__ui-panel-buttons', this.$el);

    if (this.opts.buttons) {
      const results = [];
      const groups = [];
      this.opts.buttons.forEach(item => {
        const button = createButton(item);

        if (button instanceof _ButtonGroup.default) {
          groups.push(button);
        }

        results.push(button);
      });
      this._buttons = results;
    }

    this.buttons.forEach(button => {
      this._appendButton(button);
    });

    const updateVisibility = () => {
      if (this.buttons.length === 0) {
        this.hide();
      } else {
        this.show();
      }
    };

    this.on('button:add button:remove', () => {
      updateVisibility();
    });
    updateVisibility();
  }

  _indexForId(id) {
    let result = -1;
    this.buttons.forEach((button, index) => {
      if (button.id === id && result === -1) {
        result = index;
      }
    });
    return result;
  }

  _appendButton(button, events = true, index = -1) {
    if (index >= 0) {
      button.addTo(this.ui.buttons, false, index);
    } else {
      button.addTo(this.ui.buttons);
    }

    if (events) {
      if (button instanceof _ButtonGroup.default) {
        const group = button;
        group.buttons.forEach(btn => {
          this._addButtonEvents(btn);
        });
      } else {
        this._addButtonEvents(button);
      }
    }
  }

  _addButtonEvents(button) {
    button.on('select', e => {
      this.trigger('select', Object.assign({}, button.info));
    }).on('deselect', e => {
      this.trigger('deselect', Object.assign({}, button.info));
    }).on('value:change', e => {
      this.trigger('change', Object.assign(Object.assign({}, button.info), e.data));
    }).on('control:change', e => {
      this.trigger('control:change', Object.assign(Object.assign({}, button.info), e.data));
    });

    if (button instanceof _ButtonGroup.default) {
      button.on('change:size', e => {
        this.trigger("change:size"
        /* SIZE_CHANGE */
        );
      });
    } else if (button instanceof _SegmentedButton.default) {
      button.on('expanded', () => {
        this.trigger("change:size"
        /* SIZE_CHANGE */
        );
      }).on('collapsed', () => {
        this.trigger("change:size"
        /* SIZE_CHANGE */
        );
      });
    }
  }

}

var _default = ButtonPanelView;
exports.default = _default;
module.exports = exports.default;