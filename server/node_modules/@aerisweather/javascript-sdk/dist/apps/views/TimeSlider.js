"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _startOfDay = _interopRequireDefault(require("date-fns/startOfDay"));

var _addDays = _interopRequireDefault(require("date-fns/addDays"));

var _isEqual = _interopRequireDefault(require("date-fns/isEqual"));

var _View = _interopRequireDefault(require("../ui/View"));

var _Slider = _interopRequireDefault(require("../ui/Slider"));

var _utils = require("../../utils");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

;

class TimeSlider extends _View.default {
  constructor(animation, opts) {
    opts = (0, _utils.extend)({
      className: (0, _utils.get)(opts, 'className') ? `ui-timeline ${opts.className}` : 'ui-timeline',
      ui: {
        periods: '.awxjs__ui-timeline__periods'
      },
      formatters: {
        time: 'h:mm',
        date: 'M/d',
        day: 'EEE',
        dateFull: 'EEE MMM d'
      }
    }, opts);
    super(opts);
    this._slider = new _Slider.default(opts.slider);
    this._animation = animation;
  }

  get slider() {
    return this._slider;
  }

  setPosition(value, fireEvents = true) {
    this._slider.setPosition(value, fireEvents);
  }

  setProgress(value, fireEvents = true) {
    this._slider.setProgress(value, fireEvents);
  }
  /**
   * Updates the string format for the time and day strings displayed in the component.
   * Values must be a string format supported by the date-fns library: https://date-fns.org/docs/format
   *
   * @param {{
   * 			time?: string;
   * 			date?: string;
   * 			day?: string;
   * 			dateFull?: string;
   * 		}} value
   * @memberof TimeSlider
   */


  setFormatters(value) {
    this.opts.formatters = (0, _utils.extend)({}, this.opts.formatters, value);

    this._layout();
  }

  _render() {
    return `
			<div class="awxjs__ui-timeline">
				<div class="awxjs__ui-timeline__periods"></div>
			</div>
		`;
  }

  _layout() {
    const from = this._animation.startDate();

    const to = this._animation.endDate();

    this._layoutPeriods(from, to);

    this._setupSliderTicks(from, to);
  }

  _onAddedToDOM() {
    this._slider.addTo(this.$el);

    if (this._animation) {
      this._handleDateRangeChange(this._animation.startDate(), this._animation.endDate());

      this._updateForTime(this._animation.currentTime);
    }
  }

  _setupEvents() {
    const anim = this._animation;
    const slider = this._slider;

    if (anim) {
      anim.on('start:change end:change', e => {
        const {
          from,
          to
        } = e.data;

        if (from && to) {
          this._handleDateRangeChange(from, to); // this._updateForTime(anim.currentTime);

        }
      }).on('advance', e => {
        this._updateForTime(anim.currentTime);
      });
    }

    if (slider) {
      if (!this._sliderChangeHandler) {
        this._sliderChangeHandler = (0, _utils.debounce)(e => {
          const delta = anim.endDate().getTime() - anim.startDate().getTime();
          const time = Math.round(anim.startDate().getTime() + delta * e.data.progress);
          anim.stop();
          anim.goToTime(time);
        }, 250);
      } // update animation position when slider drag occurs


      slider.on('change', e => {
        anim.pause();

        this._sliderChangeHandler(e);
      });
    }
  }

  _updateForTime(time) {
    const anim = this._animation;

    if (anim) {
      // update slider position during animation playback
      const delta = anim.endDate().getTime() - anim.startDate().getTime();
      const progress = anim.currentOffset / delta;
      this.setProgress(progress, false);
    }
  }

  _handleDateRangeChange(from, to) {
    this._layout();

    this._slider.setDateRange(from, to);
  }

  _layoutPeriods(from, to) {
    const range = to.getTime() - from.getTime();
    const $periods = this.ui.periods;
    let maxWidth = $periods.width();
    let x = 0;

    if (this._slider) {
      const size = this._slider.indicatorSize();

      maxWidth -= size.width;
      x = size.width / 2;
    }

    const formatters = this.opts.formatters;
    $periods.empty();

    if (from.getDate() !== to.getDate() || from.getMonth() !== to.getMonth()) {
      let tw = 0;
      let time = (0, _startOfDay.default)(from).getTime(); // get start date ignoring time

      let totalWidth = 0;
      let runningWidth = 0;
      let runningLabel;
      let isDST;
      let index = 0;
      const allowedWidth = 40;
      const fromDate = new Date(from.getFullYear(), from.getMonth(), from.getDate());
      const toDate = new Date(to.getFullYear(), to.getMonth(), to.getDate());
      const dayDelta = Math.round((toDate.getTime() - fromDate.getTime()) / (86400 * 1000));

      while (time < to.getTime()) {
        let date = new Date(time); // check if there's a Daylight Saving Time switch between periods and adjust
        // the current period's time accordingly so we don't get weird period issues

        const tz = date.toString().replace(/^[^\(]+/, '').replace(/[^a-zA-Z]/g, '');

        if (!(0, _utils.isEmpty)(tz)) {
          const dst = /^(\wDT|\w+DaylightTime)/.test(tz);

          if ((0, _utils.isset)(isDST) && dst !== isDST) {
            const timeShift = 3600 * 1000 * (isDST && !dst ? 1 : -1);
            isDST = dst;
            time += timeShift;
            date = new Date(time);
          }

          isDST = dst;
        } // calculate the total width of this period as a percentage of the total time range


        let w = 1;

        if ((0, _isEqual.default)((0, _startOfDay.default)(date), (0, _startOfDay.default)(from))) {
          const d = (0, _startOfDay.default)((0, _addDays.default)(date, 1));
          w = (d.getTime() - from.getTime()) / range;
        } else if ((0, _isEqual.default)((0, _startOfDay.default)(date), (0, _startOfDay.default)(to))) {
          w = 1 - tw;
        } else {
          const d1 = (0, _startOfDay.default)(date);
          const d2 = (0, _addDays.default)(date, 1);
          w = (d2.getTime() - d1.getTime()) / range;
        }

        w = Math.min(1, Math.max(w, 0));
        const dateOrDay = dayDelta >= 10 ? formatters.date : formatters.day;
        const dateFormat = w * maxWidth < 100 ? dateOrDay : formatters.dateFull;
        const itemLabel = (0, _utils.formatDate)(date, dateFormat);
        let itemWidth = Math.round(w * 100 * 100) / 100; // make sure itemWidth percentage never forces totalWidth over 100%
        // itemWidth = Math.min(itemWidth, (100 - totalWidth));

        itemWidth = Math.min(w * maxWidth, maxWidth);
        runningWidth += itemWidth;

        if (index === 0 || index === dayDelta || index > 0 && runningWidth >= allowedWidth) {
          $periods.append(`<div class="awxjs__ui-timeline__periods-item" style="left:${x}px;width:${runningWidth}px;"><span>${runningWidth >= allowedWidth - 10 ? runningLabel || itemLabel : '&nbsp;'}</span></div>`);
          x += runningWidth;
          runningWidth = 0;
          runningLabel = undefined;
        } else if (!(0, _utils.isset)(runningLabel)) {
          runningLabel = itemLabel;
        }

        time += 86400 * 1000;
        tw += w; // x += itemWidth;

        totalWidth += itemWidth;
        index += 1;
      }
    } else {
      const itemLabel = (0, _utils.formatDate)(to, formatters.dateFull);
      $periods.append(`<div class="awxjs__ui-timeline__periods-item" style="left:${x}px;width:${maxWidth}px;"><span>${itemLabel}</span></div>`);
    } // if (this._slider) {
    // 	this._slider.updateRanges(from, to);
    // }

  }

  _setupSliderTicks(from, to) {
    const range = to.getTime() - from.getTime();
    const intervals = {
      second: 1000,
      minute: 60000,
      hour: 3600000,
      day: 86400000
    };
    intervals.minute5 = intervals.minute * 5;
    intervals.minute10 = intervals.minute * 10;
    intervals.minute15 = intervals.minute * 15;
    intervals.minute30 = intervals.minute * 30;
    intervals.hour2 = intervals.hour * 2;
    intervals.hour3 = intervals.hour * 3;
    intervals.hour6 = intervals.hour * 6;
    intervals.hour12 = intervals.hour * 12;
    intervals.day2 = intervals.day * 2;
    intervals.day3 = intervals.day * 3;
    intervals.day7 = intervals.day * 7;
    intervals.month = intervals.day * 30;
    intervals.year = intervals.day * 365;
    intervals.decade = intervals.year * 10;
    let maxWidth = this.ui.periods.width();

    if (this._slider) {
      const size = this._slider.indicatorSize();

      maxWidth -= size.width;
    }

    const timeUnitForRange = timeRange => {
      let result = 0;
      const units = Object.keys(intervals).map(key => intervals[key]);
      units.sort((a, b) => a - b).forEach(interval => {
        const total = timeRange / interval;
        const spacing = maxWidth / total;

        if (spacing >= 40 && result === 0) {
          result = interval;
        }
      });
      return result;
    };

    if (this._slider) {
      const fromTime = from.getTime();
      const toTime = to.getTime();
      const timeDelta = toTime - fromTime; // let tickInterval = 15 * 60 * 1000;

      let tickInterval = timeUnitForRange(timeDelta); // console.log('using interval', tickInterval, 'from', new Date(fromTime));
      // let tickSpacing = maxWidth / (timeDelta / tickInterval);
      // // determine if the configured tick interval will allow proper spacing
      // // if not, then increase the interval until we find a good fit
      // if (tickSpacing < 50) {
      // 	const factor = Math.ceil(50 / tickSpacing);
      // 	tickInterval *= factor;
      // 	tickSpacing = maxWidth / (timeDelta / tickInterval);
      // }
      // get the tick start time by starting at the beginning of the day in the range

      const startTime = new Date(from.getFullYear(), from.getMonth(), from.getDate()).getTime(); // let tickValue = Math.floor(fromTime);

      let tickValue = startTime;
      let isDayInterval = false;

      if (tickValue % tickInterval !== 0) {
        // if tick interval is a day interval, start ticks at the next day
        if (tickInterval % intervals.day === 0) {
          tickValue += intervals.day;
          isDayInterval = true;
        } else {// tickValue += (tickInterval - (tickValue % tickInterval));
        }
      } // force day tick interval if calculated interval is based on days


      if (isDayInterval) {
        tickInterval = intervals.day;
      }

      const ticks = {};

      while (tickValue <= toTime) {
        const delta = (tickValue - fromTime) / range;

        if (tickValue >= fromTime) {
          ticks[delta] = isDayInterval ? '' : (0, _utils.formatDate)(new Date(tickValue), this.opts.formatters.time || 'h:mm');
        }

        tickValue += tickInterval;
      }

      this._slider.setTicks(ticks);
    }
  }

}

var _default = TimeSlider;
exports.default = _default;
module.exports = exports.default;