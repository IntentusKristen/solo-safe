"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _EventDispatcher = _interopRequireDefault(require("../event/EventDispatcher"));

var _InteractiveMap = require("../maps/interactive/InteractiveMap");

var _utils = require("../utils");

var _sources = require("../maps/interactive/sources");

var _utils2 = require("../maps/interactive/utils");

var _utils3 = require("../maps/utils");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var LayerAction;

(function (LayerAction) {
  LayerAction["Select"] = "select";
  LayerAction["Deselect"] = "deselect";
  LayerAction["Change"] = "change";
})(LayerAction || (LayerAction = {}));

const getRequestParams = value => {
  const params = {};

  if ((0, _utils.isPlainObject)(value)) {
    Object.keys(value).forEach(key => {
      const v = value[key];
      params[key] = (0, _utils.isPlainObject)(v) ? v === null || v === void 0 ? void 0 : v.value : v;
    });
  } else if ((0, _utils.isArray)(value) && value.length > 0) {
    params.filter = value.join(';');
  } else if ((0, _utils.isString)(value)) {
    params.filter = value;
  } // if (value.filters) {
  // 	const filters = value.filters;
  // 	if (isPlainObject(filters)) {
  // 		params = { ...params, ...filters };
  // 	} else {
  // 		params.filter = filters;
  // 	}
  // }


  if (params.filter === 'all') {
    params.filter = '';
  }

  return params;
};

class DataSourceManager extends _EventDispatcher.default {
  constructor(map, panel) {
    super();
    this.storedSources = {};
    this.sourceState = {};
    this.respondToSourceEvents = true;
    this.map = map;
    this.linkPanel(panel);
    this.setupEvents();
  }

  get sources() {
    return this.storedSources;
  }

  linkPanel(panel) {
    if (this.panel === panel) return;

    if (this.panel) {
      this.panel.off('select', this.handleSelect).off('deselect', this.handleDeselect).off('change', this.handleOptionChange);
    }

    this.panel = panel;
    this.panel.on('select', this.handleSelect.bind(this)).on('deselect', this.handleDeselect.bind(this)).on('change', this.handleOptionChange.bind(this)).on('control:change', e => {
      const {
        key,
        valueSegments,
        control = {}
      } = e.data || {};

      if (control.id === 'opacity') {
        let source = this.findSource(key); // if `value` has a `segments` property, then it's a segmented button and we need to get the proper
        // data source for the selected segment instead of the button's id value

        if (valueSegments) {
          valueSegments.forEach(segment => {
            const segmentSource = this.findSource(segment.key, segment.value);

            if (segmentSource) {
              source = segmentSource;
            }
          });
        }

        if (source && (source instanceof _sources.TileSource || source instanceof _sources.VectorSource)) {
          const opacity = control.value / 100;
          source.setOpacity(opacity);
          this.setSourceState(key, {
            style: {
              opacity
            }
          });
        }
      }

      this.trigger("change:control"
      /* CONTROL_CHANGE */
      , e.data);
    });
  }

  getSource(id) {
    return this.sources[id];
  }

  findSource(id, value = undefined) {
    let source = this.getSource(id);

    if (!source) {
      source = this.map.getSourceForId(id);
    }

    if (!source) {
      source = this.map.getSourceForLayer(id);
    }

    if (!source && (0, _utils.isString)(value)) {
      source = this.findSource(value);
    }

    if (!source && /\:\:/.test(id) === true) {
      const code = (0, _utils2.getSourceId)(id || value);
      source = this.findSource(code);
    }

    return source;
  }

  addSource(id, source) {
    this.sources[id] = source;
  }

  setSourceState(id, state) {
    this.sourceState[id] = Object.assign(Object.assign({}, this.sourceState[id]), state);
  }

  handleSourceEvent(event, id) {
    if (!this.respondToSourceEvents) return;

    switch (event) {
      case 'add':
        this.panel.select(id, true);
        break;

      case 'remove':
        this.panel.deselect(id, true);
        break;

      default:
    }
  }

  handleSelect(e) {
    const {
      changed
    } = this.handleAction(LayerAction.Select, e.data);

    if (changed) {
      this.trigger("select"
      /* SELECT */
      , Object.assign({}, e.data));
    }
  }

  handleDeselect(e) {
    const {
      changed
    } = this.handleAction(LayerAction.Deselect, e.data);

    if (changed) {
      this.trigger("deselect"
      /* DESELECT */
      , Object.assign({}, e.data));
    }
  }

  handleOptionChange(e) {
    const {
      id,
      value,
      reload,
      filter = false,
      currentSegments
    } = e.data || {};
    if (!value) return; // if source hasn't been added to the map yet, trigger the `select` event instead since it needs to be added

    if (this.map.hasSource(id) === false && value.filters) {
      this.panel.trigger('select', e.data);
      return;
    }

    const changed = this.handleAction(LayerAction.Change, Object.assign({}, e.data));

    if (changed) {
      let params = getRequestParams(value);
      params.bounds = this.map.getBounds();

      if (currentSegments) {
        currentSegments.forEach(segment => {
          var _a, _b, _c;

          const overrides = (_c = (_b = (_a = segment.options) === null || _a === void 0 ? void 0 : _a.data) === null || _b === void 0 ? void 0 : _b.request) === null || _c === void 0 ? void 0 : _c.parameters;

          if (overrides) {
            params = (0, _utils.extend)({}, params, overrides);
          }
        });
      }

      this.trigger("change"
      /* CHANGE */
      , Object.assign(Object.assign({}, e.data), {
        params
      })); // if triggered change is a filter, then reload datasource with selected filters if needed

      if (filter) {
        const source = this.findSource(id, value);

        if (source) {
          params.filter = params.filter || value; // params.filter = isArray(value) ? value.join(';') : value;

          if (!(0, _utils.isset)(reload) || reload === true) {
            source.reload(params);
          } else {
            source.render();
          }
        }
      }
    }
  } // private handleFilterChange(payload: any = {}) {
  // 	const { value, source, reload, filters } = payload || { reload: true };
  // 	const params = getRequestParams(value);
  // 	params.bounds = this.map.getBounds();
  // 	if (isPlainObject(filters)) {
  // 		payload.filters = Object.keys(filters).reduce((result: any, key) => {
  // 			result[key] = filters[key].filters;
  // 			return result;
  // 		}, {});
  // 	}
  // 	// pass in params object to event data payload so event handlers can
  // 	// override request parameters as needed
  // 	this.trigger(DataSourceManagerEvent.OPTION_CHANGE, {
  // 		...payload,
  // 		params
  // 	});
  // 	if (source) {
  // 		if (!isset(reload) || reload === true) {
  // 			source.reload(params);
  // 		} else {
  // 			source.render();
  // 		}
  // 	}
  // };


  handleAction(action, info) {
    const {
      id,
      key,
      value,
      previous,
      options,
      valueSegments,
      previousSegments,
      filter = false
    } = info;
    const saveKeys = ['id', 'key', 'value', 'options'];

    if (!value) {
      return {
        changed: false,
        added: [],
        removed: []
      };
    }

    if (this.map.isReady()) {
      let added = [];
      let removed = [];

      if (filter || value.filters) {
        if (action === LayerAction.Deselect) {
          removed.push((0, _utils.pick)(info, saveKeys));
        } else {
          added.push((0, _utils.pick)(info, saveKeys));
        } // const source = this.findSource(id, value);
        // this.handleFilterChange({
        // 	id,
        // 	value,
        // 	filters: value.filters,
        // 	options: value.options,
        // 	segments: value.segments,
        // 	source,
        // 	reload: isset(reload) ? reload : true
        // });


        if (action === LayerAction.Change) {
          return {
            changed: true,
            added,
            removed
          };
        } // } else if (value.segments) {
        // 	if (action === LayerAction.Deselect) {
        // 		removed = removed.concat(value.segments.filter((item: any) => isset(item)));
        // 	} else {
        // 		added = added.concat(value.segments.filter((item: any) => isset(item)));
        // 		if (previous && previous.segments) {
        // 			removed = removed.concat(previous.segments.filter((item: any) => isset(item)));
        // 		}
        // 	}

      } else if (action === LayerAction.Select) {
        if (valueSegments) {
          added = added.concat(valueSegments.map(item => (0, _utils.pick)(item, saveKeys)));
        } else {
          added.push((0, _utils.pick)(info, saveKeys));
        }
      } else if (action === LayerAction.Deselect) {
        if (valueSegments) {
          removed = removed.concat(valueSegments.map(item => (0, _utils.pick)(item, saveKeys)));
        } else {
          removed.push((0, _utils.pick)(info, saveKeys));
        }
      }

      if (action === LayerAction.Change) {
        if (valueSegments || previousSegments) {
          if (valueSegments) {
            added = added.concat(valueSegments.map(item => (0, _utils.pick)(item, saveKeys)));
          }

          if (previousSegments) {
            removed = removed.concat(previousSegments.map(item => (0, _utils.pick)(item, saveKeys)));
          }
        } else {
          removed.push(Object.assign(Object.assign({}, (0, _utils.pick)(info, saveKeys)), {
            value: previous
          }));
          added.push((0, _utils.pick)(info, saveKeys));
        }
      }

      if (action === LayerAction.Select) {
        removed = [];
      } else if (action === LayerAction.Deselect) {
        added = [];
      }

      const addedValues = added.map(item => item.key);
      const removedFiltered = removed.reduce((result, item) => {
        if (addedValues.indexOf(item.key) === -1) {
          result.push(item);
        }

        return result;
      }, []); // console.log('DATASOURCE', action, 'added', added, 'removed', removed, 'filtered', removedFiltered);

      if (added.length > 0 || removedFiltered.length > 0) {
        const sourcesToAdd = added.map(item => Object.assign(Object.assign({}, item), {
          parentId: id
        }));
        const sourcesToRemove = removedFiltered.map(item => Object.assign(Object.assign({}, item), {
          parentId: id
        }));
        this.updateSources(sourcesToAdd, sourcesToRemove);
        return {
          changed: true,
          added,
          removed: removedFiltered
        };
      }
    }

    return {
      changed: false,
      added: [],
      removed: []
    };
  }

  updateSources(sourcesToAdd = [], sourcesToRemove = []) {
    const added = [];
    const removed = []; // we need to disable responding to source events in `handleSourceEvent` so that add/remove events don't get captured by
    // the button panel which would then cause issues with the add/remove source changes we're performing here

    this.respondToSourceEvents = false; // console.log(sourcesToAdd, sourcesToRemove);

    sourcesToRemove.forEach(item => {
      const {
        id,
        key,
        value,
        options
      } = item;
      const source = this.findSource(id, value);

      if (source) {
        this.map.removeSource(source);
        removed.push(source);
      }
    });
    sourcesToAdd.forEach(item => {
      const {
        id,
        key,
        parentId,
        value,
        options
      } = item;
      const sourceOptions = (0, _utils.extend)({}, options, this.sourceState[id], this.sourceState[parentId]);
      const valueStr = (0, _utils.isArray)(value) ? value.join(',') : value;
      let source = this.findSource(id, valueStr);

      if (!source) {
        source = this.findSource(key, valueStr);
      } // if item is a module source, then it may not have loaded yet which means its source won't be available yet
      // so we trigger an event for it to be added when the module has loaded in InteractiveMapApp


      if (!source && /^[^\:]+::/.test(key)) {
        this.trigger('error:module:add', item);
        return;
      } // skip MapsGL layers


      if (!(0, _utils3.isMapsGLLayer)(id) && !(0, _utils3.isMapsGLLayer)(valueStr) && (options === null || options === void 0 ? void 0 : options.mapsgl) !== true) {
        if (source) {
          this.map.addSource(source, sourceOptions);
        } else if ((0, _utils.isString)(valueStr) && (this.map.layerInfo.exists(valueStr) || sourceOptions.validate === false)) {
          this.map.addLayer(valueStr, Object.assign(Object.assign({}, sourceOptions), {
            id
          }));
          source = this.map.getSourceForLayer(id || valueStr);
        } else if (this.map.layerInfo.exists(id)) {
          // try adding source as an Aeris Maps layer instead
          this.map.addLayer(id, Object.assign(Object.assign({}, sourceOptions), {
            id
          }));
          source = this.map.getSourceForLayer(id);
        }

        if (source) {
          added.push(source);
        } else if (!(0, _InteractiveMap.isModule)(value)) {
          console.warn(`[Aeris] Cannot add map data source {${id}}, source not registered and/or not a valid Aeris Maps layer.`);
        }
      }
    }); // re-enable source events now that we've updated our data sources

    this.respondToSourceEvents = true;
    this.trigger("source:change"
    /* SOURCE_CHANGE */
    , {
      added,
      removed
    });
  }

  setupEvents() {
    this.on("source:change"
    /* SOURCE_CHANGE */
    , e => {// console.log('SOURCE CHANGE', e.data);
    });
  }

}

var _default = DataSourceManager;
exports.default = _default;
module.exports = exports.default;