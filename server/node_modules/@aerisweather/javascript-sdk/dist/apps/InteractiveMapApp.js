"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _EventDispatcher = _interopRequireDefault(require("../event/EventDispatcher"));

var _InteractiveMap = _interopRequireDefault(require("../maps/interactive/InteractiveMap"));

var _ButtonPanel = _interopRequireDefault(require("./views/ButtonPanel"));

var _InfoPanel = _interopRequireDefault(require("./views/InfoPanel"));

var _TimelinePanel = _interopRequireDefault(require("./views/TimelinePanel"));

var _LegendPanel = _interopRequireDefault(require("./views/LegendPanel"));

var _PlaceSearchPanel = _interopRequireDefault(require("./views/PlaceSearchPanel"));

var _ModuleManager = _interopRequireDefault(require("./ModuleManager"));

var _CoordinateBounds = require("../geo/CoordinateBounds");

var _layout = require("../utils/layout");

var _DOM = _interopRequireDefault(require("../display/DOM"));

var _DataSourceManager = _interopRequireDefault(require("./DataSourceManager"));

var _utils = require("./utils");

var _utils2 = require("../utils");

var _defaults = require("./defaults");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * An `InteractiveMapApp` object provides an full-featured weather map application that manages an
 * interactive map and enables runtime interaction of map content using a series of panel
 * view components.
 *
 * @export
 * @class InteractiveMapApp
 * @extends {EventDispatcher}
 */
class InteractiveMapApp extends _EventDispatcher.default {
  /**
   * Initializes an interactive map application with the specified DOM target and configuration
   * object.
   *
   * @param {HTMLElement} target
   * @param {InteractiveMapAppOptions} [opts]
   * @memberof InteractiveMapApp
   */
  constructor(target, opts) {
    super();
    this._ready = false;
    this._modulesToAddOnLoad = [];
    this._layoutCache = {};
    this._layout = (0, _utils2.debounce)((sizeOnly = false) => {
      if (!sizeOnly) {
        Object.keys(this._panels).forEach(key => {
          const panel = this._panels[key];

          if (panel) {
            const pos = (0, _utils2.get)(this._opts, `panels.${key}.position`);

            if (pos && (0, _utils2.isPlainObject)(pos)) {
              if (key !== 'info') {
                panel.layout();
              }

              if (pos.pin) {
                panel.pinTo(pos.pin, pos.translate);
              } else if ((0, _utils2.isset)(pos.x) && (0, _utils2.isset)(pos.y)) {
                panel.moveTo(pos);
              }
            }
          }
        });
      }

      const layersPanel = this.panels.layers;
      const timelinePanel = this.panels.timeline;
      const legendsPanel = this.panels.legends; // calculate initial allowable area relative to parent

      const parent = this.$el.bounds(true);
      const allowed = {
        top: 0,
        left: 0,
        right: parent.right,
        bottom: parent.height,
        width: parent.width,
        height: parent.height
      };
      let region = Object.assign({}, allowed);

      if (timelinePanel) {
        const panel = timelinePanel;
        const size = panel.size();
        const inset = 10;
        const {
          pin
        } = (0, _utils2.get)(this._opts, `panels.timeline.position`) || {};

        if ((0, _layout.isCenterPinned)(pin)) {
          region = (0, _layout.insetBounds)(allowed, inset);
          const css = {};

          if (size.width >= region.width) {
            // css.width = `${region.width}px`;
            css.left = `${inset}px`; // panel.setSize(region.width, 0);
          } else {
            css.left = `${Math.floor((parent.width - size.width) / 2)}px`;
          } // panel.$el.css(css);


          this._layoutCache.timeline = css;
        }
      } // set max-height on layers panel


      if (layersPanel) {
        const panel = layersPanel;
        const contentSize = panel.contentSize();
        const bounds = panel.bounds(true, this.$el); // const contentHeight = (size.height < bounds.height) ? size.height : Math.max(size.height, bounds.height);

        let margin = bounds.top;
        region = Object.assign({}, allowed);
        const {
          pin: layersAnchor,
          translate
        } = (0, _utils2.get)(this._opts, 'panels.layers.position') || {};

        if ((0, _layout.isMiddlePinned)(layersAnchor)) {
          region.top = Math.max(0, Math.round((parent.height - bounds.height) / 2));
          region.bottom = Math.min(parent.height, region.top + region.height);
          margin = translate.y; // } else if (isBottomPinned(layersAnchor)) {

          margin = Math.abs(translate.y);
        }

        region = (0, _layout.boundsAdjustedForAnchor)(region, {
          width: bounds.width,
          height: bounds.height
        }, layersAnchor); // reference bounds for intersection checks with other panels

        const marginBounds = (0, _layout.insetBounds)(region, 10); // ensure layers panel doesn't overlap legend or timeline panels

        if (legendsPanel) {
          const {
            pin
          } = (0, _utils2.get)(this._opts, 'panels.legends.position') || {};
          const b = legendsPanel.bounds(true, this.$el);

          if ((0, _layout.intersects)(marginBounds, b, false)) {
            if ((0, _layout.isBottomPinned)(pin)) {
              region.bottom = b.top;
            } else if ((0, _layout.isTopPinned)(pin)) {
              region.top = b.bottom;
            }
          }
        }

        if (timelinePanel) {
          const {
            pin
          } = (0, _utils2.get)(this._opts, 'panels.timeline.position') || {};
          const b = timelinePanel.bounds(true, this.$el);

          if ((0, _layout.intersects)(marginBounds, b, false)) {
            if ((0, _layout.isBottomPinned)(pin)) {
              region.bottom = b.top;
            } else if ((0, _layout.isTopPinned)(pin)) {
              region.top = b.bottom;
            }
          }
        }

        region = (0, _layout.insetBounds)(region, margin);
        let maxh = Math.max(region.bottom - region.top, 0);

        if (maxh === 0) {
          maxh = allowed.bottom - allowed.top;
        }

        maxh = Math.min(maxh, region.height) - layersPanel.toolbar.outerHeight(); // console.log(bounds, allowed, `maxh=${maxh}`, 'contentSize', contentSize, margin, region);
        // const height = contentHeight > maxh ? `${Math.min(maxh, contentHeight)}px` : `${contentHeight}px`;

        const scrollbar = (0, _utils.scrollBarWidth)();
        const css = {
          'top': `${region.top}px`,
          'height': `${contentSize.height}px`,
          'max-height': `${maxh}px`,
          'width': `${contentSize.width + scrollbar}px`
        }; // panel.$el.css(css);

        panel.setMaxContentSize({
          height: maxh,
          width: contentSize.width + scrollbar
        });
        panel.content.css({
          'padding-right': `${scrollbar}px`
        });
        this._layoutCache.layers = css;
      }
    }, 50);

    if (!target) {
      throw new Error('[Aeris] Invalid DOM target specified for InteractiveMapApp');
    }

    const vp = (0, _layout.viewportSizeClass)();
    opts = (0, _utils2.extend)((0, _defaults.getMapAppDefaults)(vp), {
      map: {
        account: opts.account,
        servers: opts.servers
      },
      panels: {
        search: {
          account: opts.account
        }
      }
    }, opts);
    this._opts = opts;
    this._account = opts.account;

    if (!this.account) {
      throw new Error('An InteractiveMapApp must be configured with a valid `account` value.');
    }

    const classNames = `awxjs__mode-${this._opts.mode || 'light'}`;
    (0, _DOM.default)(target).html(`
			<div class="awxjs__app__component awxjs__app__fullscreen ${classNames}">
				<div class="awxjs__app__map"></div>
			</div>
		`);
    this._target = (0, _DOM.default)('.awxjs__app__component', (0, _DOM.default)(target)); // panel and source cache

    this._panels = {
      layers: null,
      info: null,
      timeline: null,
      legends: null,
      search: null
    };
    this._modules = new _ModuleManager.default(this);

    this._modules.on('module:load', e => {
      // check if the module is included in the set of initial layers and add it if so
      const initLayers = this.initialLayers();
      const removed = [];
      initLayers.forEach(layerId => {
        this._modulesToAddOnLoad.forEach(item => {
          if (item.key === layerId) {
            this._sourceManager.updateSources([item], []);

            removed.push(item.key);
          }
        });
      });
      this._modulesToAddOnLoad = this._modulesToAddOnLoad.filter(item => removed.includes(item.key) === false);
    }); // interface panels


    const {
      layers: layersPanel,
      info: infoPanel,
      timeline: timelinePanel,
      search: searchPanel,
      legends: legendsPanel
    } = opts.panels;
    const mapOpts = (0, _utils2.cloneDeep)(opts.map); // update opts.map.layers values by using the layer value associated with the matching
    // layer id from the layers panel buttons

    if (mapOpts && layersPanel) {
      let initialLayers = (0, _utils2.get)(opts, 'map.layers');

      if (initialLayers) {
        if ((0, _utils2.isString)(initialLayers)) {
          initialLayers = initialLayers.replace(/\s/g, '').split(',');
        }

        const buttons = layersPanel.buttons || [];
        const result = buttons.reduce((ar, item) => {
          if ((0, _utils2.isset)(item.buttons) === false) {
            const value = item.value || item.id; // if button config has segments and is not a filter, iterate through the
            // segments to find a layer value that exists in the initial layers array

            const segments = item.segments;

            if (segments && (0, _utils2.isArray)(segments) && !item.filter) {
              segments.forEach(o => {
                const layer = o.value.replace(/\:.+$/, '');
                (0, _utils2.replace)(ar, layer, o.value);
              });
            } else {
              (0, _utils2.replace)(ar, item.value, value);
              (0, _utils2.replace)(ar, item.id, value);
            }
          }

          return ar;
        }, (0, _utils2.cloneDeep)(initialLayers));
        (0, _utils2.set)(opts, 'map.layers', result);
        (0, _utils2.set)(mapOpts, 'layers', null);
      }
    }

    this._map = new _InteractiveMap.default((0, _DOM.default)('.awxjs__app__map', this._target), mapOpts); // setup interface panels

    if (layersPanel && layersPanel.enabled !== false) {
      this._setupLayersPanel(layersPanel);
    }

    if (infoPanel && infoPanel.enabled !== false) {
      this._setupInfoPanel(infoPanel);
    }

    if (timelinePanel && timelinePanel.enabled !== false) {
      this._setupTimeline(timelinePanel);
    }

    if (searchPanel && searchPanel.enabled !== false) {
      this._setupSearchPanel(searchPanel);
    }

    if (legendsPanel && legendsPanel.enabled !== false) {
      this._setupLegendsPanel(legendsPanel);
    }

    const manager = new _DataSourceManager.default(this.map, this.panels.layers);
    manager.on("select"
    /* SELECT */
    , e => {
      this.trigger("layer:select"
      /* LAYER_SELECT */
      , Object.assign(Object.assign({}, e.data), {
        source: this.getSource(e.data.key)
      }));
    }).on("deselect"
    /* DESELECT */
    , e => {
      this.trigger("layer:deselect"
      /* LAYER_DESELECT */
      , Object.assign(Object.assign({}, e.data), {
        source: this.getSource(e.data.key)
      }));
    }).on("change"
    /* CHANGE */
    , e => {
      this.trigger("layer:change"
      /* LAYER_CHANGE */
      , Object.assign(Object.assign({}, e.data), {
        source: this.getSource(e.data.key)
      })); // }).on(DataSourceManagerEvent.OPTION_CHANGE, (e: any) => {
      // 	this.trigger(InteractiveMapAppEvent.LAYER_OPTION_CHANGE, e.data);
    }).on("change:control"
    /* CONTROL_CHANGE */
    , e => {
      this.trigger("layer:change:control"
      /* LAYER_CONTROL_CHANGE */
      , Object.assign(Object.assign({}, e.data), {
        source: this.getSource(e.data.key)
      }));
    }).on("error:module:add"
    /* ERROR_MODULE_ADD */
    , e => {
      this._modulesToAddOnLoad.push(e.data);
    });
    this._sourceManager = manager;

    this._map.on('change:units', e => {
      this.trigger("change:units"
      /* CHANGE_UNITS */
      , e.data);
    });

    this._map.on('ready', () => {
      this._ready = true;
      this.trigger("ready"
      /* READY */
      );
    });

    (0, _DOM.default)(window).on('resize', () => {
      this._layout();
    });

    this._layout();

    setTimeout(() => this._layout(), 200);
  }
  /**
   * The Aeris account to use when requesting data for the map.
   *
   * @readonly
   * @type {Account}
   * @memberof InteractiveMapApp
   */


  get account() {
    return this._account;
  }
  /**
   * Primary DOM element associated with the view.
   *
   * @readonly
   * @type {*}
   * @memberof MapView
   */


  get $el() {
    return this._target;
  }

  get options() {
    return Object.assign({}, this._opts);
  }
  /**
   * Returns the underlying interactive map instance.
   *
   * @readonly
   * @type {InteractiveMap}
   * @memberof InteractiveMapApp
   */


  get map() {
    return this._map;
  }
  /**
   * Returns the panel component instances for the application keyed by their type.
   *
   * @readonly
   * @type {{ layers: ButtonPanel, info: InfoPanel }}
   * @memberof InteractiveMapApp
   */


  get panels() {
    return this._panels;
  }
  /**
   * Returns the set of custom data sources for the application.
   *
   * @readonly
   * @type {{ [key: string]: any }}
   * @memberof InteractiveMapApp
   */


  get sources() {
    return this._sourceManager.sources;
  }

  get modules() {
    return this._modules;
  }
  /**
   * Adds a map content source to the application cache that can be toggled on and off using the
   * unique key identifier. Note that this method does not render the source to the interactive
   * map.
   *
   * @param {string} key Identifier for the source
   * @param {string} type Type of map content source to use, `tile`, `vector`, `geojson` or `text`
   * @param {*} config Configuration options for the source
   * @returns {*}
   * @memberof InteractiveMapApp
   */


  addSource(key, type, config) {
    const source = this.map.createSource(key, type, config);

    if (source) {
      source.strategy = this.map.strategy;

      this._sourceManager.addSource(key, source);
    } else {
      console.warn(`[Aeris] Unable to add data source to InteractiveMapApp for key {${key}}, type {${type}} is invalid.
				Data sources must be of type 'tile', 'vector', 'geojson' or 'text'. See
				https://www.aerisweather.com/support/docs/toolkits/aeris-js-sdk/map-modules/data-sources/ for more info.`);
      return null;
    } // determine if source should be selected/active initially


    const initLayers = this.initialLayers();

    if ((0, _utils2.isArray)(initLayers)) {
      if (initLayers.indexOf(key) !== -1) {
        const layersPanel = this.panels.layers;

        if (layersPanel) {
          layersPanel.select([key]);
        } else {
          this.map.addSource(source, {
            id: key
          });
        }
      }
    }

    return source;
  }

  getSource(id) {
    return this._sourceManager.findSource(id);
  }
  /**
   * Shows the application info panel component using the specified view key, title and data.
   *
   * @param {string} view Identifier associated with the view to render
   * @param {string} [title] Title to display in the info panel (optional)
   * @param {*} [data] Data to use when rendering the view in the panel (optional)
   * @returns {InfoPanel}
   * @memberof InteractiveMapApp
   */


  showInfo(view, title, data) {
    const panel = this.panels.info;

    if (panel) {
      panel.showContent(view, title, data);
    }

    return panel;
  }
  /**
   * Shows the application info panel component for the specified geographical coordinate. Data
   * will be requested for the coordinate using the view's request instance
   *
   * @param {Coordinate} coord Coordinate to request data for
   * @param {string} view Identifier associated with the view to render
   * @param {string} [title] Title to display in the info panel (optional)
   * @param {MarkerStyle} [marker] Marker style to use when placing the marker on the map at the
   * coordinate (optional)
   * @returns {InfoPanel}
   * @memberof InteractiveMapApp
   */


  showInfoAtCoord(coord, view, title, marker) {
    const panel = this.panels.info;

    if (!coord) {
      return panel;
    }

    if (!marker) {
      marker = (0, _utils2.get)(this._opts, 'panels.info.marker');
    }

    const {
      lat,
      lon
    } = (0, _CoordinateBounds.normalize)(coord);

    if (panel && (0, _utils2.isset)(lat) && (0, _utils2.isset)(lon)) {
      panel.showContent(view, title).load({
        p: `${lat},${lon}`
      });

      if (this._infoPanelMarker) {
        this.map.strategy.removeMarker(this._infoPanelMarker);
      }

      if (marker) {
        this._infoPanelMarker = this.map.strategy.factory.marker('info', coord, marker);

        if (this._infoPanelMarker) {
          this.map.strategy.addMarker(this._infoPanelMarker);
        }
      }
    }

    return panel;
  }
  /**
   * Dismisses the application info panel if currently visible.
   *
   * @memberof InteractiveMapApp
   */


  closeInfoPanel() {
    const panel = this.panels.info;
    panel.close();
  }
  /**
   * Returns the panel view associated with the specified key, if any.
   *
   * @param {string} key
   * @returns {*}
   * @memberof InteractiveMapApp
   * @see panels
   */


  getPanel(key) {
    const panel = this._panels[key];

    if (panel) {
      return panel;
    }

    return null;
  }
  /**
   * Updates the configuration for the panel view associated with the specified key, if any.
   *
   * The new options provided will be applied to the existing options for the panel, meaning new values will
   * override the existing option values while other existing values will remain.
   *
   * @param {string} key
   * @param {*} config
   * @memberof InteractiveMapApp
   */


  updatePanel(key, config) {
    const existing = this.getPanel(key);

    if (existing) {
      config = Object.assign(Object.assign({}, existing.opts), config);
      existing.remove(true);

      if (key === 'layers') {
        // need to remove all sources since the new layers may not contain those that are
        // currently active on the map
        this.map.removeAllSources();
      }
    } // update panel config on stored opts


    (0, _utils2.set)(this._opts, `panels.${key}`, config); // don't create panel if disabled

    if (config.enabled === false) {
      return;
    }

    switch (key) {
      case 'layers':
        this._setupLayersPanel(config);

        break;

      case 'timeline':
        this._setupTimeline(config);

        break;

      case 'legends':
        this._setupLegendsPanel(config);

        break;

      case 'search':
        this._setupSearchPanel(config);

        break;

      case 'info':
        this._setupInfoPanel(config);

        break;

      default:
    }

    this._layout();
  }
  /**
   * Sets the units to display on the underlying interactive map.
   *
   * @param {boolean} isMetric
   * @memberof InteractiveMapApp
   */


  setMetric(isMetric) {
    this.map.setMetric(isMetric);
  }

  setMode(mode) {
    this._opts.mode = mode;

    this._target.removeClass('awxjs__mode-light awxjs__mode-dark');

    this._target.addClass(`awxjs__mode-${this._opts.mode}`);
  }
  /**
   * Returns whether the application has finished initializing.
   *
   * @returns {boolean}
   * @memberof InteractiveMapApp
   */


  isReady() {
    return this._ready;
  }

  initialLayers() {
    var _a, _b;

    const initLayers = ((_b = (_a = this._opts) === null || _a === void 0 ? void 0 : _a.map) === null || _b === void 0 ? void 0 : _b.layers) || [];
    let layers;

    if ((0, _utils2.isString)(initLayers)) {
      layers = initLayers.replace(/,\s+/, ',').split(',');
    } else {
      layers = initLayers;
    }

    return layers;
  }

  _setupLayersPanel(config) {
    const isInitialSetup = typeof this._panels.layers === 'undefined' || this._panels.layers === null;

    if (this._panels.layers) {
      this._panels.layers.offAll();
    }

    const panel = new _ButtonPanel.default((0, _utils2.extend)({}, config, {
      id: 'layers'
    }));
    panel.addTo(this.$el);
    panel.on('button:add button:remove change:size', () => {
      let vpos = panel.$el.css('top');
      if (vpos.length === 0) vpos = panel.$el.css('bottom');
      vpos = parseInt(vpos.replace(/[^\d]/, ''), 10);
      const sizeOnly = Number.isNaN(vpos) === false;

      this._layout(sizeOnly);
    }).on('show hide', () => {
      this._layout();
    });
    this._panels.layers = panel;

    if (this._sourceManager) {
      this._sourceManager.linkPanel(panel);
    }

    const setButtonLoadingState = (id, loading) => {
      if (id) {
        const btn = panel.buttonForId(id);

        if (btn) {
          btn.setLoading(loading);
        }
      }
    };

    if (isInitialSetup) {
      // listen for source loading events to show the loading state for that layer's button
      this.map.on('source:load:start', e => {
        setButtonLoadingState(e.data.layer, true);
      }).on('source:load:done', e => {
        setButtonLoadingState(e.data.layer, false);
      }).on('source:add', e => {
        this._sourceManager.handleSourceEvent('add', e.data.id);
      }).on('source:remove', e => {
        this._sourceManager.handleSourceEvent('remove', e.data.id);
      }); // select initial buttons based on map.layers value if defined

      let layers = (0, _utils2.get)(this._opts, 'map.layers');

      if (layers) {
        if ((0, _utils2.isString)(layers)) {
          layers = layers.replace(/\s/g, '').split(',');
        }

        this.map.on('ready', () => {
          panel.select(layers);
        });
      }
    }
  }

  _setupInfoPanel(config) {
    var _a, _b, _c;

    const panel = new _InfoPanel.default((0, _utils2.extend)({}, config, {
      id: 'info',
      account: this.account
    }));
    panel.addTo(this.$el);
    this._panels.info = panel;
    panel.on('close', () => {
      if (this._infoPanelMarker) {
        this.map.strategy.removeMarker(this._infoPanelMarker);
        this._infoPanelMarker = null;
      }
    }).on('show hide', () => {
      this._layout();
    });
    this.on('change:units', e => {
      const isMetric = e.data.metric || false;
      panel.setMetric(isMetric);
    }); // add default panel content views

    const localWeatherConfig = ((_c = (_b = (_a = this._opts.panels) === null || _a === void 0 ? void 0 : _a.info) === null || _b === void 0 ? void 0 : _b.views) === null || _c === void 0 ? void 0 : _c.localweather) || {
      views: [{
        renderer: 'place'
      }, {
        renderer: 'units'
      }, {
        title: 'Active Threats',
        renderer: 'threats'
      }, {
        title: 'Active Alerts',
        renderer: 'alerts'
      }, {
        title: 'Impacts',
        renderer: 'hazards'
      }, {
        title: 'Observations',
        renderer: 'obs'
      }, {
        title: 'Outlook',
        renderer: 'outlook'
      }, {
        title: 'Short-Term Forecast',
        renderer: 'forecast'
      }]
    };
    this.panels.info.setContentView('localweather', localWeatherConfig);
  }

  _setupTimeline(config) {
    const initRange = (0, _utils2.get)(config, 'range.value');
    const initTimelineFrom = (0, _utils2.get)(this._opts, 'map.timeline.from');
    const initTimelineTo = (0, _utils2.get)(this._opts, 'map.timeline.to'); // if the slider's `range.value` is defined and the map.timeline from/to are not, then
    // update the map's initial timeline range to the value of `range.value`

    if (initRange && !(0, _utils2.isset)(initTimelineFrom) && !(0, _utils2.isset)(initTimelineTo)) {
      const [from, to] = initRange;

      if ((0, _utils2.isNumber)(from)) {
        this.map.timeline.setStartOffset(from * 3600 * 1000);
      }

      if ((0, _utils2.isNumber)(to)) {
        this.map.timeline.setEndOffset(to * 3600 * 1000);
      }
    } else {
      // update initial slider `range.value` based on underlying map's timeline range
      (0, _utils2.set)(config, 'range.value', [this.map.timeline.startOffset() / 3600 / 1000, this.map.timeline.endOffset() / 3600 / 1000]);
    }

    const panel = new _TimelinePanel.default(this.map.timeline, (0, _utils2.extend)({}, config, {
      id: 'timeline'
    }));
    panel.on('change:range', () => {
      const time = this.map.timeline.currentTime;
      this.map.timeline.goToTime(time);
    }).on('show hide', () => {
      this._layout();
    });
    panel.addTo(this.$el);
    this._panels.timeline = panel;
  }

  _setupSearchPanel(config) {
    const panel = new _PlaceSearchPanel.default((0, _utils2.extend)({}, config, {
      id: 'search'
    }));
    panel.addTo(this.$el);
    this._panels.search = panel;
    panel.on('select', e => {
      const loc = (0, _utils2.get)(e.data, 'result.loc');

      if (loc) {
        const {
          lat,
          long: lon
        } = loc;
        const coord = {
          lat,
          lon
        };
        this.map.setView(coord, 8);
        this.showInfoAtCoord(coord, 'localweather', 'Local Weather');
      }
    });
  }

  _setupLegendsPanel(config) {
    const panel = new _LegendPanel.default((0, _utils2.extend)({}, config, {
      id: 'legends',
      legend: {
        metric: this.map.isMetric
      }
    }));
    panel.addTo(this.$el); // panel.on('show hide', () => {
    // 	this._layout();
    // });

    this._panels.legends = panel;
    this.map.on('layer:add', e => {
      if (!(0, _utils2.isset)(e.data)) return;
      const {
        layer,
        id
      } = e.data;
      const keys = layer || id;

      if (keys) {
        // remove group prefixes and split into multiple keys if multiple layers
        // combined in the key string
        const layers = keys.toLowerCase().replace(/^[^\:]+\:\:/, '').replace(/\:[^,]+/g, '').replace(/__/, ',').split(',');
        layers.forEach(_layer => {
          panel.legend.add(_layer, {
            account: this.account,
            within: {
              bounds: this.map.getBounds()
            }
          });
        });
      }
    }).on('layer:remove source:remove', e => {
      if (!(0, _utils2.isset)(e.data)) return;
      const {
        layer,
        id
      } = e.data;
      const keys = layer || id;

      if (keys) {
        // remove group prefixes and split into multiple keys if multiple layers
        // combined in the key string
        const layers = keys.toLowerCase().replace(/^[^\:]+\:\:/, '').replace(/\:[^,]+/g, '').replace(/__/, ',').split(',');
        layers.forEach(_layer => {
          panel.legend.remove(_layer);
        });
      }
    }).on('change:bounds', e => {
      const opts = {
        account: this.account
      }; // if active layers contains `alerts`, we need to pass the maps current bounds, size and zoom to be used
      // to request a filtered version of the advisories legend just for the map region

      opts.within = {
        bounds: this.map.getBounds()
      };
      panel.legend.update(opts);
    });
    this.on("change:units"
    /* CHANGE_UNITS */
    , e => {
      panel.legend.setMetric(e.data.metric);
    });
  }

}

var _default = InteractiveMapApp;
exports.default = _default;
module.exports = exports.default;