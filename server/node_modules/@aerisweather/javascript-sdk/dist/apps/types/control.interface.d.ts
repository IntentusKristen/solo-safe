import { ButtonOptions, ComponentOptions, RangeItem, ViewOptions } from '.';
/**
 * An interface for components that support toggleable state.
 *
 * @export
 * @interface Toggleable
 */
export interface Toggleable {
    id?: string;
    identifier?: string;
    /**
     * A Boolean indicating whether the element is currently selected.
     *
     * @type {boolean}
     * @memberof Toggleable
     */
    selected: boolean;
    /**
     * Sets the state to selected.
     *
     * @memberof Toggleable
     */
    select(): void;
    /**
     * Sets the state to unselected.
     *
     * @memberof Toggleable
     */
    deselect(): void;
    /**
     * Sets the disabled state of the control.
     *
     * @param {boolean} value
     * @memberof Toggleable
     */
    disable(value: boolean): void;
}
export interface RangeControlOptions extends ViewOptions {
    title?: string;
    intervals?: RangeItem[] | number[] | string;
    range?: {
        min: number;
        max: number;
        interval: number;
    };
}
/**
 * A data type that represents the configuration options for a range slider component.
 */
export interface RangeSliderOptions extends ComponentOptions {
    /**
     * Title to render above the component.
     *
     * @type {string}
     */
    title?: string;
    /**
     * Value range.
     *
     * @type {{
     * 		min: number;
     * 		max: number;
     * 	}}
     */
    range?: {
        min: number;
        max: number;
    };
    /**
     *
     *
     * @type {number}
     */
    count?: number;
    /**
     * Interval between snapped values.
     *
     * @type {number}
     */
    step?: number;
    /**
     * Labels to display along the slider, where the key is the value within the range and the
     * value is the label string to display.
     *
     * When used in conjunction with `marksEvery`, the marks defined using this property will
     * always be rendered and will override the automatically generated values.
     *
     * @type {{ [key: number]: string }}
     */
    marks?: {
        [key: string]: string;
    };
    /**
     * Interval to automatically add step marks/labels for within the range.
     *
     * If a number is provided, this interval will be based on the step count/index (e.g. render a mark
     * every `x` steps). If you want to render a mark based on the actual value at each step, provide
     * a string that is prefixed with a percent sign, which will render a mark when a step's value
     * is divisible by the following number (e.g. `% 12` will render a mark when a step's value is
     * evenly divisible by `12`).
     *
     * @type {(number | string)}
     */
    marksEvery?: number | string;
    marksFormatter?: (value: number) => string;
    /**
     * A Boolean indicating whether dots should be rendered at each step.
     *
     * @type {boolean}
     */
    dots?: boolean;
    /**
     * A Boolean indicating whether the control is enabled.
     *
     * @type {boolean}
     */
    disabled?: boolean;
    /**
     * Initial value as an array of numbers, where the first value represents the minimum value
     * in the range, and the second value represents the maximum value.
     *
     * @type {number[]}
     */
    value?: number[];
    /**
     * Width of the slider bar.
     *
     * @type {number}
     */
    width?: number;
    /**
     * A Boolean value indicating whether a tooltip should be displayed while one of the control's
     * handles is focused, in which case the tooltip will display the current value for the
     * handle.
     *
     * Alternatively, a function can be provided which will receive the handle's current
     * value as a parameter and the tooltip content is returned. If `null` is returned, then the
     * tooltip will not be displayed for that value.
     *
     * @type {boolean | ((value: number) => string)}
     */
    tooltip?: boolean | ((value: number) => string);
}
/**
 * A data type that represents the configuration options for search field component.
 */
export interface SearchFieldOptions extends ViewOptions {
    /**
     * Placeholder text for the input field.
     *
     * @type {string}
     */
    placeholder?: string;
    /**
     * A Boolean indicating whether a search request should be triggered whenever the input field's
     * value changes.
     *
     * @type {boolean}
     */
    autocomplete?: boolean;
    /**
     * A Boolean indicating whether the first search result should automatically be selected,
     * allowing the user to use the Enter key to select it.
     *
     * @type {boolean}
     */
    autoselect: boolean;
    /**
     * Configuration for requesting and formatting data based on search results.
     *
     * @type {
     * 		request: (query: string) => Promise<any[]>;
     * 		formatter?: (data: any) => string;
     * 	}
     */
    data?: {
        /**
         * A function that returns a Promise that performs the necessary search request using the
         * specified query from the field.
         *
         * @type {(query: string) => Promise<any[]>}
         */
        request: (query: string) => Promise<any[]>;
        /**
         * A function that is used to format each result returned by the search request before
         * rendering it in the field's search results.
         *
         * @type {(data: any) => string}
         *
         */
        formatter?: (data: any) => string;
    };
}
/**
 * A data type that represents the configuration options for a switch component.
 */
export interface SwitchOptions extends ButtonOptions {
    label?: string;
    values: {
        value: string;
        label: string;
    }[] | string[];
}
/**
 * A data type that represents the configuration options for a tooltip.
 */
export interface TooltipOptions {
    /**
     * CSS class name to add to the tooltip element.
     *
     * @type {string}
     */
    className?: string;
    /**
     *
     *
     * @type {string}
     */
    place?: string;
    /**
     * Animation effect when presenting and dismissing the tooltip.
     *
     * @type {string}
     */
    effect?: 'fade' | 'slide' | 'grow';
    /**
     * Position offset relative to the target.
     *
     * @type {number}
     */
    spacing?: number;
    showClose?: boolean;
}
