"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _EventDispatcher = _interopRequireDefault(require("../event/EventDispatcher"));

var _InfoPanelView = _interopRequireDefault(require("./views/InfoPanelView"));

var _utils = require("../utils");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var __rest = void 0 && (void 0).__rest || function (s, e) {
  var t = {};

  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];

  if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
  }
  return t;
};

const formatControlOpts = (opts, overrides) => (0, _utils.extend)({}, opts, overrides);
/**
 * A module manager is responsible for managing a series of modules associated with an application.
 *
 * @class ModuleManager
 */


class ModuleManager extends _EventDispatcher.default {
  /**
   * Initializes a module manager with the specified application.
   *
   * @param {InteractiveMapApp} app
   * @memberof ModuleManager
   */
  constructor(app) {
    super();
    this._moduleLegendCache = {};
    this._app = app;
    this._modules = {};
  }
  /**
   * Adds a module to the application.
   *
   * The specified module must either be an instance of a class that implements the
   * `IMapSourceModule` interface or a loader function that loads and initializes the module
   * on-demand.
   *
   * @param {IMapSourceModule} module
   * @param {*} [overrides=null]
   * @returns
   * @memberof ModuleManager
   */


  add(module, overrides = null, constructorOpts = null) {
    if (!(0, _utils.isset)(module)) {
      console.error(`[Aeris] Invalid module specified, received ${module}`);
      return;
    } // setup a module group if the provided module is an instance of ModuleGroup


    if ((0, _utils.has)(module, 'id') && (0, _utils.has)(module, 'load')) {
      this.addGroup(module, overrides);
      return;
    } // determine if we're loading in a pre-built module from the library, which we then need
    // to load and then create an instance of before adding


    if ((0, _utils.isFunction)(module)) {
      module().then(Module => {
        Module = Module.default || Module;

        if (!(0, _utils.isPlainObject)(Module)) {
          this.add(new Module(constructorOpts), overrides);
        } else {
          console.error('[Aeris] Module is not a valid class.');
        }
      }).catch(e => {
        console.error('[Aeris] Failed to load built-in module', e);
      });
      return;
    }

    if ((0, _utils.isEmpty)(module.id)) {
      throw new Error('[Aeris] Map modules must provide a unique identifier using the `id` property.');
    }

    if ((0, _utils.has)(module, 'initialize') === false) {
      throw new Error(`[Aeris] Cannot add invalid map module ${module.id}. Modules must implement the IMapSourceModule interface and its required methods.`);
    }

    this._modules[module.id] = module;
    module.initialize(this._app.account, this._app); // finish setting up module only once the app is ready

    this._onAppReady(() => {
      const {
        source,
        controls,
        legend,
        infopanel
      } = overrides || {};
      const sourceOpts = (0, _utils.extend)({}, module.source(), (0, _utils.isFunction)(source) ? source() : source);
      const legendOpts = (0, _utils.extend)({}, module.legend(), legend);
      const infoPanelOpts = (0, _utils.extend)({}, module.infopanel(), infopanel);
      const controlOpts = formatControlOpts(module.controls(), controls);

      if (!(0, _utils.isset)(sourceOpts) || (0, _utils.isEmpty)(sourceOpts)) {
        throw new Error(`[Aeris] Cannot add map module ${module.id}, a valid map content source was not provided.`);
      } // setup module controls first before adding its source so that initial state selection
      // on the controls will be set properly


      if (!module.group) {
        this._setupControls(module.id, controlOpts);
      }

      this._setupLegends(module.id, legendOpts);

      this._setupInfoPanel(module.id, infoPanelOpts);

      const dataSource = this._setupSource(module.id, sourceOpts);

      module.dataSource = dataSource;

      this._setupModuleEvents(module);

      this.trigger('module:load', {
        id: module.id,
        module
      });

      const appInitLayers = this._app.initialLayers();

      const layersPanel = this._app.panels.layers;

      if (layersPanel && (appInitLayers === null || appInitLayers === void 0 ? void 0 : appInitLayers.length) > 0) {
        const button = layersPanel.buttonForId(module.id);

        if (button) {
          layersPanel.select(appInitLayers);
        }
      }
    });
  }
  /**
   * Adds a module to the application and inserts its control at the specified index.
   *
   * The specified module must either be an instance of a class that implements the
   * `IMapSourceModule` interface or a loader function that loads and initializes the module
   * on-demand.
   *
   * @param index
   * @param module
   * @param overrides
   */


  insertAt(index, module, overrides = null, constructorOpts = null) {
    const options = Object.assign({}, overrides); // handle cases where `controls` is a function, which we need to override with a new function that injects the `index` value
    // into the final controls object

    if ((0, _utils.isFunction)(options.controls)) {
      const fn = options.controls;

      options.controls = defaults => Object.assign(Object.assign({}, fn(defaults)), {
        index
      });
    } else {
      options.controls = (0, _utils.extend)({}, options.controls, {
        index
      });
    }

    this.add(module, options, constructorOpts);
  }
  /**
   * Adds a module group to the application.
   *
   * @param {ModuleGroup} group
   * @param {*} [overrides=null]
   * @memberof ModuleManager
   */


  addGroup(group, overrides = null) {
    overrides = overrides || {};
    group.load().then(modules => {
      // const moduleControls = modules.map((m) => m.controls());
      // const groupControls = group.controls();
      // if (groupControls) {
      // 	groupControls.id = groupControls.id || group.id;
      // 	if (isPlainObject(groupControls)) {
      // 		if (isArray(groupControls.buttons)) {
      // 			groupControls.buttons = groupControls.buttons.concat(moduleControls);
      // 		} else {
      // 			groupControls.buttons = moduleControls;
      // 		}
      // 	} else if (isArray(groupControls)) {
      // 		groupControls.concat(moduleControls);
      // 	}
      // 	this._setupControls(group.id, groupControls);
      // }
      if ((0, _utils.has)(group, 'initialize')) {
        group.initialize(this._app.account, this._app);
      }

      this._onAppReady(() => {
        const defaultControls = group.controls();

        if (defaultControls) {
          const {
            controls: _controls
          } = overrides;
          let controlOpts = _controls; // if controlOverrides is a function, then we pass in the default controls and expect the callback to return the new options

          if ((0, _utils.isFunction)(_controls)) {
            controlOpts = _controls(defaultControls);
          } else {
            controlOpts = formatControlOpts(defaultControls, _controls);
          }

          this._setupControls(group.id, controlOpts);
        }

        this._setupGroupEvents(group);
      });

      const moduleOverrides = overrides.modules || {};
      modules.forEach(m => {
        m.group = group;
        this.add(m, moduleOverrides[m.id]);
      });
    }).catch(error => {
      console.error('[Aeris] Module group failed to load - ERROR', error);
    });
  }
  /**
   * Removes a module from the application.
   *
   * @param {IMapSourceModule} module
   * @memberof ModuleManager
   */


  remove(module) {
    const map = this._app.map;
    const source = map.getSourceForId(module.id);

    if (source) {
      map.removeSource(source);
    }

    delete this._modules[module.id];
    this.trigger('module:unload', {
      id: module.id,
      module
    });
  }

  removeById(identifier) {
    let module;
    Object.keys(this._modules).forEach(id => {
      if (id === identifier) {
        module = this._modules[id];
      }
    });

    if (module) {
      this.remove(module);
    }
  }

  _onAppReady(callback) {
    if (!callback) return;

    if (this._app.isReady()) {
      callback();
    } else {
      this._app.on('ready', () => callback());
    }
  }

  _setupSource(id, opts) {
    if (opts) {
      const {
        type
      } = opts,
            rest = __rest(opts, ["type"]);

      return this._app.addSource(id, type, rest);
    }

    throw new Error(`[Aeris] Cannot add module ${id}, source is invalid.`);
  }

  _setupControls(id, opts) {
    if (!opts) return;
    const layersPanel = this._app.panels.layers;

    if (layersPanel) {
      const index = opts.index;
      const config = (0, _utils.extend)({}, opts, {
        id
      });

      if ((0, _utils.isset)(index)) {
        delete config.index;
        layersPanel.insertAt(index, config);
      } else {
        layersPanel.add(config);
      }
    }
  }

  _setupLegends(id, opts) {
    if (!opts) return;
    const legendsPanel = this._app.panels.legends;

    if (legendsPanel) {
      const map = this._app.map;

      const layersPanel = this._app.getPanel('layers');

      const removeModuleLegend = moduleId => {
        legendsPanel.legend.remove(this._moduleLegendCache[moduleId]);
        delete this._moduleLegendCache[moduleId];
      };

      const addModuleLegend = moduleId => {
        const {
          title,
          url,
          code
        } = (0, _utils.isset)(opts.get) && (0, _utils.isFunction)(opts.get) ? opts.get() : opts;

        if (code === this._moduleLegendCache[moduleId]) {
          return;
        }

        removeModuleLegend(moduleId);

        if ((0, _utils.isset)(code)) {
          legendsPanel.legend.add(code, {
            account: this._app.account,
            within: {
              bounds: this._app.map.getBounds()
            },
            title
          });
          this._moduleLegendCache[id] = code;
        } else if ((0, _utils.isset)(url)) {
          legendsPanel.legend.add(id, {
            type: 'image',
            title,
            url
          });
          this._moduleLegendCache[id] = id;
        }
      };

      map.on('source:add', e => {
        const addedId = (0, _utils.get)(e.data, 'id');

        if (id === addedId) {
          addModuleLegend(id);
        }
      }).on('source:remove', e => {
        const removedId = (0, _utils.get)(e.data, 'id');

        if (id === removedId) {
          removeModuleLegend(id);
        }
      });

      if (layersPanel) {
        layersPanel.on('change', e => {
          const changedId = (0, _utils.get)(e.data, 'id');

          if (id === changedId) {
            addModuleLegend(id);
          }
        });
      }
    }
  }

  _setupInfoPanel(id, opts) {
    if (!opts) return;
    const {
      sections,
      view
    } = opts;
    const infoPanel = this._app.panels.info;

    if (infoPanel) {
      if (sections || view) {
        if (sections) {
          Object.keys(sections).forEach(key => _InfoPanelView.default.setSection(key, sections[key]));
        }

        if (view) {
          infoPanel.setContentView(id, view);
        }
      } else {
        infoPanel.setContentView(id, opts);
      }
    }
  }

  _setupModuleEvents(module) {
    const map = this._app.map;

    if ((0, _utils.has)(module, 'onAdd')) {
      map.on('source:add', e => {
        const id = (0, _utils.get)(e.data, 'id');

        if (id === module.id) {
          module.onAdd();
        }
      });
    }

    if ((0, _utils.has)(module, 'onRemove')) {
      map.on('source:remove', e => {
        const id = (0, _utils.get)(e.data, 'id');

        if (id === module.id) {
          module.onRemove();
        }
      });
    }

    if ((0, _utils.has)(module, 'onMarkerClick')) {
      map.on('marker:click', e => {
        const element = e.data.marker;
        const data = e.data.data || {};
        const source = data.awxjs_source;

        if (source === module.id) {
          module.onMarkerClick(element, data);
        }
      });
    }

    if ((0, _utils.has)(module, 'onShapeClick')) {
      map.on('shape:click', e => {
        const element = e.data.shape;
        const data = e.data.data || {};
        const source = data.awxjs_source;

        if (source === module.id) {
          module.onShapeClick(element, data);
        }
      });
    }

    if ((0, _utils.has)(module, 'onInit')) {
      module.onInit();
    }
  }

  _setupGroupEvents(module) {
    const map = this._app.map;
    const ids = module.modules.map(m => m.id); // include ids/values from group controls

    const controls = module.controls();

    if (controls && controls.buttons) {
      (controls.buttons || []).forEach(control => {
        const id = control.id || control.value;

        if (ids.indexOf(id) === -1) {
          ids.push(id);
        }
      });
    }

    if ((0, _utils.has)(module, 'onMarkerClick')) {
      map.on('marker:click', e => {
        const element = e.data.marker;
        const data = e.data.data || {};
        const source = data.awxjs_source;

        if (ids.indexOf(source) >= 0) {
          module.onMarkerClick(element, data);
        }
      });
    }

    if ((0, _utils.has)(module, 'onShapeClick')) {
      map.on('shape:click', e => {
        const element = e.data.shape;
        const data = e.data.data || {};
        const source = data.awxjs_source;

        if (ids.indexOf(source) >= 0) {
          module.onShapeClick(element, data);
        }
      });
    }

    if ((0, _utils.has)(module, 'onInit')) {
      module.onInit();
    }
  }

}

var _default = ModuleManager;
exports.default = _default;
module.exports = exports.default;