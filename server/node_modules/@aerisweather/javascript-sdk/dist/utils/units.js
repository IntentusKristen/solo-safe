"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.secondsToString = exports.formatDataValue = exports.formatMeasurement = exports.dataTypeForProp = exports.unitsForProp = exports.unitsForDataType = void 0;

var _ = require(".");

var _number = require("./number");

/**
 * @ignore
 */
const _units = {
  imperial: {
    temp: '&deg;F',
    speed: ' mph',
    distance: ' mi',
    height: ' ft',
    pressure: ' in',
    percent: '%',
    precip: '"',
    rain: '"',
    snow: '"',
    text: '',
    degree: '&deg;'
  },
  metric: {
    temp: '&deg;C',
    speed: ' km/h',
    distance: ' km',
    height: ' m',
    pressure: ' mb',
    percent: '%',
    precip: ' mm',
    rain: ' mm',
    snow: ' cm',
    phrase: 'met',
    degree: '&deg;'
  }
};
/**
 * @ignore
 */

const patterns = {
  temp: '(temp|dewpoint|dewpt|feelslike|windchill|heatindex)',
  speed: '(speed|gust|wind)',
  distance: '(visibility|distance)',
  height: '(ceiling|elev|elevation|height|ht)',
  pressure: '(pressure|altimeter)',
  rain: '(precip|rain|prcp)',
  snow: '(snow|snowdepth|hail)',
  text: '(phrase)',
  percent: '(rh|humid|pop|prob|sky|skycover)'
};

const unitsForDataType = (type, isMetric = false) => {
  if (isMetric) {
    return _units.metric[type] || '';
  }

  return _units.imperial[type] || '';
};

exports.unitsForDataType = unitsForDataType;

const unitsForProp = (prop, isMetric) => {
  const type = isMetric ? 'metric' : 'imperial';
  prop = prop.toLowerCase();
  let units;
  Object.keys(patterns).forEach(key => {
    const re = new RegExp(patterns[key], 'i');

    if (prop.match(re)) {
      units = (0, _.get)(_units, `${type}.${key}`);
    }
  });
  return units;
};

exports.unitsForProp = unitsForProp;

const dataTypeForProp = prop => {
  let result;
  prop = (prop || '').toLowerCase().replace(/\s/g, '');

  if (undefined !== patterns[prop]) {
    return prop;
  }

  if (/prob(ability)?/.test(prop)) {
    return 'percent';
  }

  Object.keys(patterns).forEach(key => {
    const re = new RegExp(patterns[key], 'i');

    if (re.test(prop)) {
      result = key;
    }
  });
  return result;
};

exports.dataTypeForProp = dataTypeForProp;

const formatMeasurement = (value, prop, isMetric = false, includeUnits = false, defaultValue = '--', unitsTemplate = null) => {
  if ((0, _.isset)(value) === false) {
    return defaultValue;
  }

  const type = dataTypeForProp(prop);

  if (!type) {
    return `${value}`;
  }

  let decimals = 0;
  let units = '';
  let spacer = ' ';

  if (type === 'temp') {
    spacer = '';
  } else if (type === 'pressure') {
    decimals = isMetric ? 0 : 2;
  } else if (type === 'rain') {
    decimals = isMetric ? 1 : 2;
  } else if (type === 'snow') {
    decimals = 1;
  } else if (type === 'distance') {
    decimals = 2;
  }

  if (decimals > 0) {
    value = parseFloat(value).toFixed(decimals);
  } else {
    value = Math.round(value);
  }

  if (includeUnits) {
    units = unitsForDataType(type, isMetric);

    if ((0, _.isset)(unitsTemplate)) {
      units = unitsTemplate.replace(/{{units}}/, units);
    }
  }

  return `${(0, _number.formatNumber)(value, decimals)}${spacer}${units}`;
};

exports.formatMeasurement = formatMeasurement;

const formatDataValue = (data, key, metricKey = null, isMetric = false) => {
  const prop = isMetric ? metricKey || key : key;
  return formatMeasurement((0, _.get)(data, prop), prop, isMetric, true, 'N/A', '<span class="units">{{units}}</span>');
};

exports.formatDataValue = formatDataValue;

const secondsToString = (value, includeSeconds = false) => {
  const result = [];
  const hours = Math.floor(value / 3600);
  const minutes = Math.floor((value - hours * 3600) / 60);
  const seconds = Math.floor(value - hours * 3600 - minutes * 60);

  if (hours > 0) {
    result.push(`${hours} hr`);
  }

  if (minutes > 0) {
    result.push(`${minutes} min`);
  }

  if (includeSeconds && seconds > 0) {
    result.push(`${seconds} sec`);
  }

  return result.join(', ');
};

exports.secondsToString = secondsToString;