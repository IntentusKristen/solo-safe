"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Color = exports.colorScale = exports.mix = exports.randomColor = exports.isLight = exports.readability = exports.luminance = exports.brightness = exports.toRGB = exports.rgbToHsv = exports.rgbToHsl = exports.rgbToHex = exports.hsvToRgb = exports.hslToRgb = exports.hexToRgb = exports.isValidHex = exports.isHSV = exports.isHSL = exports.isRGB = void 0;

var _ = require(".");

var _math = require("./math");

var _strings = require("./strings");

/* eslint-disable no-case-declarations */

/* eslint-disable no-multi-assign */

/**
 * Several color utility functions here are pulled from https://github.com/bgrins/TinyColor
 */
const isRGB = value => (0, _.hasKeys)(value, ['r', 'g', 'b']);

exports.isRGB = isRGB;

const isHSL = value => (0, _.hasKeys)(value, ['h', 's', 'l']);

exports.isHSL = isHSL;

const isHSV = value => (0, _.hasKeys)(value, ['h', 's', 'v']);

exports.isHSV = isHSV;

const isValidHex = hex => {
  // disable hex4 and hex8
  const lh = String(hex).charAt(0) === '#' ? 1 : 0;
  return hex.length !== 4 + lh && hex.length < 7 + lh;
};
/**
 * Converts the specified hex color string to an RGB object.
 *
 * Returns `{ r, g, b }` in the set `[0, 255]`.
 *
 * @param {string} hex
 * @returns {RGB}
 */


exports.isValidHex = isValidHex;

const hexToRgb = hex => {
  hex = hex.replace(/^#/, '');
  if (!(0, _.isString)(hex) || hex.length === 0) return null;
  const color = {
    r: 0,
    g: 0,
    b: 0,
    a: 1
  }; // eslint-disable-line object-curly-newline

  if (hex.length === 6) {
    color.r = parseInt(hex.substring(0, 2), 16);
    color.g = parseInt(hex.substring(2, 4), 16);
    color.b = parseInt(hex.substring(4), 16);
  }

  return color;
};
/**
 * Converts an HSL color value to RGB.
 *
 * Assumes `h` is contained in the set `[0, 360]` or `[0, 1]` and `s` and `l` are contained in the
 * set `[0, 100]` or `[0, 1]`.
 * Returns `{ r, g, b }` in the set `[0, 255]`.
 *
 * @param {HSL} hsl
 * @returns {RGB}
 */


exports.hexToRgb = hexToRgb;

const hslToRgb = hsl => {
  if (!isHSL(hsl)) return null;
  let r;
  let g;
  let b;
  let {
    h,
    s,
    l
  } = hsl; // eslint-disable-line object-curly-newline

  h = (0, _math.fraction)(h, 0, 360);
  s = (0, _math.fraction)(s, 0, 100);
  l = (0, _math.fraction)(l, 0, 100);

  const hue2rgb = (p, q, t) => {
    if (t < 0) t += 1;
    if (t > 1) t -= 1;
    if (t < 1 / 6) return p + (q - p) * 6 * t;
    if (t < 1 / 2) return q;
    if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;
    return p;
  };

  if (s === 0) {
    r = g = b = l; // achromatic
  } else {
    const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
    const p = 2 * l - q;
    r = hue2rgb(p, q, h + 1 / 3);
    g = hue2rgb(p, q, h);
    b = hue2rgb(p, q, h - 1 / 3);
  }

  return {
    r: Math.round(r * 255),
    g: Math.round(g * 255),
    b: Math.round(b * 255),
    a: hsl.a || 1
  };
};
/**
 * Converts an HSV color value to RGB.
 *
 * Assumes `h` is contained in the set `[0, 360]` or `[0, 1]` and `s` and `v` are contained in the
 * set `[0, 100]` or `[0, 1]`.
 * Returns `{ r, g, b }` in the set `[0, 255]`.
 *
 * @param {HSV} hsv
 * @returns {RGB}
 */


exports.hslToRgb = hslToRgb;

const hsvToRgb = hsv => {
  if (!isHSV(hsv)) return null;
  let {
    h,
    s,
    v
  } = hsv; // eslint-disable-line object-curly-newline

  h = (0, _math.fraction)(h, 0, 360) * 6;
  s = (0, _math.fraction)(s, 0, 100);
  v = (0, _math.fraction)(v, 0, 100);
  const i = Math.floor(h);
  const f = h - i;
  const p = v * (1 - s);
  const q = v * (1 - f * s);
  const t = v * (1 - (1 - f) * s);
  const mod = i % 6;
  const r = [v, q, p, p, t, v][mod];
  const g = [t, v, v, q, p, p][mod];
  const b = [p, p, t, v, v, q][mod];
  return {
    r: Math.round(r * 255),
    g: Math.round(g * 255),
    b: Math.round(b * 255),
    a: hsv.a || 1
  };
};
/**
 * Converts an RGB color to a hex string.
 *
 * Assumes `r`, `g`, and `b` are contained in the set `[0, 255]`.
 *
 * @param {RGB} rgb
 * @returns {string}
 */


exports.hsvToRgb = hsvToRgb;

const rgbToHex = rgb => {
  if (!isRGB(rgb)) return null;
  const parts = [rgb.r, rgb.g, rgb.b].map(x => {
    const hex = x.toString(16);
    return hex.length === 1 ? `0${hex}` : hex;
  });
  return `#${parts.join('')}`;
};
/**
 * Converts an RGB color value to HSL.
 *
 * Assumes `r`, `g`, and `b` are contained in the set `[0, 255]` or `[0, 1]`.
 * Returns `{ h, s, l }` in the set `[0, 1]`.
 *
 * @param {RGB} rgb
 * @returns {HSL}
 */


exports.rgbToHex = rgbToHex;

const rgbToHsl = rgb => {
  if (!isRGB(rgb)) return null;
  let {
    r,
    g,
    b
  } = rgb; // eslint-disable-line object-curly-newline

  r = (0, _math.fraction)(r, 0, 255);
  g = (0, _math.fraction)(g, 0, 255);
  b = (0, _math.fraction)(b, 0, 255);
  const min = Math.min(r, g, b);
  const max = Math.max(r, g, b);
  let h;
  let s;
  const l = (max + min) / 2;

  if (max === min) {
    // achromatic
    h = 0;
    s = 0;
  } else {
    const d = max - min;
    s = l > 0.5 ? d / (2 - max - min) : d / (max + min);

    switch (max) {
      case r:
        h = (g - b) / d + (g < b ? 6 : 0);
        break;

      case g:
        h = (b - r) / d + 2;
        break;

      case b:
        h = (r - g) / d + 4;
        break;

      default:
        break;
    }

    h /= 6;
  }

  return {
    h,
    s,
    l
  }; // eslint-disable-line object-curly-newline
};
/**
 * Converts an RGB color value to HSV.
 *
 * Assumes `r`, `g`, and `b` are contained in the set `[0, 255]` or `[0, 1]`.
 * Returns `{ h, s, v }` in the set `[0, 1]`.
 *
 * @param {RGB} rgb
 * @returns {HSV}
 */


exports.rgbToHsl = rgbToHsl;

const rgbToHsv = rgb => {
  if (!isRGB(rgb)) return null;
  let {
    r,
    g,
    b
  } = rgb; // eslint-disable-line object-curly-newline

  r = (0, _math.fraction)(r, 0, 255);
  g = (0, _math.fraction)(g, 0, 255);
  b = (0, _math.fraction)(b, 0, 255);
  const max = Math.max(r, g, b);
  const min = Math.min(r, g, b);
  let h;
  const v = max;
  const d = max - min;
  const s = max === 0 ? 0 : d / max;

  if (max === min) {
    h = 0; // achromatic
  } else {
    switch (max) {
      case r:
        h = (g - b) / d + (g < b ? 6 : 0);
        break;

      case g:
        h = (b - r) / d + 2;
        break;

      case b:
        h = (r - g) / d + 4;
        break;

      default:
        break;
    }

    h /= 6;
  }

  return {
    h,
    s,
    v
  }; // eslint-disable-line object-curly-newline
};
/**
 * Given a string or object, convert that input to RGB.
 *
 * @param {*} value
 * @returns {RGB}
 */


exports.rgbToHsv = rgbToHsv;

const toRGB = value => {
  if (isRGB(value)) {
    return value;
  }

  if (isHSL(value)) {
    return hslToRgb(value);
  }

  if (isHSV(value)) {
    return hsvToRgb(value);
  }

  if ((0, _.isString)(value)) {
    const m = /^(rgb|hsl|hsv)a?\((\d+),\s*([\d%]+),\s*([\d%]+)(?:,\s*(\d+(?:\.\d+)?))?\)$/.exec(`${value}`);

    if (m && m.length >= 5) {
      const type = m[1];
      const alpha = (0, _.isset)(m[5]) ? parseFloat(m[5]) : 1;
      const p = m.slice(2, 5).map(v => (0, _strings.isPercentage)(v) ? v : parseInt(v, 10));

      if (type === 'rgb' || type === 'rgba') {
        return {
          r: (0, _math.clamp)(p[0], 0, 255),
          g: (0, _math.clamp)(p[1], 0, 255),
          b: (0, _math.clamp)(p[2], 0, 255),
          a: alpha
        };
      }

      if (type === 'hsl') {
        const hsl = {
          h: p[0],
          s: p[1],
          l: p[2],
          a: alpha
        };
        return hslToRgb(hsl);
      }

      if (type === 'hsv') {
        const hsv = {
          h: p[0],
          s: p[1],
          v: p[2],
          a: alpha
        };
        return hsvToRgb(hsv);
      }
    } else {
      return hexToRgb(value);
    }
  }

  return null;
};
/**
 * Returns the brightness of the specified color value.
 *
 * The value for `color` can either be a color string or an RGB, HSV or HSL object.
 *
 * @param {*} color
 * @returns {number}
 */


exports.toRGB = toRGB;

const brightness = color => {
  const rgb = toRGB(color);
  return (rgb.r * 299 + rgb.g * 587 + rgb.b * 114) / 1000;
};
/**
 * Returns the luminance of the specified color value.
 *
 * The value for `color` can either be a color string or an RGB, HSV or HSL object.
 *
 * @param {string | RGB} color
 * @returns {number}
 */


exports.brightness = brightness;

const luminance = color => {
  const rgb = toRGB(color);
  if (!rgb) return null;
  return 0.2126 * rgb.r + 0.7152 * rgb.g + 0.0722 * rgb.b;
};
/**
 * Analyze the two colors and return the color contrast defined by WCAG version 2.
 *
 * @param {*} color1
 * @param {*} color2
 * @returns {number}
 */


exports.luminance = luminance;

const readability = (color1, color2) => {
  const c1 = toRGB(color1);
  const c2 = toRGB(color2);
  return (Math.max(luminance(c1), luminance(c2)) + 0.05) / (Math.min(luminance(c1), luminance(c2)) + 0.05);
};
/**
 * Returns whether the specified color is light based on its luminance.
 *
 * The value for `color` can either be a color string or an RGB, HSV or HSL object.
 *
 * @param {string | Color} color
 * @returns {boolean}
 */


exports.readability = readability;

const isLight = color => {
  const lum = luminance(color);
  return lum && lum >= 140;
};
/**
 * Returns a random color as RGB.
 *
 * @returns {RGB}
 */


exports.isLight = isLight;

const randomColor = () => ({
  r: (0, _math.random)(0, 255),
  g: (0, _math.random)(0, 255),
  b: (0, _math.random)(0, 255),
  a: 1
});
/**
 * Returns a new color as RGB by linearly interpolating between two color values.
 *
 * @param {*} start	Starting color value
 * @param {*} end Ending color value
 * @param {number} ratio Value to use to interpolate between in the set `[0, 1]`
 * @returns {RGB}
 */


exports.randomColor = randomColor;

const mix = (start, end, ratio) => {
  start = toRGB(start);
  end = toRGB(end);
  if (!(0, _.isset)(start) || !(0, _.isset)(end)) return null;
  const sc = start;
  const ec = end;
  const r = (0, _math.lerp)(sc.r, ec.r, ratio);
  const g = (0, _math.lerp)(sc.g, ec.g, ratio);
  const b = (0, _math.lerp)(sc.b, ec.b, ratio);
  const a = (0, _math.lerp)(sc.a, ec.a, ratio);
  return {
    r: Math.round(r),
    g: Math.round(g),
    b: Math.round(b),
    a
  };
};
/**
 * Generates an array of linearly interpolated color values defined by starting and ending color
 * values and the total number of color stops, or steps, in the scale.
 *
 * @param {(RGB | string)} start
 * @param {(RGB | string)} end
 * @param {number} steps
 * @returns {RGB[]}
 */


exports.mix = mix;

const colorScale = (start, end, steps) => {
  const delta = 1 / (steps - 1);
  const scale = [];

  for (let i = 0; i < steps; i += 1) {
    const color = mix(start, end, delta * i);
    scale.push(color);
  }

  return scale;
};
/**
 * A convenience class for working with and manipulating colors.
 *
 * @export
 * @class Color
 */


exports.colorScale = colorScale;

class Color {
  constructor(value) {
    this._rgb = toRGB(value);
  }
  /**
   * Returns the color's red value in the set `[0, 255]`.
   *
   * @type {number}
   * @memberof Color
   */


  get red() {
    return this._rgb.r;
  }
  /**
   * Sets the color's red value, which must be in the set `[0, 255]`.
   *
   * @memberof Color
   */


  set red(value) {
    this._rgb.r = value;
  }
  /**
   * Returns the color's green value in the set `[0, 255]`.
   *
   * @type {number}
   * @memberof Color
   */


  get green() {
    return this._rgb.g;
  }
  /**
   * Sets the color's green value, which must be in the set `[0, 255]`.
   *
   * @memberof Color
   */


  set green(value) {
    this._rgb.g = value;
  }
  /**
   * Returns the color's blue value in the set `[0, 255]`.
   *
   * @type {number}
   * @memberof Color
   */


  get blue() {
    return this._rgb.b;
  }
  /**
   * Sets the color's blue value, which must be in the set `[0, 255]`.
   *
   * @memberof Color
   */


  set blue(value) {
    this._rgb.b = value;
  }
  /**
   * Returns the color's alpha value in the set `[0, 1]`.
   *
   * @type {number}
   * @memberof Color
   */


  get alpha() {
    return this._rgb.a;
  }
  /**
   * Sets the color's alpha value, which must be in the set `[0, 1]`.
   *
   * @memberof Color
   */


  set alpha(value) {
    this._rgb.a = (0, _math.clamp)(value, 0, 1);
  }
  /**
   * Returns whether the color is light based on its luminance.
   *
   * @returns {boolean}
   * @memberof Color
   */


  isLight() {
    return isLight(this._rgb);
  }
  /**
   * Returns whether the color is dark based on its luminance.
   *
   * @returns {boolean}
   * @memberof Color
   */


  isDark() {
    return !this.isLight();
  }
  /**
   * Returns the brightness of the color.
   *
   * @returns {number}
   * @memberof Color
   */


  brightness() {
    return brightness(this._rgb);
  }
  /**
   * Returns the luminance of the color.
   *
   * @returns {number}
   * @memberof Color
   */


  luminance() {
    return luminance(this._rgb);
  }
  /**
   * Increases the lightness of the color by a specified percentage.
   *
   * @param {number} amount
   * @memberof Color
   */


  lighten(percent = 10) {
    percent = (0, _math.clamp)(percent, 0, 100);
    const hsl = this.toHsl();
    let lightness = parseFloat(`${hsl.l}`);
    lightness += percent;
    hsl.l = (0, _math.clamp)(lightness, 0, 1);
    return toRGB(hsl);
  }
  /**
   * Brightens the color by a specified percentage.
   *
   * @param {number} percent
   * @memberof Color
   */


  brighten(percent = 10) {
    percent = (0, _math.clamp)(percent, 0, 100);
    const rgb = this._rgb;
    this.red = (0, _math.clamp)(rgb.r - Math.round(255 * -percent), 0, 255);
    this.green = (0, _math.clamp)(rgb.g - Math.round(255 * -percent), 0, 255);
    this.blue = (0, _math.clamp)(rgb.b - Math.round(255 * -percent), 0, 255);
  }
  /**
   * Darkens the color by a specified percentage.
   *
   * @param {number} percent
   * @memberof Color
   */


  darken(percent = 10) {
    percent = (0, _math.clamp)(percent, 0, 100);
    const hsl = this.toHsl();
    let lightness = parseFloat(`${hsl.l}`);
    lightness -= percent;
    hsl.l = (0, _math.clamp)(lightness, 0, 1);
    return toRGB(hsl);
  }
  /**
   * Returns the hex value for the color.
   *
   * @returns {string}
   * @memberof Color
   */


  toHex() {
    return rgbToHex(this._rgb);
  }
  /**
   * Returns the HSL (hue, saturation, lightness) for the color.
   *
   * @returns {HSL}
   * @memberof Color
   */


  toHsl() {
    return rgbToHsl(this._rgb);
  }
  /**
   * Returns the HSV (hue, saturation, value) for the color.
   *
   * @returns {HSV}
   * @memberof Color
   */


  toHsv() {
    return rgbToHsv(this._rgb);
  }
  /**
   * Returns a string representation of the color in the specified format.
   *
   * @param {string} [format]
   * @returns {string}
   * @memberof Color
   */


  toString(format) {
    format = format || 'hex';
    const rgb = this._rgb;
    let formatted = null;

    switch (format) {
      case 'rgb':
        if (rgb.a === 1) {
          formatted = `rgb("${rgb.r}", "${rgb.g}", "${rgb.b}")`;
        } else {
          formatted = `rgba("${rgb.r}", "${rgb.g}", "${rgb.b}", "${rgb.a}")`;
        }

        break;

      case 'hex':
        formatted = rgbToHex(rgb);
        break;

      case 'hsl':
        const hsl = rgbToHsl(rgb);

        if (hsl) {
          if (rgb.a === 1) {
            formatted = `hsl(
							"${Math.round(hsl.h * 360)}",
							"${(0, _strings.isPercentage)(hsl.s) ? hsl.s : Math.round(hsl.s * 100)}%",
							"${(0, _strings.isPercentage)(hsl.l) ? hsl.l : Math.round(hsl.l * 100)}%"
						)`;
          } else {
            formatted = `hsla(
							"${Math.round(hsl.h * 360)}",
							"${(0, _strings.isPercentage)(hsl.s) ? hsl.s : Math.round(hsl.s * 100)}%",
							"${(0, _strings.isPercentage)(hsl.l) ? hsl.l : Math.round(hsl.l * 100)}%",
							"${this.alpha}"
						)`;
          }
        }

        break;

      case 'hsv':
        const hsv = rgbToHsv(rgb);

        if (hsv) {
          if (rgb.a === 1) {
            formatted = `hsv(
							"${Math.round(hsv.h * 360)}",
							"${(0, _strings.isPercentage)(hsv.s) ? hsv.s : Math.round(hsv.s * 100)}%",
							"${(0, _strings.isPercentage)(hsv.v) ? hsv.v : Math.round(hsv.v * 100)}%"
						)`;
          } else {
            formatted = `hsva(
							"${Math.round(hsv.h * 360)}",
							"${(0, _strings.isPercentage)(hsv.s) ? hsv.s : Math.round(hsv.s * 100)}%",
							"${(0, _strings.isPercentage)(hsv.v) ? hsv.v : Math.round(hsv.v * 100)}%",
							"${this.alpha}"
						)`;
          }
        }

        break;

      default:
        break;
    }

    return formatted.replace(/"/g, '').replace(/[\s\n]/g, '').split(',').join(', ');
  }

}

exports.Color = Color;