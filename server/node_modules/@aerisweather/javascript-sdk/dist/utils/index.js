"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.extend = extend;
exports.loadStyles = exports.loadScript = exports.debounce = exports.isPromise = exports.dateFromISO = exports.adjustDate = exports.parseDate = exports.formatDate = exports.toTimeOffsetHours = exports.toTimeStr = exports.toQueryStr = exports.toRangeStr = exports.toBool = exports.interval = exports.flatten = exports.cloneDeep = exports.pickBy = exports.pick = exports.hasKeys = exports.has = exports.set = exports.get = exports.mergeUnique = exports.unique = exports.merge = exports.replace = exports.toUTC = exports.offsetToTime = exports.isZipcode = exports.isValidCoord = exports.isCoord = exports.isDOM = exports.isHTMLElement = exports.isPlainObject = exports.isObject = exports.isEmpty = exports.isDate = exports.isNumeric = exports.isNumber = exports.isString = exports.isBoolean = exports.isFunction = exports.isArray = exports.isset = exports.isUndefined = exports.isNull = exports.toTypeName = exports.toType = void 0;

var _format = _interopRequireDefault(require("date-fns/format"));

var _parse = _interopRequireDefault(require("date-fns/parse"));

var _formatDistanceStrict = _interopRequireDefault(require("date-fns/formatDistanceStrict"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const toString = {}.toString;

const toType = a => toString.call(a).match(/([a-z]+)(:?\])/i)[1];

exports.toType = toType;

const toTypeName = o => {
  const objectToString = Object.prototype.toString.call(o).slice(8, -1);

  if (objectToString === 'Function') {
    const instanceToString = o.toString();

    if (instanceToString.indexOf(' => ') !== -1) {
      return 'ArrowFunction';
    }

    const getFunctionName = /^function ([^(]+)\(/;
    const match = instanceToString.match(getFunctionName);

    if (match === null) {
      return 'AnonymousFunction';
    }

    return 'Function';
  }

  return objectToString;
};

exports.toTypeName = toTypeName;

const isNull = obj => obj === null;

exports.isNull = isNull;

const isUndefined = obj => undefined === obj;

exports.isUndefined = isUndefined;

const isset = obj => !isUndefined(obj) && !isNull(obj);

exports.isset = isset;

const isArray = value => toString.call(value) === '[object Array]';

exports.isArray = isArray;

const isFunction = value => typeof value === 'function';

exports.isFunction = isFunction;

const isBoolean = value => value === true || value === false || toString.call(value) === '[object Boolean]';

exports.isBoolean = isBoolean;

const isString = obj => toString.call(obj) === '[object String]';

exports.isString = isString;

const isNumber = obj => typeof obj === 'number' && !Number.isNaN(obj);

exports.isNumber = isNumber;

const isNumeric = obj => !isString(obj) && isNumber(obj) || isString(obj) && !isNull(obj.match(/^[\-\+]?\d*\.?\d*$/)) && !isNull(obj.match(/\d/));

exports.isNumeric = isNumeric;

const isDate = obj => isset(obj) && obj.constructor.toString().indexOf('Date') > -1 && typeof obj.getTime !== 'undefined' && !Number.isNaN(obj.getTime());

exports.isDate = isDate;

const isEmpty = obj => {
  if (!isset(obj)) return true;
  if (obj == null) return true;
  if (isNumber(obj)) return false;
  if (isArray(obj) || isString(obj)) return obj.length === 0;
  return Object.keys(obj).length === 0;
};

exports.isEmpty = isEmpty;

const isObject = value => value !== null && typeof value === 'object';

exports.isObject = isObject;

const isPlainObject = value => isObject(value) && value.constructor.name === 'Object' && !isArray(value) && !isFunction(value) && toString.call(value) === '[object Object]';

exports.isPlainObject = isPlainObject;

const isHTMLElement = value => value instanceof HTMLElement === true;

exports.isHTMLElement = isHTMLElement;

const isDOM = value => isObject(value) && (value.constructor.name === 'DOMtastic' || isset(value[0]));

exports.isDOM = isDOM;

const isMergebleObject = value => isPlainObject(value) && !Array.isArray(value);

const isCoord = str => /^(-?[\d\.]+),\s*(-?[\d\.]+)$/.test(str);

exports.isCoord = isCoord;

const isValidCoord = value => {
  const {
    lat,
    lon
  } = value || {
    lat: null,
    lon: null
  };
  return isset(lat) && isset(lon) && Number.isNaN(lat) === false && Number.isNaN(lon) === false;
};

exports.isValidCoord = isValidCoord;

const isZipcode = str => /^(\d\d\d\d\d(?:-\d\d\d\d)?|[ABCEGHJKLMNPRSTVXY]\d[A-Z] ?\d[A-Z]\d)$/.test(str);

exports.isZipcode = isZipcode;

const offsetToTime = str => {
  let offset = 0;
  const matches = (str || '').match(/^([\d\.-]+)(\w*)$/);

  if (matches && matches.length >= 3) {
    const [match, value, type] = matches;
    offset = parseFloat(value);

    if (/^days?/.test(type)) {
      offset *= 86400;
    } else if (/^hours?/.test(type)) {
      offset *= 3600;
    } else if (/^minutes?/.test(type)) {
      offset *= 60;
    }
  }

  return new Date().getTime() + offset * 1000;
};

exports.offsetToTime = offsetToTime;

const toUTC = date => {
  const utc = Date.UTC(date.getUTCFullYear(), date.getUTCMonth(), date.getUTCDate(), date.getUTCHours(), date.getUTCMinutes(), date.getUTCSeconds());
  return new Date(utc);
};

exports.toUTC = toUTC;

const replace = (target, value, replacement) => {
  if (target.indexOf(value) !== -1) {
    target[target.map((e, i) => [i, e]).filter(e => e[1] === value)[0][0]] = replacement;
  }
};

exports.replace = replace;

const merge = (target, ...sources) => {
  if (!sources.length) {
    return target;
  }

  const source = sources.shift();

  if (source === undefined) {
    return target;
  }

  if (isMergebleObject(target) && isMergebleObject(source)) {
    const targetObj = target;
    const sourceObj = source;
    Object.keys(source).forEach(key => {
      if (isMergebleObject(sourceObj[key])) {
        if (!targetObj[key]) {
          targetObj[key] = {};
        }

        merge(targetObj[key], sourceObj[key]);
      } else if (isset(sourceObj[key])) {
        targetObj[key] = sourceObj[key];
      }
    });
  } else if (isObject(target) && isObject(source)) {
    for (const name in source) {
      // eslint-disable-line no-restricted-syntax
      if (target.hasOwnProperty(name) && isset(source[name])) {
        // eslint-disable-line no-prototype-builtins
        target[name] = source[name];
      }
    }
  }

  return merge(target, ...sources);
};

exports.merge = merge;

const unique = ar => {
  const a = ar.concat();

  for (let i = 0; i < a.length; i += 1) {
    for (let j = i + 1; j < a.length; j += 1) {
      if (a[i] === a[j]) {
        a.splice(j--, 1); // eslint-disable-line no-plusplus
      }
    }
  }

  return a;
};

exports.unique = unique;

const mergeUnique = (arr1, arr2) => arr1.concat(arr2.filter(item => arr1.indexOf(item) === -1));
/**
 * Access a deep value inside a object.
 * Works by passing a path like "foo.bar", also works with nested arrays like "foo[0][1].baz"
 * @author Victor B. https://gist.github.com/victornpb/4c7882c1b9d36292308e
 * Unit tests: http://jsfiddle.net/Victornpb/0u1qygrh/
 */


exports.mergeUnique = mergeUnique;

const get = (obj, path, fallbackValue = undefined) => {
  if (typeof obj === 'undefined' || obj === null || !isset(path) || !isString(path)) return fallbackValue;
  const props = path.split(/[\.\[\]\"\']{1,2}/);
  const len = props.length;

  for (let i = 0; i < len; i += 1) {
    if (!isEmpty(props[i])) {
      obj = obj[props[i]];
      if (typeof obj === 'undefined' || obj === null) return fallbackValue;
    }
  }

  return typeof obj !== 'undefined' ? obj : fallbackValue;
};
/**
 * Set a deep property on nested objects.
 * @param  {object}   obj  A object
 * @param  {String}   path A path
 * @param  {Any}      val  Anything that can be set
 * @author Victor B. https://gist.github.com/victornpb/4c7882c1b9d36292308e
 */


exports.get = get;

const set = (obj, path, val) => {
  if (!isset(path)) return obj;
  const props = path.split('.');
  const len = props.length - 1;
  let i;

  for (i = 0; i < len; i += 1) {
    obj[props[i]] = obj[props[i]] || {};
    obj = obj[props[i]];
  }

  obj[props[i]] = val;
  return obj;
};

exports.set = set;

const has = (obj, path) => {
  if (!isset(path)) return false;
  const props = path.split(/[\.\[\]\"\']{1,2}/).filter(val => val !== '');
  return !!props.reduce((el, prop) => el && el[prop] ? el[prop] : undefined, obj);
};

exports.has = has;

const hasKeys = (obj, keys) => {
  if (!isArray(keys) || !isset(obj) || !isPlainObject(obj)) return false;
  let _has = true;
  keys.forEach(k => {
    if (obj.hasOwnProperty(k) === false) {
      // eslint-disable-line no-prototype-builtins
      _has = false;
    }
  });
  return _has;
};
/**
 * @ignore
 */


exports.hasKeys = hasKeys;

const _pick = (obj, paths, predicate) => {
  if (!paths || paths.length === 0) {
    return null;
  }

  const len = paths.length;
  const result = {};
  let index = 0;

  while (index < len) {
    const path = paths[index];
    const val = get(obj, path);

    if (predicate(val, path)) {
      set(result, path, val);
    }

    index += 1;
  }

  return result;
};

const pick = (obj, paths) => {
  return obj == null ? {} : _pick(obj, paths, (val, path) => has(obj, path));
};

exports.pick = pick;

const pickBy = (obj, predicate) => {
  if (obj == null) return {};
  const props = Object.keys(obj);
  return _pick(obj, props, (val, path) => predicate(val, path[0]));
};

exports.pickBy = pickBy;

const cloneDeep = obj => {
  if (isArray(obj)) {
    const ar = obj;

    if (ar.length > 0) {
      return ar.map(el => {
        if (isPlainObject(el)) {
          return cloneDeep(el);
        }

        return el;
      });
    }

    return ar.slice(0);
  }

  return merge({}, obj);
};

exports.cloneDeep = cloneDeep;

const flatten = (arr, result = []) => {
  for (let i = 0, length = arr.length; i < length; i += 1) {
    const value = arr[i];

    if (Array.isArray(value)) {
      flatten(value, result);
    } else {
      result.push(value);
    }
  }

  return result;
};

exports.flatten = flatten;

const interval = (value, int) => {
  if (value % int === 0) {
    return value;
  }

  return Math.round((value + int / 2) / int) * int;
};

exports.interval = interval;

const toBool = value => {
  if (isBoolean(value)) return value;
  if (isString(value)) return value === 'true' || value === '1';
  if (isNumber(value)) return value === 1;
  return false;
};

exports.toBool = toBool;

const toRangeStr = (min, max, valueInterval) => {
  const nearestInterval = (value, int) => Math.floor((value + int / 2) / int) * int;

  const minInterval = nearestInterval(min, valueInterval);
  const maxInterval = nearestInterval(max, valueInterval);

  if (minInterval === maxInterval) {
    return `${minInterval}`;
  }

  return `${minInterval}-${maxInterval}`;
};

exports.toRangeStr = toRangeStr;

const toQueryStr = obj => Object.keys(obj).map(k => `${encodeURIComponent(k)}=${encodeURIComponent(obj[k])}`).join('&');

exports.toQueryStr = toQueryStr;

const toTimeStr = (date, from) => {
  const relativeTo = from || new Date();

  if (Math.abs(date.getTime() - relativeTo.getTime()) < 60 * 1000) {
    return '';
  }

  const now = new Date();
  const month = 86400 * 30 * 1000;
  const delta = Math.abs(now.getTime() - date.getTime());

  if (delta > month) {
    return (0, _format.default)(date, 'M/d/yyyy');
  }

  const str = (0, _formatDistanceStrict.default)(relativeTo, date).replace(/\s+/, '');

  if (date.getTime() < relativeTo.getTime()) {
    return `-${str}`;
  }

  return str;
};

exports.toTimeStr = toTimeStr;

const toTimeOffsetHours = str => {
  str = str.replace(/\s/g, '');
  const factors = {
    second: 1 / 3600,
    minute: 1 / 60,
    hour: 1,
    day: 24,
    week: 168,
    month: 720,
    year: 8760
  };
  let offset = 0;
  const m = str.match(/[\d\.-]+\w+/g);

  if (m && m.length > 0) {
    m.forEach(result => {
      const parts = result.match(/^([\d\.-]+)(\w+)$/);

      if (parts && parts.length >= 3) {
        const val = parseFloat(parts[1]);
        const period = (parts[2] || '').replace(/s$/, '');
        const multiplier = factors[period] || 0;
        offset += val * multiplier;
      }
    });
  }

  return offset;
};
/**
 * Formats a date to a string using `date-fns`.
 */


exports.toTimeOffsetHours = toTimeOffsetHours;

const formatDate = (date, formatStr) => {
  if (!isset(formatStr) || isEmpty(formatStr)) {
    console.warn(`[Aeris] Cannot format date with invalid format string "${formatStr}". Refer to the supported format options at https://date-fns.org/docs/format`);
    return null;
  }

  return (0, _format.default)(date, formatStr);
};
/**
 * Converts a string to a Date using `date-fns`.
 */


exports.formatDate = formatDate;
const parseDate = _parse.default;
exports.parseDate = parseDate;

const adjustDate = (date, tzoffset = null) => {
  const utcOffset = new Date().getTimezoneOffset() * 60000;
  const tzShift = tzoffset ? utcOffset + tzoffset : 0; // need to add timezone offset difference between the local and alert timezones

  return new Date(date.getTime() + tzShift);
};

exports.adjustDate = adjustDate;

const dateFromISO = isoDate => {
  isoDate = isoDate || '';
  const parts = isoDate.split(/[\D\-\+]+/).map(v => parseInt(v, 10));
  const tz = isoDate.replace(/^.+\d\d(\-?\d\d\:\d\d)Z?$/, '$1');
  const utcOffset = new Date().getTimezoneOffset() / 60 * -1; // const result = new Date();
  // result.setUTCFullYear(parts[0]);
  // result.setUTCMonth(parts[1] - 1);
  // result.setUTCDate(parts[2]);
  // result.setUTCHours(parts[3]);
  // result.setUTCMinutes(parts[4]);
  // result.setUTCSeconds(parts[5]);
  // result.setUTCMilliseconds(parts[6]);

  const result = new Date(parts[0], parts[1] - 1, parts[2], parts[3], parts[4], parts[5]);
  let tzHourOffset = 0;

  if (!isEmpty(tz)) {
    const tzParts = tz.split(':');

    if (tzParts.length === 2) {
      const [h, m] = tzParts.map(v => parseInt(v, 10));
      tzHourOffset += h;
      tzHourOffset += m / 60;
    }
  } // result.setHours(result.getUTCHours() + tzHourOffset);


  return result;
};

exports.dateFromISO = dateFromISO;

const isPromise = value => isset(value) && has(value, 'then') && typeof value.then === 'function' // && Object.prototype.toString.call(value) === '[object Promise]'
;

exports.isPromise = isPromise;

const debounce = (fn, wait, isImmediate = false) => {
  let timeout;
  return function (...args) {
    const context = this;

    const later = () => {
      timeout = undefined;

      if (!isImmediate) {
        fn.apply(context, args);
      }
    };

    const shouldCall = isImmediate && timeout === undefined;

    if (timeout !== undefined) {
      clearTimeout(timeout);
    }

    timeout = setTimeout(later, wait);

    if (shouldCall) {
      fn.apply(context, args);
    }
  };
};

exports.debounce = debounce;

const loadScript = src => {
  return new Promise((resolve, reject) => {
    const script = document.createElement('script');
    script.type = 'text/javascript';
    script.charset = 'utf-8';
    script.async = true;
    script.src = src; // script.timeout = 120000;

    script.addEventListener('load', resolve);
    script.addEventListener('error', () => reject(new Error('Error loading script.')));
    script.addEventListener('abort', () => reject(new Error('Script loading aborted.')));
    document.body.appendChild(script);
  });
};

exports.loadScript = loadScript;

const loadStyles = src => {
  return new Promise((resolve, reject) => {
    const link = document.createElement('link');
    link.type = 'text/css';
    link.rel = 'stylesheet';

    link.onload = () => {
      resolve();
    };

    link.href = src;
    const head = document.getElementsByTagName('head');

    if (head) {
      head[0].appendChild(link);
    }
  });
};

exports.loadStyles = loadStyles;

function extend(...args) {
  // let args = Array.prototype.slice.call(arguments, 1);
  // let args = arguments;
  const len = args.length;
  if (len === 0) return null;
  let target = args[0] || {};
  if (len < 2 || target == null) return target;

  if (!isObject(target) && typeof target === 'function') {
    target = {};
  }

  let obj;
  let src;
  let cp;
  let clone;

  const assignKey = (o, key) => {
    src = target[key];
    cp = o[key]; // console.log('...key: '+key+', src: '+src+', cp: '+cp+', typeof: '+(typeof cp));
    // prevent endless loop

    if (target !== cp) {
      if (isset(cp) && isPlainObject(cp)) {
        if (isArray(cp)) {
          clone = src && isArray(src) ? src : []; // need to perform a deep copy of array so internal objects are no longer references

          const arCopy = [];
          cp.forEach((el, j) => {
            if (isPlainObject(el)) {
              arCopy[j] = cloneDeep(el);
            } else {
              arCopy[j] = el;
            }
          }); // target[key] = cp.slice();	// make copy of array instead of passing by reference

          target[key] = arCopy;
        } else if (isFunction(cp)) {
          target[key] = cp;
        } else if (isDate(cp)) {
          target[key] = cp;
        } else {
          clone = isset(src) && isPlainObject(src) ? src : {};
          target[key] = extend({}, clone, cp);
        }
      } else if (isset(cp)) {
        target[key] = cp;
      }
    }
  };

  for (let i = 1; i < len; i += 1) {
    obj = args[i];

    if (obj != null) {
      Object.keys(obj).forEach(key => assignKey(obj, key)); // eslint-disable-line no-loop-func
    }
  }

  return target;
}