"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.geoDistance = exports.radToDeg = exports.degToRad = exports.random = exports.fraction = exports.wrap = exports.clamp = exports.lerp = void 0;

var _strings = require("./strings");

/**
 * Linearly interpolate between two values.
 *
 * @param {number} a Start value of the range
 * @param {number} b End value of the range
 * @param {number} fraction Weight value used to interpolate between `a` and `b`.
 * @returns {number}
 */
const lerp = (a, b, fraction) => (b - a) * fraction + a;
/**
 * Constrain a value to lie between two values.
 *
 * @param {number} value
 * @param {number} min
 * @param {number} max
 * @returns {number}
 */


exports.lerp = lerp;

const clamp = (value, min, max) => Math.min(Math.max(value, min), max);
/**
 * Wraps a value so that it's within the specified range.
 *
 * @param {number} value
 * @param {number} min
 * @param {number} max
 * @returns {number}
 */


exports.clamp = clamp;

const wrap = (value, min, max) => {
  const range = max - min;
  return min + ((value - min) % range + range) % range;
};
/**
 * Takes a value from `[min, max]` and returns it as `[0, 1]`.
 *
 * @param {(number | string)} value
 * @param {number} min
 * @param {number} max
 * @returns {number}
 */


exports.wrap = wrap;

const fraction = (value, min, max) => {
  const isPercent = (0, _strings.isPercentage)(value);
  const delta = max - min;
  value = clamp(parseFloat(`${value}`), min, max); // process percentage value

  if (isPercent) {
    value = parseInt(`${value * max}`, 10) / 100;
  } // handle floating point rounding errors


  if (Math.abs(value - max) < 0.000001) {
    return 1;
  } // convert into [0, 1] range if it isn't already


  return value % delta / delta;
};

exports.fraction = fraction;

const random = (min, max) => Math.floor(Math.random() * (max - min + 1)) + min;

exports.random = random;

const degToRad = degrees => degrees * Math.PI / 180;

exports.degToRad = degToRad;

const radToDeg = radians => radians * 180 / Math.PI;

exports.radToDeg = radToDeg;

const geoDistance = (coord1, coord2) => {
  if (coord1.lat === coord2.lat && coord1.lon === coord2.lon) {
    return 0;
  } // const radlat1 = (Math.PI * coord1.lat) / 180;
  // const radlat2 = (Math.PI * coord2.lat) / 180;
  // const theta = coord1.lon - coord2.lon;
  // const radtheta = (Math.PI * theta) / 180;
  // let dist = Math.sin(radlat1) * Math.sin(radlat2) + Math.cos(radlat1) * Math.cos(radlat2) * Math.cos(radtheta);
  // if (dist > 1) {
  // 	dist = 1;
  // }
  // dist = Math.acos(dist);
  // dist = (dist * 180) / Math.PI;
  // dist = dist * 60 * 1.1515;
  // dist *= 1.609344; // convert miles to km


  const R = 6371e3; // R is earthâ€™s radius
  // const lat1 = 23.18489670753479; // starting point lat
  // const lat2 = 32.726601;         // ending point lat
  // const lon1 = 72.62524545192719; // starting point lon
  // const lon2 = 74.857025;         // ending point lon
  // const lat1radians = toRadians(lat1);
  // const lat2radians = toRadians(lat2);
  // const latRadians = toRadians(lat2-lat1);
  // const lonRadians = toRadians(lon2-lon1);

  const radlat1 = degToRad(coord1.lat);
  const radlat2 = degToRad(coord2.lat);
  const latRadians = degToRad(coord2.lat - coord1.lat);
  const lonRadians = degToRad(coord2.lon - coord1.lon);
  const a = Math.sin(latRadians / 2) * Math.sin(latRadians / 2) + Math.cos(radlat1) * Math.cos(radlat2) * Math.sin(lonRadians / 2) * Math.sin(lonRadians / 2);
  const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
  const dist = R * c;
  return dist;
};

exports.geoDistance = geoDistance;