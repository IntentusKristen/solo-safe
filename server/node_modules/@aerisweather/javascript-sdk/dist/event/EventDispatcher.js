"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _utils = require("../utils");

var _Event = _interopRequireDefault(require("./Event"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * The EventDispatcher class is the base class for all classes that dispatch events.
 *
 * @export
 * @class EventDispatcher
 */
class EventDispatcher {
  constructor() {
    /**
     * @ignore
     * @type {*}
     * @memberof EventDispatcher
     */
    this.parentEvent = null;
    /**
     * @ignore	 *
     * @protected
     * @type {*}
     * @memberof EventDispatcher
     */

    this._listeners = {};
  }
  /**
   * Registers a listener function to be executed each time an event occurs
   *
   * @param {string} type Name of the event to listen for. Value can contain multiple event names
   * separated by spaces to trigger the same handler function for each event name.
   * @param {Function} callback Handler function to be called when the event occurs
   * @param {*} [scope=null]
   * @param {number} [priority=0]
   * @returns {EventDispatcher}
   * @memberof EventDispatcher
   */


  on(type, callback, scope = null, priority = 0) {
    scope = scope || this;

    if (/\s+/.test(type)) {
      const events = type.split(' ');
      events.forEach(event => {
        this.on(event, callback, scope, priority);
      });
      return this;
    }

    let list = this._listeners[type];

    if (list == null) {
      list = [];
      this._listeners[type] = list;
    }

    let index = 0;
    let listener;
    let i = list.length - 1;

    while (i > -1) {
      listener = list[i];

      if (listener.callback === callback && listener.scope === scope) {
        list.splice(i, 1);
      } else if (index === 0 && listener.priority < priority) {
        index = i + 1;
      }

      i -= 1;
    } // insert the event listener to the list array at the index value


    list.splice(index, 0, {
      callback,
      scope,
      priority,
      once: false
    });
    return this;
  }
  /**
   * Registers a listener function to be executed the first time an event occurs.
   *
   * @param {string} type Name of the event to listen for. Value can contain multiple event names
   * separated by spaces to trigger the same handler function for each event name.
   * @param {Function} callback Handler function to be called when the event occurs
   * @param {*} [scope=null]
   * @param {number} [priority=0]
   * @returns {EventDispatcher}
   * @memberof EventDispatcher
   */


  once(type, callback, scope = null, priority = 0) {
    scope = scope || this;

    if (/\s+/.test(type)) {
      const events = type.split(' ');
      events.forEach(event => {
        this.once(event, callback, scope, priority);
      });
      return this;
    }

    this.on(type, callback, scope, priority); // get the listeners just added

    const list = this._listeners[type];
    const listener = list[0]; // change the value to true so it will be removed after `trigger` is called

    listener.once = true;
    return this;
  }
  /**
   * Removes a registered listener function for the specified event.
   *
   * @param {string} type Name of the event to remove the listener for.
   * @param {Function} callback Handler function to remove so it won't be executed next time the
   * event is triggered.
   * @param {*} [scope=null]
   * @returns {EventDispatcher}
   * @memberof EventDispatcher
   */


  off(type, callback, scope = null) {
    scope = scope || this;

    if (/\s+/.test(type)) {
      const events = type.split(' ');
      events.forEach(event => {
        this.off(event, callback, scope);
      });
      return this;
    }

    const list = this._listeners[type];

    if (undefined !== list) {
      let i = list.length - 1;

      while (i > -1) {
        // if the callback and scope are the same then remove the event listener
        if (list[i].callback === callback && list[i].scope === scope) {
          list.splice(i, 1);
          break;
        }

        i -= 1;
      }
    }

    return this;
  }

  offAll() {
    this._listeners = {};
    return this;
  }
  /**
   * Triggers the specified event so that all registered listeners will be executed with the
   * specified parameters.
   *
   * @param {*} type Event name to trigger
   * @param {*} [data=null] Object containing data to pass to all listener functions.
   * @returns {EventDispatcher}
   * @memberof EventDispatcher
   */


  trigger(type, data = null) {
    let event = type;
    console.log(type, data);

    if (typeof event === 'string') {
      event = new _Event.default(type, false, true, data);
    } else if (event instanceof _Event.default) {
      type = event.type;

      if ((0, _utils.isset)(data)) {
        event.data = data;
      }
    }

    if (event instanceof _Event.default && event.target == null) {
      event.target = this;
      event.currentTarget = this;
    }

    const list = this._listeners[type];

    if (undefined !== list) {
      const cachedList = list.slice();
      let i = cachedList.length - 1;
      let listener;

      while (i > -1) {
        // if cancellable and isImmediatePropagationStopped are true then break out of the
        // while loop
        if (event.cancellable === true && event.isImmediatePropagationStopped === true) {
          break;
        }

        listener = cachedList[i];
        listener.callback.call(listener.scope, event); // if the `once` value is true we want to remove the listener right after this
        // callback was called

        if (listener.once === true) {
          this.off(event.type, listener.callback, listener.scope);
        }

        i -= 1;
      }
    }

    if (this.parentEvent != null && event.bubbles === true) {
      if (event.cancellable === true && event.isImmediatePropagationStopped === true) {
        return this;
      } // assign the current object that is currently processing the event (e.g. event
      // bubbling at)


      event.currentTarget = this; // pass the event to the parentEvent (event bubbling)

      this.parentEvent.trigger(event);
    }

    return this;
  }
  /**
   * Returns whether the listeners are registered for the specified event name.
   *
   * @param {string} type
   * @returns {boolean}
   * @memberof EventDispatcher
   */


  has(type) {
    return this._listeners[type] !== undefined;
  }

}

var _default = EventDispatcher;
exports.default = _default;
module.exports = exports.default;