"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.modulesLoader = modulesLoader;
exports.default = void 0;

var _Account = _interopRequireDefault(require("./account/Account"));

var utils = _interopRequireWildcard(require("./utils"));

var strings = _interopRequireWildcard(require("./utils/strings"));

var colors = _interopRequireWildcard(require("./utils/color"));

var _DOM = _interopRequireDefault(require("./display/DOM"));

var _globals = require("./globals");

var _mapsgl = require("./modules/mapsgl");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _getRequireWildcardCache() { if (typeof WeakMap !== "function") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

var __awaiter = void 0 && (void 0).__awaiter || function (thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function (resolve) {
      resolve(value);
    });
  }

  return new (P || (P = Promise))(function (resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }

    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }

    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }

    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};

var __rest = void 0 && (void 0).__rest || function (s, e) {
  var t = {};

  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];

  if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
  }
  return t;
};

const isValidKey = key => utils.isEmpty(key) === false && utils.isString(key) && /_/.test(key) === false;

function modulesLoader(callback) {
  return __awaiter(this, void 0, void 0, function* () {
    const module = yield Promise.resolve().then(() => _interopRequireWildcard(require('./modules')));
    return new Promise((resolve, reject) => {
      const m = module.Modules;
      resolve(m);
      if (callback) callback(m);
    }).catch(error => {
      console.error('AerisWeather.Modules - ERROR', error);
    });
  });
}

;
/**
 * The main entry point for interacting with AerisWeather API services.
 */

class AerisWeather {
  /**
   * Initializes an AerisWeather instance configured with the specified client id and secret.
   * @param id
   * @param secret
   * @param server
   */
  constructor(id, secret, servers) {
    if (!isValidKey(id) || !isValidKey(secret)) {
      const error = new Error('AerisWeather must be initialized with valid access keys. Refer to https://www.aerisweather.com/support/docs/api/getting-started/ for more information.');
      console.error(error.message);
      throw error;
    }

    this._account = new _Account.default(id, secret);
    this._servers = servers || _globals.servers;
    this._account.servers = this._servers;
  }
  /**
   * Provides access to the library's utility functions.
   *
   * General utility functions are accessible at the root of the `utils` object, but additional
   * functions are available for specific data types, such as colors, strings, etc:
   *
   * - `utils.strings`: String-related utility functions
   * - `utils.colors`: Color-related utility functions
   * - `utils.dates`: Date-related utility functions
   *
   * @readonly
   * @type {({ [key: string]: Function | { [key: string]: Function }})}
   * @memberof AerisWeather
   */


  get utils() {
    return Object.assign(Object.assign({
      $: _DOM.default
    }, utils), {
      strings: Object.assign({}, strings),
      colors: Object.assign({}, colors),
      dates: {
        format: utils.formatDate,
        parse: utils.parseDate
      }
    });
  }
  /**
   * Returns the Account instance used when performing API requests.
   */


  account() {
    return this._account;
  }
  /**
   * Returns the API server used when performing API requests.
   */


  servers() {
    return this._servers;
  }
  /**
   * Creates and returns a new ApiRequest configured for the current account.
   *
   * @returns {ApiRequest}
   * @memberof AerisWeather
   */


  api(config) {
    return this.account().api(config);
  }
  /**
   * Creates and returns a new MapRequest configured for the current account.
   *
   * @returns {MapRequest}
   * @memberof AerisWeather
   */


  map(config) {
    return this.account().map(config);
  }
  /**
   * Provides access to the views module of the library.
   *
   * The `views` module is loaded asynchronously using this method, which means you'll need to
   * wait for it to be loaded before working with any of its features. You can use the `Promise`
   * that's returned, or provide a callback function as a parameter to be notified once the
   * module is available.
   *
   * @param {(views: any) => void} [callback]
   * @returns {Promise<any>}
   * @memberof AerisWeather
   */


  views(callback) {
    return __awaiter(this, void 0, void 0, function* () {
      const module = yield Promise.resolve().then(() => _interopRequireWildcard(require('./maps')));
      return new Promise((resolve, reject) => {
        const m = module.Views;
        m.setAccount(this.account());
        m.setServers(this.servers());
        resolve(module.Views);
        if (callback) callback(module.Views);
      }).catch(error => {
        console.error('AerisWeather.Views - ERROR', error);
      });
    });
  }
  /**
   * Provides access to the apps module of the library.
   *
   * The `apps` module is loaded asynchronously using this method, which means you'll need to
   * wait for it to be loaded before working with any of its features. You can use the `Promise`
   * that's returned, or provide a callback function as a parameter to be notified once the
   * module is available.
   *
   * @param {(apps: any) => void} [callback]
   * @returns {Promise<any>}
   * @memberof AerisWeather
   */


  apps(callback) {
    return __awaiter(this, void 0, void 0, function* () {
      const module = yield Promise.resolve().then(() => _interopRequireWildcard(require('./apps')));
      return new Promise((resolve, reject) => {
        const m = module.Apps;
        m.setAccount(this.account());
        m.setServers(this.servers());
        resolve(module.Apps);
        if (callback) callback(module.Apps);
      }).catch(error => {
        console.error('AerisWeather.Apps - ERROR', error);
      });
    });
  }
  /**
   * Provides access to the external modules library.
   *
   * The `modules` library is loaded asynchronously using this method, which means you'll need to
   * wait for it to be loaded before working with any of its features. You can use the `Promise`
   * that's returned, or provide a callback function as a parameter to be notified once the
   * library is available.
   *
   * @param {(modules: any) => void} [callback]
   * @returns {Promise<any>}
   * @memberof AerisWeather
   */


  modules(callback) {
    return __awaiter(this, void 0, void 0, function* () {
      return modulesLoader(callback);
    });
  }

  mapsgl(app, options = {}) {
    return new Promise((resolve, reject) => {
      const {
        version = 'latest'
      } = options,
            opts = __rest(options, ["version"]);

      Promise.all([utils.loadStyles(`https://cdn.aerisapi.com/sdk/js/mapsgl/${version}/aerisweather.mapsgl.css`), utils.loadScript(`https://cdn.aerisapi.com/sdk/js/mapsgl/${version}/aerisweather.mapsgl.js`)]).then(() => {
        var _a;

        const mapsgl = (_a = window.aerisweather) === null || _a === void 0 ? void 0 : _a.mapsgl;

        if (mapsgl) {
          (0, _mapsgl.setupMapsGL)(mapsgl, app, opts, controller => {
            resolve({
              controller,
              mapsgl
            });
          });
        } else {
          reject(new Error('Failed to load MapsGL library'));
        }
      }).catch(error => {
        console.error(`Failed to load MapsGL library for version '${version}'`, error);
      });
    });
  }

}

var _default = AerisWeather;
exports.default = _default;