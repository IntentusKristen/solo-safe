"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _domtastic = _interopRequireDefault(require("domtastic"));

var _strings = require("../utils/strings");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// / <reference path="./domtastic.d.ts" />
function _getStyle(target, prop) {
  let value;
  const defaultView = target.ownerDocument.defaultView; // W3C standard method

  if (defaultView && defaultView.getComputedStyle) {
    // sanitize property name to css notation (hyphen separate words)
    prop = prop.replace(/([A-Z])/g, "-$1").toLowerCase();
    return defaultView.getComputedStyle(target, null).getPropertyValue(prop);
  } // IE method


  if (target.currentStyle) {
    // sanitize property name to camelCase
    prop = prop.replace(/\-(\w)/g, (str, letter) => letter.toUpperCase());
    value = target.currentStyle[prop]; // convert other units to pixels in IE

    if (/^\d+(em|pt|%|ex)?$/i.test(value)) {
      return (value => {
        const oldLeft = target.style.left;
        const oldRsLeft = target.runtimeStyle.left;
        target.runtimeStyle.left = target.currentStyle.left;
        target.style.left = value || 0;
        value = `${target.style.pixelLeft}px`;
        target.style.left = oldLeft;
        target.runtimeStyle.left = oldRsLeft;
        return value;
      })(value);
    }
  }

  return value;
}

function _toNumber(str) {
  return parseFloat((str || '').replace(/[^0-9\.-]/, ''));
}

const _defaultDisplayMap = {};
const _elementDisplayMap = {};

function _storeDisplay(element) {
  const display = _getStyle(element, 'display');

  if (display && display !== 'none') {
    _elementDisplayMap[element] = display;
  }
}

function _getDefaultDisplay(element) {
  const nodeName = element.nodeName;
  let display = _elementDisplayMap[element];

  if (!display) {
    display = _defaultDisplayMap[nodeName];
  }

  if (display) {
    return display;
  }

  const doc = element.ownerDocument;
  const temp = doc.body.appendChild(doc.createElement(nodeName));
  display = _getStyle(temp, 'display');
  temp.parentNode.removeChild(temp);

  if (display === 'none') {
    display = 'block';
  }

  _defaultDisplayMap[nodeName] = display || 'block';
  return display;
}

function _matches(el, selector) {
  const matchesSelector = el.matches || el.webkitMatchesSelector || el.mozMatchesSelector || el.msMatchesSelector;

  if (matchesSelector) {
    return matchesSelector.call(el, selector);
  }

  return false;
}

function _clone(fn) {
  const temp = function temporary(...args) {
    return fn.apply(this, args);
  };

  for (const key in this) {
    if (fn.hasOwnProperty(key)) {
      temp[key] = fn[key];
    }
  }

  return temp;
}

;

const dataClone = _clone(_domtastic.default.fn.data); // extend DOMtastic API


_domtastic.default.fn.show = function () {
  this.each((el, i) => {
    el.style.display = _getDefaultDisplay(el);
  });
};

_domtastic.default.fn.hide = function () {
  this.each((el, i) => {
    _storeDisplay(el);

    el.style.display = 'none';
  });
};

_domtastic.default.fn.prev = function (selector) {
  let node = this[0]; // eslint-disable-line react/no-this-in-sfc

  while (node = node.previousSibling) {
    const el = node;

    if (node.nodeType === 1 && _matches(el, selector)) {
      return (0, _domtastic.default)(el);
    }
  }

  return null;
};

_domtastic.default.fn.next = function (selector) {
  let node = this[0];

  while (node = node.nextSibling) {
    const el = node;

    if (node.nodeType === 1 && _matches(el, selector)) {
      return (0, _domtastic.default)(el);
    }
  }

  return null;
};

_domtastic.default.fn.last = function () {
  const len = this.length;

  if (len > 0) {
    return (0, _domtastic.default)(this[len - 1]);
  } // return this.slice.call(len - 1, 1);


  return (0, _domtastic.default)([]);
};

_domtastic.default.fn.parents = function (selector) {
  const nodes = [];
  this.each(el => {
    while (el) {
      if (_matches(el, selector)) {
        nodes.push(el);
        break;
      } else {
        el = el.parentNode;
      }
    }
  });
  return (0, _domtastic.default)(nodes);
};

_domtastic.default.fn.replace = function (element) {
  if (typeof element === 'string') {
    const content = element.replace(/^[^<]+/, '').replace(/[\n\r\t.]+$/, '');
    element = (0, _domtastic.default)(content)[0];
  }

  if (element instanceof Node) {
    if (this instanceof Node) {
      this.replaceWith(element);
      return (0, _domtastic.default)(element);
    }

    const collection = [];
    this.each(el => {
      el.replaceWith(element);
      collection.push(element);
    });
    return (0, _domtastic.default)(collection);
  }

  return (0, _domtastic.default)([]);
};

_domtastic.default.fn.contains = function (element) {
  const node = this[0]; // eslint-disable-line react/no-this-in-sfc

  if (typeof element === 'string') {
    element = document.querySelector(element);
  } else if (element[0]) {
    element = element[0];
  }

  return node.contains(element);
};

_domtastic.default.fn.width = function (value) {
  if (value === undefined) {
    const el = this[0];
    if (!el) return null;
    return el.offsetWidth;
  }

  return this.each(el => {
    el.style.width = `${value}px`;
  });
};

_domtastic.default.fn.outerWidth = function (margins = false) {
  const el = this[0];
  if (!el) return null;
  let value = el.offsetWidth; // borders

  value += _toNumber(_getStyle(el, 'border-left-width')) + _toNumber(_getStyle(el, 'border-right-width')); // margins

  if (margins) {
    value += _toNumber(_getStyle(el, 'margin-left')) + _toNumber(_getStyle(el, 'margin-right'));
  }

  return value;
};

_domtastic.default.fn.height = function (value) {
  if (value === undefined) {
    const el = this[0];
    if (!el) return null;
    return el.offsetHeight;
  }

  return this.each(el => {
    el.style.height = `${value}px`;
  });
};

_domtastic.default.fn.outerHeight = function (margins = false) {
  const el = this[0];
  if (!el) return null;
  let value = el.offsetHeight; // borders

  value += _toNumber(_getStyle(el, 'border-top-width')) + _toNumber(_getStyle(el, 'border-bottom-width')); // margins

  if (margins) {
    value += _toNumber(_getStyle(el, 'margin-top')) + _toNumber(_getStyle(el, 'margin-bottom'));
  }

  return value;
};

_domtastic.default.fn.padding = function () {
  const el = this[0];
  return {
    top: _toNumber(_getStyle(el, 'padding-top')),
    right: _toNumber(_getStyle(el, 'padding-right')),
    bottom: _toNumber(_getStyle(el, 'padding-bottom')),
    left: _toNumber(_getStyle(el, 'padding-left'))
  };
};

_domtastic.default.fn.margins = function () {
  const el = this[0];
  return {
    top: _toNumber(_getStyle(el, 'margin-top')),
    right: _toNumber(_getStyle(el, 'margin-right')),
    bottom: _toNumber(_getStyle(el, 'margin-bottom')),
    left: _toNumber(_getStyle(el, 'margin-left'))
  };
};

_domtastic.default.fn.borders = function () {
  const el = this[0];
  return {
    top: _toNumber(_getStyle(el, 'border-top-width')),
    right: _toNumber(_getStyle(el, 'border-right-width')),
    bottom: _toNumber(_getStyle(el, 'border-bottom-width')),
    left: _toNumber(_getStyle(el, 'border-left-width'))
  };
};

_domtastic.default.fn.bounds = function (absolute = false, relative = null) {
  const el = this[0];
  const b = {};
  const rect = el.getBoundingClientRect();

  if (rect) {
    b.x = rect.x;
    b.y = rect.y;
    b.width = rect.width;
    b.height = rect.height;
    b.top = rect.top;
    b.left = rect.left;
    b.right = rect.right;
    b.bottom = rect.bottom;
  }

  if (absolute) {
    const scrollX = window.scrollX || window.pageXOffset;
    const scrollY = window.scrollY || window.pageYOffset;
    if (b.left) b.left += scrollX;
    if (b.top) b.top += scrollY;
    if (b.right) b.right += scrollX;
    if (b.bottom) b.bottom += scrollY;
    if (b.x) b.x += scrollX;
    if (b.y) b.y += scrollY;
  }

  if (relative) {
    const rb = (0, _domtastic.default)(relative).bounds(absolute);
    if (b.left) b.left -= rb.left;
    if (b.top) b.top -= rb.top;
    if (b.right) b.right = b.left + b.width;
    if (b.bottom) b.bottom = b.top + b.height;
    if (b.x) b.x -= rb.x;
    if (b.y) b.y -= rb.y;
  }

  return b;
};

_domtastic.default.fn.scroll = function () {
  const el = this[0];
  const pos = {
    top: 0,
    left: 0
  };

  if (el === window) {
    pos.top = window.pageYOffset || document.documentElement.scrollTop;
    pos.left = window.pageXOffset || document.documentElement.scrollLeft;
  } else {
    pos.top = el.scrollTop;
    pos.left = el.scrollLeft;
  }

  return pos;
};

_domtastic.default.fn.allData = function (key, value) {
  if (!key) return;
  if (this.length === 0) return;

  if (typeof key === 'string' && typeof value === 'undefined') {
    let val = this.data(key, value);

    if (!val && /-/.test(key)) {
      val = this.data((0, _strings.camelcase)(key), value);
    }

    if (!val) {
      const name = `data-${key.replace(/[A-Z]/g, '-$&').toLowerCase()}`;
      val = this[0].getAttribute(name); // set data value so it isn't changed later

      if (val) {
        if (val === 'true') {
          val = true;
        } else if (val === 'false') {
          val = false;
        } else if (val === 'null') {
          val = null;
        } // try to convert to a number if string doesn't change


        if (val === `${+val}`) {
          val = +val;
        } // convert to an object if needed


        if (/^(?:\{[\w\W]*\}|\[[\w\W]*\])$/.test(val)) {
          try {
            val = JSON.parse(val);
          } catch (e) {
            console.error('[Aeris] Failed parsing JSON string to object', e);
          }
        }

        key = (0, _strings.camelcase)(key);
        this.data(key, val);
      }
    }

    return val;
  }

  if (/-/.test(key)) {
    key = (0, _strings.camelcase)(key);
  }

  this.data(key, value);
};

_domtastic.default.fn.click = function () {
  this.each(el => {
    el.click();
  });
};

_domtastic.default.fn.focus = function () {
  this.each(el => {
    if (el instanceof HTMLInputElement) {
      el.focus();
    }
  });
};

_domtastic.default.fn.blur = function () {
  this.each(el => {
    if (el instanceof HTMLInputElement) {
      el.blur();
    }
  });
};

var _default = _domtastic.default;
exports.default = _default;
module.exports = exports.default;