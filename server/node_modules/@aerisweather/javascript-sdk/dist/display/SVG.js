"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SVG = void 0;

var _utils = require("../utils");

/**
 * @private
 */
const getPosition = (pos, size, container, translate) => {
  let x = 0;
  let y = 0;
  translate = (0, _utils.extend)({
    x: 0,
    y: 0
  }, translate);

  if ((0, _utils.isString)(pos)) {
    const anchor = pos;
    x = (container.width - size.width) / 2;
    y = (container.height - size.height) / 2;

    if (/^top/.test(anchor)) {
      y = 0;
    } else if (/^bottom/.test(anchor)) {
      y = container.height - size.height;
    }

    if (/left$/.test(anchor)) {
      x = 0;
    } else if (/right$/.test(anchor)) {
      x = container.width - size.width;
    }
  } else {
    const p = pos;
    x = p.x;
    y = p.y;
  }

  x += translate.x;
  y += translate.y;
  return {
    x,
    y
  };
};
/**
 * @private
 */


const getStyleAttributes = opts => {
  const strokeOpts = opts.stroke ? Object.keys(opts.stroke).reduce((value, key) => {
    const val = opts.stroke[key];

    if ((0, _utils.isset)(val)) {
      if (key === 'width') value += ` stroke-width="${val}"`;
      if (key === 'color') value += ` stroke="${val}"`;
      if (key === 'opacity') value += ` stroke-opacity="${val}"`;
    }

    return value;
  }, '') : '';
  const fillOpts = opts.fill ? Object.keys(opts.fill).reduce((value, key) => {
    const val = opts.fill[key];

    if ((0, _utils.isset)(val)) {
      if (key === 'color') value += ` fill="${val}"`;
      if (key === 'opacity') value += ` fill-opacity="${val}"`;
    }

    return value;
  }, '') : '';
  return fillOpts || strokeOpts ? `${fillOpts}${strokeOpts}` : '';
};
/**
 * The `SVG` module provides utility functions for generating the necessary HTML for various SVG
 * elements based on certain configurations and styles.
 */


var SVG;
exports.SVG = SVG;

(function (SVG) {
  SVG.calculateTextSize = (str, fontSize, fontStyle, padding) => {
    let width = 0;
    let height = 0;
    padding = padding || [0, 0];
    fontSize = fontSize || 12; // calculate bounding box of actual text if we have a document object

    if (window && window.document) {
      const doc = window.document;
      const el = doc.createElement('text');
      el.style.fontSize = (0, _utils.isString)(fontSize) ? `${fontSize}` : `${fontSize}px`;
      el.style.fontWeight = fontStyle || 'normal';
      el.style.visibility = 'hidden';
      el.innerHTML = str;
      doc.body.appendChild(el);
      const bbox = el.getBoundingClientRect();
      doc.body.removeChild(el);

      if (bbox.width > 0) {
        width = bbox.width;
      }

      if (bbox.height > 0) {
        height = bbox.height;
      }
    } // adjust size by text padding amounts


    const [ph, pv] = padding;
    width += ph * 2;
    height += pv * 2;
    return [width, height];
  };
  /**
   * Returns the SVG path string using the specified path value string and style options.
   *
   * @param {string} value
   * @param {SVGPathOptions} opts
   * @returns {string}
   * @memberof SVG
   */


  SVG.path = (value, opts) => {
    opts = (0, _utils.extend)({
      stroke: {
        opacity: 1
      },
      fill: {
        color: '#ffffff',
        opacity: 1
      }
    }, opts);
    const attr = getStyleAttributes(opts);
    return `<g${opts.transform ? ` transform="${opts.transform}"` : ``}><path d="${value}"${attr} /></g>`;
  };
  /**
   * Returns the SVG rectangle string for the specified width, height and style options.
   *
   * @param {number} width
   * @param {number} height
   * @param {SVGRectOptions} opts
   * @returns {string}
   * @memberof SVG
   */


  SVG.rect = (width, height, opts) => {
    opts = (0, _utils.extend)({
      margin: 0,
      radius: 0,
      stroke: null,
      fill: {
        color: '#ffffff',
        opacity: 1
      }
    }, opts);
    const {
      margin,
      radius
    } = opts;
    let offset = margin;

    if (opts.stroke && opts.stroke.width > 0) {
      offset += opts.stroke.width / 2;
      width -= opts.stroke.width;
      height -= opts.stroke.width;
    }

    let p = `M${offset + radius},${offset} `;
    p += `L${offset + width - radius},${offset} `;
    if (radius > 0) p += `A${radius},${radius} 0 0,1 ${offset + width},${offset + radius} `;
    p += `L${offset + width},${offset + height - radius} `;
    if (radius > 0) p += `A${radius},${radius} 0 0,1 ${offset + width - radius},${offset + height} `;
    p += `L${offset + radius},${offset + height} `;
    if (radius > 0) p += `A${radius},${radius} 0 0,1 ${offset},${offset + height - radius} `;
    p += `L${offset},${offset + radius} `;
    if (radius > 0) p += `A${radius},${radius} 0 0,1 ${offset + radius},${offset} `;
    p += 'Z';
    return SVG.path(p, opts);
  };
  /**
   * Returns the SVG circle string for the specified style options.
   *
   * @param {SVGCircleOptions} opts
   * @returns {string}
   * @memberof SVG
   */


  SVG.circle = (container, opts) => {
    opts = (0, _utils.extend)({
      position: 'center',
      translate: {
        x: 0,
        y: 0
      },
      radius: 0,
      stroke: null,
      fill: {
        color: '#ffffff',
        opacity: 1
      }
    }, opts);
    const radius = opts.radius || 8;
    const size = (radius + ((0, _utils.get)(opts, 'stroke.width') || 0) + 1) * 2;
    const pos = getPosition(opts.position, {
      width: size,
      height: size
    }, container, opts.translate);
    const attr = getStyleAttributes(opts); // shift position values to the center

    pos.x += size / 2;
    pos.y += size / 2;
    return `<circle${opts.transform ? ` transform="${opts.transform}"` : ``} cx="${pos.x}" cy="${pos.y}" r="${opts.radius}"${attr} />`;
  };
  /**
   * Returns the SVG text string for the specified value and style options.
   *
   * @param {string | number} value
   * @param {SVGTextOptions} opts
   * @returns {string}
   * @memberof SVG
   */


  SVG.text = (value, container, opts) => {
    opts = (0, _utils.extend)({
      position: 'center',
      translate: {
        x: 0,
        y: 0
      },
      anchor: 'start',
      size: 12,
      font: "'Helvetica','Arial',sans-serif",
      style: 'bold',
      color: '#222222'
    }, opts);
    value = value || opts.value;
    const [w, h] = SVG.calculateTextSize(`${value}`, opts.size, opts.style, opts.padding); // svg text is positioned relative to the baseline, so add the height to the vertical translate value
    // opts.translate.x += 1;

    opts.translate.y += h - 1;
    const pos = getPosition(opts.position, {
      width: w,
      height: h
    }, container, opts.translate);
    let content = '';

    if (opts.stroke) {
      const {
        color = '#333333',
        width = 2
      } = opts.stroke;
      content += `<text${opts.transform ? ` transform="${opts.transform}"` : ``} dominent-baseline="hanging" text-anchor="${opts.anchor}" x="${pos.x}" y="${pos.y}" style="font-family:${opts.font};font-size:${opts.size}px;font-weight:${opts.style};" stroke="${color}" stroke-width="${width}">${value || ''}</text>`; // eslint-disable-line max-len
    }

    content += `<text${opts.transform ? ` transform="${opts.transform}"` : ``} dominent-baseline="hanging" text-anchor="${opts.anchor}" x="${pos.x}" y="${pos.y}" style="font-family:${opts.font};font-size:${opts.size}px;font-weight:${opts.style};" fill="${opts.color}">${value || ''}</text>`; // eslint-disable-line max-len

    return content;
  };

  SVG.image = (url, container, opts) => {
    opts = (0, _utils.extend)({
      position: 'center',
      size: [30, 30]
    }, opts);
    url = url || opts.url;
    const [w, h] = opts.size;
    const pos = getPosition(opts.position, {
      width: w,
      height: h
    }, container, opts.translate);
    const [width, height] = opts.size;
    return `<image${opts.transform ? ` transform="${opts.transform}"` : ``} x="${pos.x}" y="${pos.y}" width="${width}" height="${height}" xlink:href="${url}" />`;
  };
  /**
   * Returns the SVG HTML string for the specified options and array of drawable elements.
   *
   * @param {number} width
   * @param {number} height
   * @param {string[]} elements
   * @param {string} [viewBox]
   * @returns {string}
   * @memberof SVG
   */


  SVG.svg = (width, height, elements, viewBox = null) => // eslint-disable-line max-len
  `<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" version="1.1" width="${width}" height="${height}"${viewBox ? ` viewBox="${viewBox}"` : ''}>
			${(elements || []).map(el => el).join('')}
		</svg>`;
  /**
   * Returns the SVG HTML string using the specified size and options.
   *
   * @param {number} width
   * @param {number} height
   * @param {any} opts
   * @returns {string}
   * @memberof SVG
   */


  SVG.draw = (width, height, opts) => {
    const {
      value
    } = opts;
    let allow = true;
    let requiresText = false;
    const {
      shape: shapeOpts,
      text: textOpts,
      image: imageOpts
    } = opts;
    let elements = []; // setup text element first if defined so we can adjust shape sizing as needed

    const textElements = [];

    if (textOpts) {
      const generateTextEl = (textValue, config) => {
        const val = textValue || config.value || '';
        const x = config.x || 0;
        const y = config.y || 0;
        const size = config.size || 12;
        const [w, h] = SVG.calculateTextSize(val, size, config.style, config.padding);
        const autoSize = (0, _utils.isset)(config.autosize) ? config.autosize : true; // don't allow this element if the text value is empty

        if ((0, _utils.isEmpty)(val)) return null;

        if (autoSize) {
          // update width and height if we have text to display
          if (w && h) {
            width = w;
            height = h;
          } else {
            width = 5 * val.length;
            height = size + 2;
          }
        }

        let offset = 0;

        if (shapeOpts && shapeOpts.stroke) {
          offset = shapeOpts.stroke.width / 2 || 0;
        }

        const element = SVG.text(val, {
          width,
          height
        }, (0, _utils.extend)(config, {
          x: offset + width / 2 + x,
          y: offset + Math.round(height - (height - size * 0.7) / 2) + y
        }));
        return element;
      };

      if ((0, _utils.isArray)(textOpts)) {
        textOpts.forEach(config => {
          const el = generateTextEl(value, config);
          if (el) textElements.push(el);
        });
      } else {
        const el = generateTextEl(value, textOpts);
        if (el) textElements.push(el);
      }

      if (textElements.length > 0) {
        requiresText = true;
      }
    }

    if (shapeOpts) {
      let w = width;
      let h = height;
      const {
        type,
        size
      } = shapeOpts;

      if (size && size.length === 2) {
        w = size[0];
        h = size[1];
      }

      if (type === 'rect') {
        const shape = SVG.rect(w, h, shapeOpts);
        elements.push(shape);
      } else if (type === 'path') {
        const shape = SVG.path((0, _utils.get)(shapeOpts, 'path'), shapeOpts);
        elements.push(shape);
      } else {
        const strokeWidth = (0, _utils.get)(shapeOpts, 'stroke.width') || 0;
        shapeOpts.radius = Math.floor((w - strokeWidth * 2) / 2);
        shapeOpts.center = {
          x: Math.round(w / 2) + 1,
          y: Math.round(h / 2) + 1
        };
        const shape = SVG.circle({
          width,
          height
        }, shapeOpts);
        elements.push(shape);
      }
    }

    if (imageOpts) {
      const url = imageOpts.url;

      if (url) {
        const x = imageOpts.x || 0;
        const y = imageOpts.y || 0;
        const center = {
          x: width / 2,
          y: height / 2
        };
        const [w, h] = imageOpts.size || [30, 30];
        const imageEl = SVG.image(url, {
          width,
          height
        }, (0, _utils.extend)(imageOpts, {
          x: center.x - w / 2 + x,
          y: center.y - h / 2 + y
        }));
        elements.push(imageEl);
      }
    }

    if (textElements.length > 0) {
      elements = elements.concat(textElements);
    } else if (requiresText) {
      allow = false;
    }

    return allow ? SVG.svg(width, height, elements, opts.viewBox) : null;
  };
})(SVG || (exports.SVG = SVG = {}));